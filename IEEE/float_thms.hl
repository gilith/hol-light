(* ========================================================================== *)
(* FLOATING POINT THEOREMS                                                    *)
(* ========================================================================== *)

(* needs "IEEE/common.hl";; *)
(* needs "IEEE/fixed_thms.hl";; *)
(* needs "IEEE/fixed.hl";; *)
(* needs "IEEE/float.hl";; *)

(* -------------------------------------------------------------------------- *)
(* Valid flformat properties                                                  *)
(* -------------------------------------------------------------------------- *)

let FLFORMAT_SPLIT = TAUT `!(fmt:flformat).
  (dest_flformat fmt) = (FST (dest_flformat fmt),
                         SND (dest_flformat fmt))`;;

let FLFORMAT_VALID_IMP_RADIX_LT_1 =
  prove(`!(r:num) (p:num). ((is_valid_flformat (r,p)) ==>
                                      1 < (FST (r,p)))`,
        REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_flformat] THEN ARITH_TAC);;

let FLFORMAT_VALID_IMP_RADIX_EVEN =
  prove(`!(r:num) (p:num). ((is_valid_flformat (r,p)) ==>
                                      EVEN (FST (r,p)))`,
        REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_flformat] THEN MESON_TAC[]);;

let FLFORMAT_VALID_IMP_PREC_LT_1 =
  prove(`!(r:num) (p:num). ((is_valid_flformat (r,p)) ==>
                                      1 < (SND (r,p)))`,
        REPEAT GEN_TAC THEN REWRITE_TAC[is_valid_flformat] THEN MESON_TAC[]);;

let FLFORMAT_VALID =
  prove(`!(fmt:flformat). is_valid_flformat (dest_flformat fmt)`,
        REWRITE_TAC[flformat_typbij]);;

let FLFORMAT_RADIX_LT_1 =
  prove(`!(fmt:flformat). 1 < (flr fmt)`,
        GEN_TAC THEN REWRITE_TAC[flr] THEN ONCE_REWRITE_TAC[FLFORMAT_SPLIT] THEN
          MATCH_MP_TAC FLFORMAT_VALID_IMP_RADIX_LT_1 THEN
          REWRITE_TAC[FLFORMAT_VALID]);;

let FLFORMAT_RADIX_LT_0 =
  prove(`!(fmt:flformat). 0 < (flr fmt)`,
        GEN_TAC THEN MATCH_MP_TAC (ARITH_RULE `1 < x ==> 0 < x`) THEN
        REWRITE_TAC[FLFORMAT_RADIX_LT_1]);;

let FLFORMAT_RADIX_NE_0 =
  prove(`!(fmt:flformat). ~(&(flr fmt) = &0)`,
        GEN_TAC THEN REWRITE_TAC[REAL_OF_NUM_EQ] THEN MATCH_MP_TAC
        (ARITH_RULE `0 < x ==> ~(x = 0)`) THEN
        REWRITE_TAC[FLFORMAT_RADIX_LT_0]);;

let FLFORMAT_RADIX_EVEN =
  prove(`!(fmt:flformat). EVEN (flr fmt)`,
        GEN_TAC THEN REWRITE_TAC[flr] THEN ONCE_REWRITE_TAC[FLFORMAT_SPLIT] THEN
          MATCH_MP_TAC FLFORMAT_VALID_IMP_RADIX_EVEN THEN
          REWRITE_TAC[FLFORMAT_VALID]);;

let FLFORMAT_RADIX_LE_2 =
  prove(`!(fmt:flformat). 2 <= (flr fmt)`,
        GEN_TAC THEN
        SUBGOAL_THEN `!x. ~(x = 0) /\ EVEN x ==> 2 <= x` MATCH_MP_TAC THENL [
          GEN_TAC THEN
          DISCH_THEN (LABEL_CONJUNCTS_TAC ["xneq0"; "evenx"]) THEN
          ASM_CASES_TAC `x = 0` THENL [
            ASM_ARITH_TAC; ALL_TAC] THEN
          ASM_CASES_TAC `x = 1` THENL [
            USE_THEN "evenx" (fun evenx ->
            ASSUME_TAC (REWRITE_RULE[ASSUME `x = 1`] evenx)) THEN
            ASSUME_TAC (REWRITE_RULE[GSYM NOT_EVEN] (ARITH_RULE `ODD 1`)) THEN
            ASM_ARITH_TAC; ASM_ARITH_TAC]; ALL_TAC] THEN
        REWRITE_TAC[REWRITE_RULE[REAL_OF_NUM_EQ] FLFORMAT_RADIX_NE_0] THEN
        REWRITE_TAC[FLFORMAT_RADIX_EVEN]);;

let FLFORMAT_PREC_LT_1 =
  prove(`!(fmt:flformat). 1 < (flp fmt)`,
        GEN_TAC THEN REWRITE_TAC[flp] THEN ONCE_REWRITE_TAC[FLFORMAT_SPLIT] THEN
          MATCH_MP_TAC FLFORMAT_VALID_IMP_PREC_LT_1 THEN
          REWRITE_TAC[FLFORMAT_VALID]);;

let FLFORMAT_PREC_LT_0 =
  prove(`!(fmt:flformat). 0 < (flp fmt)`,
        GEN_TAC THEN MATCH_MP_TAC (ARITH_RULE `1 < x ==> 0 < x`) THEN
        REWRITE_TAC[FLFORMAT_PREC_LT_1]);;

let FLFORMAT_PREC_MINUS_1 =
  prove(`!(fmt:flformat). &0 <= (&(flp fmt):int) - (&1:int)`,
        REWRITE_TAC[ARITH_RULE `&0 <= x:int - &1:int <=> &1 <= x`] THEN
        REWRITE_TAC[INT_OF_NUM_LE] THEN
        REWRITE_TAC[ARITH_RULE `1 <= n <=> 0 < n`] THEN
        REWRITE_TAC[FLFORMAT_PREC_LT_0]);;

let FLFORMAT_PREC_IPOW_EQ_EXP =
  prove(`!(fmt:flformat). &(flr fmt) ipow (&(flp fmt) - &1) =
      &((flr fmt) EXP ((flp fmt) - 1))`,
        REPEAT GEN_TAC THEN MATCH_MP_TAC IPOW_EQ_EXP_P THEN
        REWRITE_TAC[FLFORMAT_PREC_LT_0]);;

let FLFORMAT_PREC_EXP_EQ_IPOW =
  prove(`!(fmt:flformat) (n:num). &((flr fmt) EXP n) = &(flr fmt) ipow (&n)`,
        REPEAT GEN_TAC THEN REWRITE_TAC[GSYM REAL_OF_NUM_POW] THEN
        REWRITE_TAC[ipow] THEN
        SUBGOAL_THEN `(&0:int) <= (&n)` (fun thm -> REWRITE_TAC[thm]) THENL [
          REWRITE_TAC[REAL_OF_NUM_LE] THEN ARITH_TAC; ALL_TAC] THEN
        REWRITE_TAC[NUM_OF_INT_OF_NUM]);;

let FLFORMAT_RADIX_IPOW_LE_0 =
  prove(`!(fmt:flformat) (e:int). &0 <= &(flr fmt) ipow e`,
        REPEAT GEN_TAC THEN
        MATCH_MP_TAC (ARITH_RULE `&0 < (x:real) ==> &0 <= x`) THEN
        MATCH_MP_TAC IPOW_LT_0 THEN
        REWRITE_TAC[REAL_OF_NUM_LT] THEN
        REWRITE_TAC[FLFORMAT_RADIX_LT_0]);;

let FLFORMAT_RADIX_IPOW_LT_0 =
  prove(`!(fmt:flformat) (e:int). &0 < &(flr fmt) ipow e`,
        REPEAT GEN_TAC THEN
        MATCH_MP_TAC IPOW_LT_0 THEN
        REWRITE_TAC[REAL_OF_NUM_LT] THEN
        REWRITE_TAC[FLFORMAT_RADIX_LT_0]);;

let FLFORMAT_RADIX_IPOW_NEQ_0 =
  prove(`!(fmt:flformat) (e:int). ~(&(flr fmt) ipow e = &0)`,
        REPEAT GEN_TAC THEN
        MATCH_MP_TAC (ARITH_RULE `&0 < (x:real) ==> ~(x = &0)`) THEN
        MATCH_MP_TAC IPOW_LT_0 THEN
        REWRITE_TAC[REAL_OF_NUM_LT] THEN
        REWRITE_TAC[FLFORMAT_RADIX_LT_0]);;

let FLFORMAT_RADIX_IPOW_ADD_EXP =
  prove(`!(fmt:flformat) (u:int) (v:int).
        &(flr fmt) ipow u * &(flr fmt) ipow v = &(flr fmt) ipow (u + v)`,
        REPEAT GEN_TAC THEN MATCH_MP_TAC IPOW_ADD_EXP THEN
        REWRITE_TAC[FLFORMAT_RADIX_NE_0]);;

let FLFORMAT_TO_FFORMAT =
  prove(`!(fmt:flformat) (e:int). ?(fmt':fformat).
          (to_fformat fmt e) = fmt' /\
          (fr fmt') = (flr fmt)     /\
          (fp fmt') = (flp fmt)     /\
          (fe fmt') = e`,
        REPEAT GEN_TAC THEN
        EXISTS_TAC `mk_fformat ((flr fmt), (flp fmt), e)` THEN
        REWRITE_TAC[to_fformat] THEN REWRITE_TAC[fr;fp;fe] THEN
        SUBGOAL_THEN `is_valid_fformat ((flr fmt), (flp fmt), e)`
           (LABEL_TAC "valid") THENL [
             REWRITE_TAC[is_valid_fformat] THEN
             REWRITE_TAC[FLFORMAT_RADIX_LT_1] THEN
             REWRITE_TAC[FLFORMAT_RADIX_EVEN] THEN
             REWRITE_TAC[FLFORMAT_PREC_LT_0]; ALL_TAC] THEN
        USE_THEN "valid" (fun valid ->
        REWRITE_TAC[REWRITE_RULE[fformat_typbij] valid]));;

(* a saner version *)
let FLFORMAT_TO_FFORMAT_2 =
  prove(`!(fmt:flformat) (e:int).
          (fr (to_fformat fmt e)) = (flr fmt) /\
          (fp (to_fformat fmt e)) = (flp fmt) /\
          (fe (to_fformat fmt e)) = e`,
        REPEAT GEN_TAC THEN REWRITE_TAC[to_fformat] THEN

        SUBGOAL_THEN `is_valid_fformat (flr fmt, flp fmt, (e:int))`
          (fun thm -> ASSUME_TAC (REWRITE_RULE[fformat_typbij] thm)) THENL [
            REWRITE_TAC[is_valid_fformat] THEN
            REWRITE_TAC[FLFORMAT_RADIX_LT_1] THEN
            REWRITE_TAC[FLFORMAT_RADIX_EVEN] THEN
            REWRITE_TAC[FLFORMAT_PREC_LT_0]; ALL_TAC] THEN

        REWRITE_TAC[fr; fp; fe] THEN
        ASM_REWRITE_TAC[]);;

(* -------------------------------------------------------------------------- *)
(* Useful ipow/exp properties, translated over to floating point              *)
(* -------------------------------------------------------------------------- *)

let FLOAT_IPOW_LE_REAL =
  prove(`!(fmt:flformat) (z:real). ?(e:int). z <= &(flr fmt) ipow e`,
        GEN_TAC THEN
        REWRITE_TAC[MATCH_MP IPOW_LE_REAL
                             (SPEC `fmt:flformat`FLFORMAT_RADIX_LE_2)]);;

let FLOAT_IPOW_LE_REAL_2 =
  prove(`!(fmt:flformat) (z:real). &0 < z ==> ?(e:int). &(flr fmt) ipow e <= z`,
        REPEAT GEN_TAC THEN DISCH_THEN (fun thm ->
        REWRITE_TAC[MATCH_MP IPOW_LE_REAL_2 (CONJ thm
        (SPEC `fmt:flformat`FLFORMAT_RADIX_LE_2))]));;

(* -------------------------------------------------------------------------- *)
(* Various float props                                                        *)
(* -------------------------------------------------------------------------- *)

let dump_float_defn isfloat =
  LABEL_TAC "isfloat" isfloat THEN
  CHOOSE_THEN
  (CHOOSE_THEN (LABEL_TAC "isfracexp"))
  (REWRITE_RULE[is_float] isfloat) THEN
  USE_THEN "isfracexp" (fun isfracexp -> LABEL_CONJUNCTS_TAC
  ["fgt0"; "fltrp"; "absxeq"] (REWRITE_RULE[is_frac_and_exp] isfracexp));;

let FLOAT_NEG =
  prove(`!(fmt:flformat) (x:real). is_float(fmt) x <=> is_float(fmt) (-- x)`,
        REPEAT GEN_TAC THEN REWRITE_TAC[is_float] THEN
        REWRITE_TAC[is_frac_and_exp] THEN
        REWRITE_TAC[ARITH_RULE `abs(-- x) = abs(x)`] );;

let FLOAT_NOT_ZERO =
  prove(`!(fmt:flformat) (x:real). is_float(fmt) x ==> ~(x = &0)`,
        REPEAT GEN_TAC THEN DISCH_THEN dump_float_defn THEN
        ONCE_REWRITE_TAC[GSYM REAL_ABS_ZERO] THEN
        MATCH_MP_TAC (ARITH_RULE
             `!y. (x:real) = y /\ ~(y = &0) ==> ~(x = &0)`) THEN
        EXISTS_TAC `&f * &(flr fmt) ipow (e - &(flp fmt) + &1)` THEN
        ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[REAL_ENTIRE] THEN REWRITE_TAC[DE_MORGAN_THM] THEN
        CONJ_TAC THENL [
          REWRITE_TAC[REAL_OF_NUM_EQ] THEN ASM_ARITH_TAC;
          MATCH_MP_TAC (ARITH_RULE `&0 < x ==> ~(x = &0)`) THEN
          REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]]);;

(* -------------------------------------------------------------------------- *)
(* greatest_e, greatest_m, greatest_r                                         *)
(* -------------------------------------------------------------------------- *)

let is_greatest_e = define
  `is_greatest_e (fmt:flformat) (x:real) (e:int) =
  (&(flr fmt) ipow e <= abs(x) /\ !(e':int). &(flr fmt) ipow e' <= abs(x)
     ==> e' <= e)`;;

let FLOAT_GREATEST_E_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
           ?(e:int). greatest_e(fmt) x = e /\ is_greatest_e(fmt) x e`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        SUBGOAL_THEN `~({ e:int | &(flr fmt) ipow e <= abs(x) } = {})`
           (LABEL_TAC "neqempty") THENL [
          REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
          REWRITE_TAC[IN_ELIM_THM] THEN
          USE_THEN "xneq0" (fun xneq0 ->
          REWRITE_TAC[MATCH_MP FLOAT_IPOW_LE_REAL_2
          (MATCH_MP
             (ARITH_RULE `~((x:real) = &0) ==> &0 < abs(x)`) xneq0)]);
          ALL_TAC] THEN
        SUBGOAL_THEN `?(b:int). !(e:int). e IN
              { e:int | &(flr fmt) ipow e <= abs(x) } ==> e <= b`
           (CHOOSE_THEN (LABEL_TAC "bound")) THENL [
          CHOOSE_TAC (SPECL [`fmt:flformat`; `abs((x:real))`]
                       FLOAT_IPOW_LE_REAL) THEN
          EXISTS_TAC `e:int` THEN
          GEN_TAC THEN REWRITE_TAC[IN_ELIM_THM] THEN
          DISCH_TAC THEN MATCH_MP_TAC IPOW_MONOTONE THEN
          EXISTS_TAC `(flr fmt)` THEN REWRITE_TAC[FLFORMAT_RADIX_LE_2] THEN
          ASM_ARITH_TAC; ALL_TAC] THEN
        USE_THEN "neqempty" (fun neqempty -> USE_THEN "bound" (fun bound ->
        CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["supint"; "issupint"])
        (MATCH_MP SUP_INT_BOUNDED (CONJ neqempty bound)))) THEN
        EXISTS_TAC `e':int` THEN REWRITE_TAC[greatest_e; is_greatest_e] THEN
        ASM_REWRITE_TAC[] THEN USE_THEN "issupint" (fun issupint ->
        (LABEL_CONJUNCTS_TAC ["inset"; "biggest"]) (REWRITE_RULE[is_sup_int]
        issupint)) THEN
        CONJ_TAC THENL [
          USE_THEN "inset" (fun inset -> REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM]
          inset]);
          USE_THEN "biggest" (fun biggest ->
          REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] biggest])]);;

let dump_ge_info xneq0 lbl =
  let concat s = String.concat "" [lbl; s] in
  CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC [concat "geeq"; concat "gebig"])
  (MATCH_MP (SPEC `fmt:flformat` FLOAT_GREATEST_E_EXISTS) xneq0) THEN
  USE_THEN (concat "gebig") (fun gebig ->
  LABEL_CONJUNCTS_TAC [concat "gebig1"; concat "gebig2"]
  (REWRITE_RULE[is_greatest_e] gebig));;

let dump_fl_ge_info isfloat lbl =
  dump_ge_info (MATCH_MP (SPEC `fmt:flformat` FLOAT_NOT_ZERO) isfloat) lbl;;

let FLOAT_GREATEST_E_UNIQUE =
  prove(`!(fmt:flformat) (x:real) (e1:int) (e2:int).
        is_greatest_e(fmt) x e1 /\ is_greatest_e(fmt) x e2 ==>
         e1 = e2`,
        REPEAT GEN_TAC THEN DISCH_THEN
        (LABEL_CONJUNCTS_TAC ["e1ge"; "e2ge"]) THEN
        USE_THEN "e1ge" (fun e1ge -> LABEL_CONJUNCTS_TAC ["e1leqx"; "e1big"]
        (REWRITE_RULE[is_greatest_e] e1ge)) THEN
        USE_THEN "e2ge" (fun e2ge -> LABEL_CONJUNCTS_TAC ["e2leqx"; "e2big"]
        (REWRITE_RULE[is_greatest_e] e2ge)) THEN
        SUBGOAL_THEN `(e1:int) <= e2` ASSUME_TAC THENL [
          USE_THEN "e2big" (fun e2big -> MATCH_MP_TAC e2big) THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN
        SUBGOAL_THEN `(e2:int) <= e1` ASSUME_TAC THENL [
          USE_THEN "e1big" (fun e1big -> MATCH_MP_TAC e1big) THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN
        ASM_ARITH_TAC);;

let FLOAT_GREATEST_E_NEG =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          greatest_e(fmt) (-- x) = greatest_e(fmt) x`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        MATCH_MP_TAC FLOAT_GREATEST_E_UNIQUE THEN
        EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `-- x` THEN
        SUBGOAL_THEN `~(-- x = &0)` (LABEL_TAC "negxneq0") THENL [
          ASM_ARITH_TAC; ALL_TAC] THEN
        USE_THEN "negxneq0" (fun negxneq0 -> dump_ge_info negxneq0 "negx") THEN
        ASM_REWRITE_TAC[] THEN REWRITE_TAC[is_greatest_e] THEN
        USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x") THEN
        ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[ARITH_RULE `abs(-- x) = abs(x)`] THEN
        ASM_REWRITE_TAC[]);;

let is_greatest_m = define
  `is_greatest_m (fmt:flformat) (x:real) (m:num) =
  (&m * &(flr fmt) ipow (greatest_e(fmt) x) <= abs(x) /\
  !(m':num). &m' * &(flr fmt) ipow (greatest_e(fmt) x) <= abs(x) ==>
   m' <= m)`;;

let FLOAT_GREATEST_M_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
           ?(m:num). greatest_m(fmt) x = m /\
                     is_greatest_m(fmt) x m /\
                     1 <= m /\
                     m < (flr fmt)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        SUBGOAL_THEN `1 IN { (m:num) |
              &m * &(flr fmt) ipow (greatest_e(fmt) x) <= abs(x) }`
        (LABEL_TAC "oneins") THENL [
          REWRITE_TAC[IN_ELIM_THM] THEN
          REWRITE_TAC[ARITH_RULE `&1 * (x:real) = x`] THEN
          USE_THEN "xneq0" (fun xneq0 -> CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["geeq"; "isge"])
          (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_E_EXISTS xneq0))) THEN
          ASM_REWRITE_TAC[] THEN USE_THEN "isge" (fun isge ->
          REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[is_greatest_e]
          isge)]); ALL_TAC] THEN
        SUBGOAL_THEN `~({ (m:num) | &m * &(flr fmt) ipow (greatest_e(fmt) x) <=
                      abs(x) } = {})`
           (LABEL_TAC "neqempty") THENL [
          REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
          EXISTS_TAC `1:num` THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN
        SUBGOAL_THEN `!(m:num). m IN
              { (m:num) | &m * &(flr fmt) ipow (greatest_e(fmt) x) <=
                      abs(x) } ==> m < (flr fmt)`
           (LABEL_TAC "bound") THENL [
          GEN_TAC THEN REWRITE_TAC[IN_ELIM_THM] THEN
          USE_THEN "xneq0" (fun xneq0 -> CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["geeq"; "isge"])
          (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_E_EXISTS xneq0))) THEN
          ASM_REWRITE_TAC[] THEN
          ASM_CASES_TAC `m < (flr fmt)` THENL [
            ASM_ARITH_TAC;
            SUBGOAL_THEN `?k. m = (flr fmt) + k` CHOOSE_TAC THENL [
              EXISTS_TAC `m - (flr fmt)` THEN
              ASM_ARITH_TAC; ALL_TAC] THEN
            ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
            SUBGOAL_THEN `&(flr fmt) ipow (e + &1) <= abs(x)`
            (LABEL_TAC "eplus1") THENL [
              REWRITE_TAC[GSYM(MATCH_MP IPOW_ADD_EXP
                           (SPEC `fmt:flformat`FLFORMAT_RADIX_NE_0))] THEN
              REWRITE_TAC[IPOW_TO_1] THEN
              ONCE_REWRITE_TAC[ARITH_RULE `(a:real) * b = b * a`] THEN
              ASSUME_TAC (REWRITE_RULE[ARITH_RULE `((a:real) + b) * c =
              a * c + b * c`] (REWRITE_RULE[GSYM REAL_OF_NUM_ADD]
              (ASSUME `&(flr fmt + k) * &(flr fmt) ipow e <= abs x`))) THEN
              MATCH_MP_TAC (ARITH_RULE
                `!z. &0 <= z /\ (a:real) + z <= b ==> a <= b`) THEN
              EXISTS_TAC `&k * &(flr fmt) ipow e` THEN ASM_REWRITE_TAC[] THEN
              MATCH_MP_TAC REAL_LE_MUL THEN
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN ARITH_TAC;
              ALL_TAC] THEN
            USE_THEN "eplus1" (fun eplus1 -> USE_THEN "isge" (fun isge ->
            LABEL_TAC "eplus1leqe" (MATCH_MP (CONJUNCT2 (
            REWRITE_RULE[is_greatest_e] isge)) eplus1))) THEN
            ASM_ARITH_TAC]; ALL_TAC] THEN
        SUBGOAL_THEN `!(m:num). m IN
              { (m:num) | &m * &(flr fmt) ipow (greatest_e(fmt) x) <=
                      abs(x) } ==> m <= (flr fmt)`
           (LABEL_TAC "bound2") THENL [
             GEN_TAC THEN
             DISCH_THEN (fun thm -> USE_THEN "bound" (fun bound ->
             ASSUME_TAC (MATCH_MP bound thm))) THEN ASM_ARITH_TAC; ALL_TAC] THEN
        USE_THEN "neqempty" (fun neqempty -> USE_THEN "bound2" (fun bound2 ->
        CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["supnum"; "issupnum"])
        (MATCH_MP SUP_NUM_BOUNDED (CONJ neqempty bound2)))) THEN
        EXISTS_TAC `n':num` THEN REWRITE_TAC[greatest_m; is_greatest_m] THEN
        ASM_REWRITE_TAC[] THEN USE_THEN "issupnum" (fun issupnum ->
        (LABEL_CONJUNCTS_TAC ["inset"; "biggest"]) (REWRITE_RULE[is_sup_num]
        issupnum)) THEN
        CONJ_TAC THENL [
          CONJ_TAC THENL [
            USE_THEN "inset" (fun inset -> REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM]
            inset]);
            USE_THEN "biggest" (fun biggest ->
            REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] biggest])];
          CONJ_TAC THENL [
            USE_THEN "oneins" (fun oneins -> USE_THEN "biggest" (fun biggest ->
            REWRITE_TAC[MATCH_MP biggest oneins]));
            USE_THEN "bound" (fun bound -> USE_THEN "inset" (fun inset ->
            REWRITE_TAC[MATCH_MP bound inset]))]]);;

let dump_gm_info xneq0 lbl =
  let concat s = String.concat "" [lbl; s] in
  CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC [concat "gmeq"; concat "gmbig"; concat "gmgeq1";
    concat "gmltr"])
  (MATCH_MP (SPEC `fmt:flformat` FLOAT_GREATEST_M_EXISTS) xneq0) THEN
  USE_THEN (concat "gmbig") (fun gmbig ->
  LABEL_CONJUNCTS_TAC [concat "gmbig1"; concat "gmbig2"]
  (REWRITE_RULE[is_greatest_m] gmbig));;

let dump_fl_gm_info isfloat lbl =
  dump_gm_info (MATCH_MP (SPEC `fmt:flformat` FLOAT_NOT_ZERO) isfloat) lbl;;

let FLOAT_GREATEST_M_UNIQUE =
  prove(`!(fmt:flformat) (x:real) (m1:num) (m2:num).
        is_greatest_m(fmt) x m1 /\ is_greatest_m(fmt) x m2 ==>
         m1 = m2`,
        REPEAT GEN_TAC THEN DISCH_THEN
        (LABEL_CONJUNCTS_TAC ["m1ge"; "m2ge"]) THEN
        USE_THEN "m1ge" (fun m1ge -> LABEL_CONJUNCTS_TAC ["m1leqx"; "m1big"]
        (REWRITE_RULE[is_greatest_m] m1ge)) THEN
        USE_THEN "m2ge" (fun m2ge -> LABEL_CONJUNCTS_TAC ["m2leqx"; "m2big"]
        (REWRITE_RULE[is_greatest_m] m2ge)) THEN
        SUBGOAL_THEN `(m1:num) <= m2` ASSUME_TAC THENL [
          USE_THEN "m2big" (fun m2big -> MATCH_MP_TAC m2big) THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN
        SUBGOAL_THEN `(m2:num) <= m1` ASSUME_TAC THENL [
          USE_THEN "m1big" (fun m1big -> MATCH_MP_TAC m1big) THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN
        ASM_ARITH_TAC);;

let FLOAT_GREATEST_M_NEG =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
        greatest_m(fmt) (-- x) = greatest_m(fmt) x`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        MATCH_MP_TAC FLOAT_GREATEST_M_UNIQUE THEN
        EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `-- x` THEN
        SUBGOAL_THEN `~(-- x = &0)` (LABEL_TAC "negxneq0") THENL [
          ASM_ARITH_TAC; ALL_TAC] THEN
        USE_THEN "negxneq0" (fun negxneq0 -> dump_gm_info negxneq0 "negx") THEN
        ASM_REWRITE_TAC[] THEN REWRITE_TAC[is_greatest_m] THEN
        USE_THEN "xneq0" (fun xneq0 -> REWRITE_TAC[MATCH_MP
        FLOAT_GREATEST_E_NEG xneq0]) THEN
        USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
        ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[ARITH_RULE `abs(-- x) = abs(x)`] THEN
        ASM_REWRITE_TAC[]);;

let old_dump_ge_gm_info xneq0 =
  CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC ["geeq"; "isge"])
  (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_E_EXISTS xneq0)) THEN
  REMOVE_THEN "isge" (fun isge -> LABEL_CONJUNCTS_TAC ["geleqx"; "gebig"]
  (REWRITE_RULE[is_greatest_e] isge)) THEN
  CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC ["gmeq"; "isgm"; "gmgeq1"; "gmltr"])
  (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_M_EXISTS xneq0)) THEN
  REMOVE_THEN "isgm" (fun isgm -> LABEL_CONJUNCTS_TAC ["gmleqx2"; "gmbig2"]
  (REWRITE_RULE[is_greatest_m] isgm)) THEN
  REMOVE_THEN "gmleqx2" (fun gmleqx2 -> USE_THEN "geeq" (fun geeq ->
  LABEL_TAC "gmleqx" (REWRITE_RULE[geeq] gmleqx2))) THEN
  REMOVE_THEN "gmbig2" (fun gmbig2 -> USE_THEN "geeq" (fun geeq ->
  LABEL_TAC "gmbig" (REWRITE_RULE[geeq] gmbig2)));;

let dump_flformat_conv expterm =
  CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC ["fmteq"; "fmteqr"; "fmteqp"; "fmteqe"])
  (SPECL [`fmt:flformat`; expterm] FLFORMAT_TO_FFORMAT);;

let FLOAT_GREATEST_R_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
           ?(y:real). greatest_r(fmt) x = y /\
                      abs(y) < (finf (to_fformat fmt (greatest_e(fmt) x)))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        USE_THEN "xneq0" (fun xneq0 -> old_dump_ge_gm_info xneq0) THEN
        ASM_REWRITE_TAC[] THEN dump_flformat_conv `e:int` THEN
        ASM_REWRITE_TAC[] THEN REWRITE_TAC[greatest_r] THEN
        ASM_CASES_TAC `&0 <= (x:real)` THENL [
          (* 0 <= x *)
          ASM_REWRITE_TAC[] THEN
          EXISTS_TAC `x - &m * &(flr fmt) ipow e` THEN REWRITE_TAC[] THEN
          SUBGOAL_THEN `abs(x - &m * &(flr fmt) ipow e) =
                            x - &m * &(flr fmt) ipow e`
          (fun thm -> REWRITE_TAC[thm]) THENL [
            ASM_ARITH_TAC; ALL_TAC] THEN
          REWRITE_TAC[finf] THEN ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `(x:real) - y < z <=> x < y + z`] THEN
          USE_THEN "gmbig" (fun gmbig -> LABEL_TAC "mplus1"
          (MATCH_MP (ONCE_REWRITE_RULE[GSYM CONTRAPOS_THM] gmbig)
             (ARITH_RULE `~(m + 1 <= m)`))) THEN
          REWRITE_TAC[ARITH_RULE `(a:real) * b + b = (a + &1) * b`] THEN
          REWRITE_TAC[REAL_OF_NUM_ADD] THEN ASM_ARITH_TAC;

          (* x < 0 *)
          ASM_REWRITE_TAC[] THEN
          EXISTS_TAC `x + &m * &(flr fmt) ipow e` THEN REWRITE_TAC[] THEN
          SUBGOAL_THEN `abs(x + &m * &(flr fmt) ipow e) =
                            -- x - &m * &(flr fmt) ipow e`
          (fun thm -> REWRITE_TAC[thm]) THENL [
            ASM_ARITH_TAC; ALL_TAC] THEN
          REWRITE_TAC[finf] THEN ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `(x:real) - y < z <=> x < y + z`] THEN
          USE_THEN "gmbig" (fun gmbig -> LABEL_TAC "mplus1"
          (MATCH_MP (ONCE_REWRITE_RULE[GSYM CONTRAPOS_THM] gmbig)
             (ARITH_RULE `~(m + 1 <= m)`))) THEN
          REWRITE_TAC[ARITH_RULE `(a:real) * b + b = (a + &1) * b`] THEN
          REWRITE_TAC[REAL_OF_NUM_ADD] THEN ASM_ARITH_TAC]);;

let FLOAT_GREATEST_R_NEG =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
        greatest_r(fmt) (-- x) = -- greatest_r(fmt) x`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[greatest_r] THEN
        USE_THEN "xneq0" (fun xneq0 -> REWRITE_TAC[MATCH_MP
        FLOAT_GREATEST_E_NEG xneq0] THEN REWRITE_TAC[MATCH_MP
        FLOAT_GREATEST_M_NEG xneq0]) THEN
        COND_CASES_TAC THENL [
          ASM_ARITH_TAC;
          ASM_ARITH_TAC]);;

let dump_gr_info xneq0 lbl =
  let concat s = String.concat "" [lbl; s] in
  CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC [concat "greq"; concat "grleq"])
  (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_R_EXISTS xneq0));;

let dump_fl_gr_info isfloat lbl =
  dump_gr_info (MATCH_MP (SPEC `fmt:flformat` FLOAT_NOT_ZERO) isfloat) lbl;;

let FLOAT_GREATEST_R_LE_0 =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) /\ &0 <= x ==>
          &0 <= greatest_r(fmt) x`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
        ["xneq0"; "xgeq0"]) THEN
        REWRITE_TAC[greatest_r] THEN ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[ARITH_RULE `&0 <= (z:real) - w <=> w <= z`] THEN
        USE_THEN "xgeq0" (fun xgeq0 -> GEN_REWRITE_TAC (RAND_CONV o
        ONCE_DEPTH_CONV) [MATCH_MP
         (ARITH_RULE `&0 <= (x:real) ==> x = abs(x)`) xgeq0]) THEN
        USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
        ASM_REWRITE_TAC[]);;

let FLOAT_GREATEST_R_LE_0_2 =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) /\ ~(&0 <= x) ==>
          greatest_r(fmt) x <= &0`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
        ["xneq0"; "xgeq0"]) THEN
        REWRITE_TAC[greatest_r] THEN ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[ARITH_RULE `((z:real) + w <= &0) <=> (w <= -- z)`] THEN
        USE_THEN "xgeq0" (fun xgeq0 -> GEN_REWRITE_TAC (RAND_CONV o
        ONCE_DEPTH_CONV) [MATCH_MP
         (ARITH_RULE `~(&0 <= (x:real)) ==> -- x = abs(x)`) xgeq0]) THEN
        USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
        ASM_REWRITE_TAC[]);;

let old_dump_ge_gm_gr_info xneq0 =
  old_dump_ge_gm_info xneq0 THEN
  CHOOSE_THEN
  (LABEL_CONJUNCTS_TAC ["greq"; "grleq2"])
  (SPEC `fmt:flformat` (MATCH_MP FLOAT_GREATEST_R_EXISTS xneq0)) THEN
  USE_THEN "geeq" (fun geeq -> dump_flformat_conv (rand (concl geeq))) THEN
  REMOVE_THEN "grleq2" (fun grleq2 -> USE_THEN "fmteq" (fun fmteq ->
  USE_THEN "geeq" (fun geeq ->
  LABEL_TAC "grleq" (REWRITE_RULE[fmteq] (REWRITE_RULE[geeq] grleq2)))));;

let FLOAT_NORMALIZE_REAL =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (if (&0 <= x)
           then
             x = &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x) +
                 (greatest_r(fmt) x)
           else
             x = -- (&(greatest_m(fmt) x) *
                     &(flr fmt) ipow (greatest_e(fmt) x)) +
                 (greatest_r(fmt) x))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        USE_THEN "xneq0" (fun xneq0 -> old_dump_ge_gm_gr_info xneq0) THEN
        REWRITE_TAC[greatest_r] THEN ASM_REWRITE_TAC[] THEN
        ARITH_TAC);;

let FLOAT_NORM_FRAC =
  prove(`!(fmt:flformat) (x:real). is_float(fmt) x ==>
          ?(f:num) (e:int). (flr fmt) EXP ((flp fmt) - 1) <= f /\
                            is_frac_and_exp(fmt) x f e`,
        REPEAT GEN_TAC THEN DISCH_THEN dump_float_defn THEN
        SUBGOAL_THEN `?n. (flr fmt) EXP ((flp fmt) - 1) <=
                          f * (flr fmt) EXP n`
        (LABEL_TAC "nexist") THENL [
          EXISTS_TAC `(flp fmt) - 1` THEN REWRITE_TAC[IN_ELIM_THM] THEN
          GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
          [ARITH_RULE `n:num = n * 1`] THEN
          GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
          [ARITH_RULE `(n:num) * m = m * n`] THEN
          REWRITE_TAC[LE_MULT_LCANCEL] THEN DISJ2_TAC THEN ASM_ARITH_TAC;
          ALL_TAC] THEN
        REMOVE_THEN "nexist" (fun nexist -> CHOOSE_THEN
        (LABEL_CONJUNCTS_TAC ["expn"; "nsmall"])
        (MATCH_MP (REWRITE_RULE[WF] WF_num) nexist)) THEN
        EXISTS_TAC `f * (flr fmt) EXP n` THEN EXISTS_TAC `(e:int) - &n` THEN
        ASM_REWRITE_TAC[] THEN REWRITE_TAC[is_frac_and_exp] THEN
        CONJ_TAC THENL [
          REWRITE_TAC[LT_MULT] THEN ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[EXP_LT_0] THEN DISJ1_TAC THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
          REWRITE_TAC[FLFORMAT_RADIX_NE_0];
          CONJ_TAC THENL [
            DISJ_CASES_TAC (SPEC `n:num` num_CASES) THENL [
              ASM_REWRITE_TAC[] THEN REWRITE_TAC[EXP] THEN
              ASM_ARITH_TAC;
              CHOOSE_THEN (LABEL_TAC "neqnp")
              (ASSUME `?n'. n = SUC n'`) THEN
              CHOOSE_THEN (LABEL_TAC "peqpp")
              (MATCH_MP (REWRITE_RULE[TAUT `a \/ b <=> ~a ==> b`] num_CASES)
              (MATCH_MP (ARITH_RULE `0 < a ==> ~(a = 0)`)
               (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))) THEN
              ASM_REWRITE_TAC[] THEN REWRITE_TAC[EXP] THEN
              ONCE_REWRITE_TAC[ARITH_RULE
                  `(a:num) * b * c = b * (a * c)`] THEN
              REWRITE_TAC[LT_MULT_LCANCEL] THEN CONJ_TAC THENL [
                REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
                REWRITE_TAC[FLFORMAT_RADIX_NE_0];
                SUBGOAL_THEN `n'' = (flp fmt) - 1` (fun thm ->
                REWRITE_TAC[thm]) THENL [
                  ASM_ARITH_TAC; ALL_TAC] THEN
                SUBGOAL_THEN `(n':num) < n` (LABEL_TAC "npltn") THENL [
                  ASM_ARITH_TAC; ALL_TAC] THEN
                REWRITE_TAC[ARITH_RULE `(a:num) < b <=> ~(b <= a)`] THEN
                USE_THEN "npltn" (fun npltn -> USE_THEN "nsmall" (fun nsmall ->
                REWRITE_TAC[MATCH_MP nsmall npltn]))]];
            (* cancel the common factor ... *)
            REWRITE_TAC[ARITH_RULE `(e:int) - &n - &(flp fmt) + &1 =
                                       (-- &n) + (e - &(flp fmt) + &1)`] THEN
            ONCE_REWRITE_TAC[GSYM(MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
            (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0))] THEN
            GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RATOR_CONV o RAND_CONV o
            ONCE_DEPTH_CONV)
            [MATCH_MP (SPEC `&(flr fmt)` IPOW_INV_NEG)
            (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
            REWRITE_TAC[ARITH_RULE `-- -- (&n:int) = &n`] THEN
            SUBGOAL_THEN `&(flr fmt) ipow &n = &((flr fmt) EXP n)` (fun thm ->
            REWRITE_TAC[thm]) THENL [
              SUBGOAL_THEN `&0 <= (&n:int)` (fun thm ->
              CHOOSE_THEN ASSUME_TAC (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP)
              thm)) THENL [ ARITH_TAC; ALL_TAC ] THEN
              ASM_REWRITE_TAC[] THEN REWRITE_TAC[NUM_OF_INT_OF_NUM];
              ALL_TAC] THEN
            REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
            SUBGOAL_THEN `(&((flr fmt) EXP n)) * inv (&((flr fmt) EXP n)) = &1`
            ASSUME_TAC THENL [
              MATCH_MP_TAC REAL_MUL_RINV THEN REWRITE_TAC[REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[EXP_EQ_0] THEN REWRITE_TAC[DE_MORGAN_THM] THEN
              DISJ1_TAC THEN REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0]; ALL_TAC] THEN
            REWRITE_TAC[ARITH_RULE `((x:real) * y) * inv y * z =
                                        (y * inv y) * x * z`] THEN
            ASM_REWRITE_TAC[] THEN ARITH_TAC]]);;

let FLOAT_NORM_M =
  prove(`!(fmt:flformat) (x:real). is_float(fmt) x ==>
          (?(m:num) (e:int) (f':num).
             f' < (flr fmt) EXP ((flp fmt) - 1) /\
             1 <= m /\
             m < (flr fmt) /\
             abs(x) = &(m * (flr fmt) EXP ((flp fmt) - 1) + f') *
                        &(flr fmt) ipow (e - &(flp fmt) + &1))`,
        REPEAT GEN_TAC THEN DISCH_THEN (fun thm -> CHOOSE_THEN
        (CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["flow"; "isfracexp"]))
        (MATCH_MP FLOAT_NORM_FRAC thm)) THEN
        REMOVE_THEN "isfracexp" (fun isfracexp -> LABEL_CONJUNCTS_TAC
        ["fpos"; "fleqrp"; "absxeq"] (REWRITE_RULE[is_frac_and_exp]
        isfracexp)) THEN
        SUBGOAL_THEN `?(m:num) (f':num).
                f = m * ((flr fmt) EXP ((flp fmt) - 1)) + f' /\
                f' < (flr fmt) EXP ((flp fmt) - 1)`
        (CHOOSE_THEN (CHOOSE_THEN (LABEL_CONJUNCTS_TAC
        ["feqmfp"; "fpleq"]))) THENL [
          MATCH_MP_TAC DIVMOD_EXIST THEN REWRITE_TAC[EXP_EQ_0] THEN
          REWRITE_TAC[DE_MORGAN_THM] THEN DISJ1_TAC THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
          REWRITE_TAC[FLFORMAT_RADIX_NE_0]; ALL_TAC] THEN
        EXISTS_TAC `m:num` THEN EXISTS_TAC `e:int` THEN EXISTS_TAC `f':num` THEN
        ASM_REWRITE_TAC[] THEN CONJ_TAC THENL [
          MATCH_MP_TAC NUM_LE_MUL_1 THEN
          EXISTS_TAC `(flr fmt) EXP ((flp fmt) - 1)` THEN
          REWRITE_TAC[ARITH_RULE `1 <= b <=> 0 < b`] THEN
          MATCH_MP_TAC (ARITH_RULE `!b. (a:num) < b /\ b <= c ==> a < c`) THEN
          EXISTS_TAC `(flr fmt) EXP ((flp fmt) - 1) - f'` THEN
          ASM_ARITH_TAC;
          MATCH_MP_TAC (ARITH_RULE `!(a:num). x < (y:num) /\ ~(a = 0) ==>
                          x < y`) THEN
          EXISTS_TAC `(flr fmt) EXP ((flp fmt) - 1)` THEN
          REWRITE_TAC[GSYM LT_MULT_RCANCEL] THEN
          GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
          [GSYM EXP] THEN
          REWRITE_TAC[MATCH_MP (ARITH_RULE `0 < n ==> SUC (n - 1) = n`)
                      (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0)] THEN
          ASM_ARITH_TAC]);;

let FLOAT_NORM_GREATEST =
  prove(`!(fmt:flformat) (x:real). is_float(fmt) x ==>
           (?(f':num).
              f' < (flr fmt) EXP ((flp fmt) - 1) /\
              abs(x) = &((greatest_m(fmt) x) * ((flr fmt) EXP ((flp fmt) - 1))
                          + f') *
                    &(flr fmt) ipow ((greatest_e(fmt) x) - &(flp fmt) + &1))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "isfloat") THEN
        USE_THEN "isfloat" (fun isfloat -> CHOOSE_THEN
        (CHOOSE_THEN (CHOOSE_THEN (LABEL_CONJUNCTS_TAC
        ["fpleqrp"; "mgeq1"; "mltr"; "absxeq"])))
        (MATCH_MP FLOAT_NORM_M isfloat)) THEN
        EXISTS_TAC `f':num` THEN ASM_REWRITE_TAC[] THEN
        USE_THEN "isfloat" (fun isfloat -> LABEL_TAC "xneq0" (MATCH_MP
        FLOAT_NOT_ZERO isfloat)) THEN
        USE_THEN "xneq0" (fun xneq0 -> old_dump_ge_gm_info xneq0) THEN
        SUBGOAL_THEN `&(flr fmt) ipow e <= abs(x)` (LABEL_TAC "eleqabs") THENL [
          MATCH_MP_TAC REAL_LE_TRANS THEN
          EXISTS_TAC `&m * &(flr fmt) ipow e` THEN CONJ_TAC THENL [
            GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
            [ARITH_RULE `(x:real) = &1 * x`] THEN
              MATCH_MP_TAC REAL_LE_RMUL THEN CONJ_TAC THENL [
              REWRITE_TAC[REAL_OF_NUM_LE] THEN ASM_REWRITE_TAC[];
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]];
            MATCH_MP_TAC REAL_LE_TRANS THEN
            EXISTS_TAC `&(m * flr fmt EXP (flp fmt - 1) + f') *
                        &(flr fmt) ipow (e - &(flp fmt) + &1)` THEN
            CONJ_TAC THENL [
              REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
              REWRITE_TAC[REAL_ADD_RDISTRIB] THEN
              MATCH_MP_TAC (ARITH_RULE `(a:real) = b /\ &0 <= (c:real) ==>
                                          a <= b + c`) THEN
              CONJ_TAC THENL [
                REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
                REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
                REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
                REWRITE_TAC[MATCH_MP IPOW_ADD_EXP
                (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
                REWRITE_TAC[ARITH_RULE `(x:int) - &1 + e - x + &1 = e`];
                MATCH_MP_TAC REAL_LE_MUL THEN CONJ_TAC THENL [
                  REWRITE_TAC[REAL_OF_NUM_LE] THEN ARITH_TAC;
                  REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]];
            ASM_ARITH_TAC]]; ALL_TAC] THEN
          USE_THEN "eleqabs" (fun eleqabs -> USE_THEN "gebig" (fun gebig ->
          DISJ_CASES_TAC (MATCH_MP (ARITH_RULE `(e:int) <= b ==>
          e = b \/ e < b`) (MATCH_MP gebig eleqabs)))) THENL [

            (* e = e' *)
            SUBGOAL_THEN `&m * &(flr fmt) ipow e' <= abs(x)`
            (LABEL_TAC "mleqabs") THENL [
              MATCH_MP_TAC REAL_LE_TRANS THEN
              EXISTS_TAC `&(m * flr fmt EXP (flp fmt - 1) + f') *
                        &(flr fmt) ipow (e - &(flp fmt) + &1)` THEN
              CONJ_TAC THENL [
                REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
                REWRITE_TAC[REAL_ADD_RDISTRIB] THEN
                MATCH_MP_TAC (ARITH_RULE `(a:real) = b /\ &0 <= (c:real) ==>
                                          a <= b + c`) THEN
                CONJ_TAC THENL [
                  REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
                  REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                  (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
                  REWRITE_TAC[ARITH_RULE
                                `((a:real) * b) * c = a * (b * c)`] THEN
                  REWRITE_TAC[MATCH_MP IPOW_ADD_EXP
                  (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
                  REWRITE_TAC[ARITH_RULE `(x:int) - &1 + e - x + &1 = e`] THEN
                  ASM_REWRITE_TAC[];
                  MATCH_MP_TAC REAL_LE_MUL THEN CONJ_TAC THENL [
                    REWRITE_TAC[REAL_OF_NUM_LE] THEN ARITH_TAC;
                    REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]];
                ASM_ARITH_TAC]; ALL_TAC] THEN
            USE_THEN "mleqabs" (fun mleqabs -> USE_THEN "gmbig" (fun gmbig ->
            DISJ_CASES_TAC (MATCH_MP (ARITH_RULE `(e:num) <= b ==>
            e = b \/ e < b`) (MATCH_MP gmbig mleqabs)))) THENL [

              (* m = m' *)
              ASM_REWRITE_TAC[];

              (* m < m' *)
              SUBGOAL_THEN `&(m + 1) * &(flr fmt) ipow e' <= abs(x)`
              ASSUME_TAC THENL [
                MATCH_MP_TAC REAL_LE_TRANS THEN
                EXISTS_TAC `&m' * &(flr fmt) ipow e'` THEN
                ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_RMUL THEN
                REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN
                REWRITE_TAC[REAL_OF_NUM_LE] THEN ASM_ARITH_TAC; ALL_TAC] THEN
              SUBGOAL_THEN `abs(x) < &(m + 1) * &(flr fmt) ipow e'`
              ASSUME_TAC THENL [
                ASM_REWRITE_TAC[] THEN REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
                REWRITE_TAC[REAL_ADD_RDISTRIB] THEN
                MATCH_MP_TAC (ARITH_RULE
                              `(a:real) < b /\ c = d ==> c + a < d + b`) THEN
                CONJ_TAC THENL [
                  MATCH_MP_TAC (ARITH_RULE
                                  `!b. (a:real) < b /\ b = c ==> a < c`) THEN
                  EXISTS_TAC `&((flr fmt) EXP ((flp fmt) - 1)) *
                                &(flr fmt) ipow (e' - &(flp fmt) + &1)` THEN
                  CONJ_TAC THENL [
                    MATCH_MP_TAC REAL_LT_RMUL THEN
                    REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0] THEN
                    REWRITE_TAC[REAL_OF_NUM_LT] THEN ASM_REWRITE_TAC[];
                    REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                    (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
                    REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                    (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
                    REWRITE_TAC[ARITH_RULE
                                `(e:int) - &1 + e' - e + &1 = e'`] THEN
                    ARITH_TAC];
                REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
                REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
                REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
                REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
                REWRITE_TAC[ARITH_RULE
                                `(e:int) - &1 + e' - e + &1 = e'`]];
                ALL_TAC] THEN
             ASM_ARITH_TAC];

            (* e < e' *)
            SUBGOAL_THEN `&(flr fmt) ipow (e + &1) <= abs(x)`
              ASSUME_TAC THENL [
                MATCH_MP_TAC REAL_LE_TRANS THEN
                EXISTS_TAC `&(flr fmt) ipow e'` THEN CONJ_TAC THENL [
                  MATCH_MP_TAC IPOW_MONOTONE_2 THEN CONJ_TAC THENL [
                    REWRITE_TAC[REAL_OF_NUM_LE] THEN MATCH_MP_TAC
                    (ARITH_RULE `1 < x ==> 1 <= x`) THEN
                    REWRITE_TAC[FLFORMAT_RADIX_LT_1];
                    ASM_ARITH_TAC];
                  ASM_REWRITE_TAC[]]; ALL_TAC] THEN
            SUBGOAL_THEN `abs(x) < &(flr fmt) ipow (e + &1)`
              ASSUME_TAC THENL [
              MATCH_MP_TAC (ARITH_RULE
                              `!b. (a:real) < b /\ b <= d ==> a < d`) THEN
              EXISTS_TAC `&(m + 1) * &(flr fmt) ipow e` THEN CONJ_TAC THENL [
                ASM_REWRITE_TAC[] THEN REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
                REWRITE_TAC[REAL_ADD_RDISTRIB] THEN
                MATCH_MP_TAC (ARITH_RULE
                              `(a:real) < b /\ c = d ==> c + a < d + b`) THEN
                CONJ_TAC THENL [
                  MATCH_MP_TAC (ARITH_RULE
                                  `!b. (a:real) < b /\ b = c ==> a < c`) THEN
                  EXISTS_TAC `&((flr fmt) EXP ((flp fmt) - 1)) *
                                &(flr fmt) ipow (e - &(flp fmt) + &1)` THEN
                  CONJ_TAC THENL [
                    MATCH_MP_TAC REAL_LT_RMUL THEN
                    REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0] THEN
                    REWRITE_TAC[REAL_OF_NUM_LT] THEN ASM_REWRITE_TAC[];
                    REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                    (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
                    REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                    (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
                    REWRITE_TAC[ARITH_RULE
                                `(e:int) - &1 + e' - e + &1 = e'`] THEN
                    ARITH_TAC];
                REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
                REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
                REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
                REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
                REWRITE_TAC[ARITH_RULE
                                `(e:int) - &1 + e' - e + &1 = e'`]];
             REWRITE_TAC[GSYM (MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0))] THEN
             GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
             [ARITH_RULE `(a:real) * b = b * a`] THEN
             MATCH_MP_TAC REAL_LE_RMUL THEN
             REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN
             REWRITE_TAC[IPOW_TO_1] THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
             ASM_ARITH_TAC]; ALL_TAC] THEN
           ASM_ARITH_TAC]);;

let FLOAT_NORMALIZE_FLOAT =
  prove(`!(fmt:flformat) (x:real). is_float(fmt) x ==>
          is_fixed(to_fformat fmt (greatest_e(fmt) x)) (greatest_r(fmt) x) /\
          (if (&0 <= x)
           then
             x = &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x) +
                 (greatest_r(fmt) x)
           else
             x = -- (&(greatest_m(fmt) x) *
                     &(flr fmt) ipow (greatest_e(fmt) x)) +
                 (greatest_r(fmt) x))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "isfloat") THEN
        CONJ_TAC THENL [
          USE_THEN "isfloat" (fun isfloat -> CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["fltrp"; "absxeq"]) (MATCH_MP
          FLOAT_NORM_GREATEST isfloat)) THEN
          dump_flformat_conv `greatest_e(fmt) x` THEN ASM_REWRITE_TAC[] THEN
          ASM_CASES_TAC `&0 <= (x:real)` THENL [
            REWRITE_TAC[greatest_r] THEN ASM_REWRITE_TAC[] THEN
            SUBGOAL_THEN
             `x - &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x =
                  &f' * &(flr fmt) ipow (greatest_e fmt x - &(flp fmt) + &1)`
            (fun thm -> REWRITE_TAC[thm]) THENL [
              SUBGOAL_THEN `x = abs(x)`
              (fun thm -> GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o
              RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV) [thm]) THENL [
                ASM_ARITH_TAC; ALL_TAC] THEN
              REWRITE_TAC[ARITH_RULE `((a:real) - b = c) <=> (a = b + c)`] THEN
              ASM_REWRITE_TAC[] THEN REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
              REWRITE_TAC[REAL_ADD_RDISTRIB] THEN
              REWRITE_TAC[ARITH_RULE `((a:real) + b = c + b) <=> a = c`] THEN
              REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
              REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
              (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
              REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
              REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
              (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
              REWRITE_TAC[ARITH_RULE `(e:int) - &1 + e2 - e + &1 = e2`];
              ALL_TAC] THEN
          REWRITE_TAC[is_fixed] THEN EXISTS_TAC `f':num` THEN
          REWRITE_TAC[is_frac] THEN CONJ_TAC THENL [
            ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC;
            ASM_REWRITE_TAC[] THEN MATCH_MP_TAC (ARITH_RULE
            `&0 <= (x:real) ==> abs(x) = x`) THEN
            MATCH_MP_TAC REAL_LE_MUL THEN CONJ_TAC THENL [
              ARITH_TAC;
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]];

      (* x < 0 *)
      REWRITE_TAC[greatest_r] THEN ASM_REWRITE_TAC[] THEN
        SUBGOAL_THEN
        `x + &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x =
         -- (&f' * &(flr fmt) ipow (greatest_e fmt x - &(flp fmt) + &1))`
        (fun thm -> REWRITE_TAC[thm]) THENL [
          SUBGOAL_THEN `x = -- abs(x)`
          (fun thm -> GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o
          RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV) [thm]) THENL [
            ASM_ARITH_TAC; ALL_TAC] THEN
          REWRITE_TAC[ARITH_RULE
                       `(-- (a:real) + b = -- c) <=> (a = b + c)`] THEN
              ASM_REWRITE_TAC[] THEN REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
              REWRITE_TAC[REAL_ADD_RDISTRIB] THEN
              REWRITE_TAC[ARITH_RULE `((a:real) + b = c + b) <=> a = c`] THEN
              REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
              REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
              (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
              REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
              REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
              (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
              REWRITE_TAC[ARITH_RULE `(e:int) - &1 + e2 - e + &1 = e2`];
              ALL_TAC] THEN
          REWRITE_TAC[is_fixed] THEN EXISTS_TAC `f':num` THEN
          REWRITE_TAC[is_frac] THEN CONJ_TAC THENL [
            ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC;
            ASM_REWRITE_TAC[] THEN MATCH_MP_TAC (ARITH_RULE
            `&0 <= (x:real) ==> abs(-- x) = x`) THEN
            MATCH_MP_TAC REAL_LE_MUL THEN CONJ_TAC THENL [
              ARITH_TAC;
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]]];
    USE_THEN "isfloat" (fun isfloat -> REWRITE_TAC[MATCH_MP
    FLOAT_NORMALIZE_REAL (MATCH_MP FLOAT_NOT_ZERO isfloat)])]);;

(* -------------------------------------------------------------------------- *)
(* Discreteness and rounding lemmas                                           *)
(* -------------------------------------------------------------------------- *)

let real_normalize xneq0 signthm lbl =
  let concat s = String.concat "" [lbl; s] in
  LABEL_TAC (concat "normed2")
  (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0) THEN
  REMOVE_THEN (concat "normed2") (fun normed2 ->
        LABEL_TAC (concat "normed") (REWRITE_RULE[signthm] normed2));;

let float_normalize isfloat signthm lbl =
  let concat s = String.concat "" [lbl; s] in
  LABEL_CONJUNCTS_TAC [concat "grfixed"; concat "normed2"]
  (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_FLOAT) isfloat) THEN
  REMOVE_THEN (concat "normed2") (fun normed2 ->
        LABEL_TAC (concat "normed") (REWRITE_RULE[signthm] normed2));;

let FLOAT_EQ_IPOW =
  prove(`!(fmt:flformat) (x:real) (e:int) (m:num).
          ~(x = &0) /\
          1 <= m /\
          m < (flr fmt) /\
          abs(x) = &m * &(flr fmt) ipow e ==>
          greatest_e(fmt) x = e /\
          greatest_m(fmt) x = m`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
        ["xneq0"; "mgeq1"; "mltr"; "mrleq"; "absxeq"]) THEN
        SUBGOAL_THEN `greatest_e(fmt) x = e`
        (LABEL_TAC "xgeeqe") THENL [
          MATCH_MP_TAC FLOAT_GREATEST_E_UNIQUE THEN
          EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x") THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[is_greatest_e] THEN
          CONJ_TAC THENL [
            (* show e is a lower bound *)
            MATCH_MP_TAC REAL_LE_TRANS THEN
            EXISTS_TAC `&m * &(flr fmt) ipow e` THEN ASM_REWRITE_TAC[] THEN
            CONJ_TAC THENL [
              GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
              [ARITH_RULE `(x:real) = &1 * x`] THEN
              MATCH_MP_TAC REAL_LE_RMUL THEN
              REWRITE_TAC[REAL_OF_NUM_LE] THEN ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];
              ARITH_TAC]; ALL_TAC] THEN
            (* show e is biggest *)
            GEN_TAC THEN ONCE_REWRITE_TAC[GSYM CONTRAPOS_THM] THEN
            DISCH_TAC THEN
            REWRITE_TAC[ARITH_RULE `~((i:real) <= j) <=> j < i`] THEN
            MATCH_MP_TAC
                  (ARITH_RULE `!y. (x:real) < y /\ y <= z ==> x < z`) THEN
            EXISTS_TAC `&m * &(flr fmt) ipow e + finf (to_fformat fmt e)` THEN
            CONJ_TAC THENL [
              USE_THEN "mrleq" (fun mrleq -> REWRITE_TAC[GSYM mrleq]) THEN
              REWRITE_TAC[ARITH_RULE `(x:real) < x + y <=> &0 < y`] THEN
              REWRITE_TAC[finf] THEN REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0];
              ALL_TAC] THEN
            MATCH_MP_TAC REAL_LE_TRANS THEN
            EXISTS_TAC `&(flr fmt) ipow (e + &1)` THEN CONJ_TAC THENL [
              (* one side *)
              REWRITE_TAC[finf] THEN dump_flformat_conv `e:int` THEN
              ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[ARITH_RULE `(x:real) * y + y = (x + &1) * y`] THEN
              REWRITE_TAC[GSYM(MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
              (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0))] THEN
              REWRITE_TAC[IPOW_TO_1] THEN
              GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
              [ARITH_RULE `(a:real) * b = b * a`] THEN
              MATCH_MP_TAC REAL_LE_RMUL THEN REWRITE_TAC[REAL_OF_NUM_ADD] THEN
              REWRITE_TAC[REAL_OF_NUM_LE] THEN
              CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];
              (* the other side *)
              MATCH_MP_TAC IPOW_MONOTONE_2 THEN
              REWRITE_TAC[REAL_OF_NUM_LE] THEN
              REWRITE_TAC[MATCH_MP (ARITH_RULE `0 < x ==> 1 <= x`)
                 (SPEC `fmt:flformat` FLFORMAT_RADIX_LT_0)] THEN
              ASM_ARITH_TAC]; ALL_TAC] THEN
        ASM_REWRITE_TAC[] THEN
        (* show m is x's gm *)
        MATCH_MP_TAC FLOAT_GREATEST_M_UNIQUE THEN
        EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
        USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
        ASM_REWRITE_TAC[] THEN REWRITE_TAC[is_greatest_m] THEN CONJ_TAC THENL [
          (* lower bound is easy *)
          ASM_REWRITE_TAC[] THEN ARITH_TAC;
          (* show m is the biggest *)
          GEN_TAC THEN ONCE_REWRITE_TAC[GSYM CONTRAPOS_THM] THEN
          DISCH_TAC THEN
          REWRITE_TAC[ARITH_RULE `~((i:real) <= j) <=> j < i`] THEN
          MATCH_MP_TAC
                  (ARITH_RULE `!y. (x:real) < y /\ y <= z ==> x < z`) THEN
          EXISTS_TAC `&m * &(flr fmt) ipow e + finf (to_fformat fmt e)` THEN
          CONJ_TAC THENL [
              USE_THEN "mrleq" (fun mrleq -> REWRITE_TAC[GSYM mrleq]) THEN
              REWRITE_TAC[ARITH_RULE `(x:real) < x + y <=> &0 < y`] THEN
              REWRITE_TAC[finf] THEN REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0];
              ALL_TAC] THEN
          MATCH_MP_TAC REAL_LE_TRANS THEN
          EXISTS_TAC `&(m + 1) * &(flr fmt) ipow e` THEN CONJ_TAC THENL [
            (* one side *)
            REWRITE_TAC[finf] THEN dump_flformat_conv `e:int` THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[ARITH_RULE `(x:real) * y + y = (x + &1) * y`] THEN
            REWRITE_TAC[REAL_OF_NUM_ADD] THEN
            ARITH_TAC;
            ASM_REWRITE_TAC[] THEN
            MATCH_MP_TAC REAL_LE_RMUL THEN
            REWRITE_TAC[REAL_OF_NUM_LE] THEN
            CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]]);;

let FLOAT_EQ_IPOW_R_0 =
  prove(`!(fmt:flformat) (x:real) (e:int) (m:num).
          ~(x = &0) /\
          1 <= m /\
          m < (flr fmt) /\
          abs(x) = &m * &(flr fmt) ipow e ==>
          greatest_r(fmt) x = &0`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
        ["xneq0"; "mgeq1"; "mltr"; "mrleq"; "absxeq"]) THEN

        SUBGOAL_THEN `greatest_e(fmt) x = e /\ greatest_m(fmt) x = m`
        ASSUME_TAC THENL [
          MATCH_MP_TAC FLOAT_EQ_IPOW THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN

        REWRITE_TAC[greatest_r] THEN ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC);;

let FLOAT_BETWEEN =
  prove(`!(fmt:flformat) (x:real) (e:int) (m:num).
          ~(x = &0) /\
          1 <= m /\
          m < (flr fmt) /\
          &m * &(flr fmt) ipow e <= abs(x) /\
          abs(x) < &m * &(flr fmt) ipow e + (finf (to_fformat fmt e)) ==>
          greatest_e(fmt) x = e /\
          greatest_m(fmt) x = m`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
        ["xneq0"; "mgeq1"; "mltr"; "mrleq"; "absxleq"]) THEN
        SUBGOAL_THEN `greatest_e(fmt) x = e`
        (LABEL_TAC "xgeeqe") THENL [
          MATCH_MP_TAC FLOAT_GREATEST_E_UNIQUE THEN
          EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x") THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[is_greatest_e] THEN CONJ_TAC THENL [
            (* show e is a lower bound *)
            MATCH_MP_TAC REAL_LE_TRANS THEN
            EXISTS_TAC `&m * &(flr fmt) ipow e` THEN ASM_REWRITE_TAC[] THEN
            GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
            [ARITH_RULE `(x:real) = &1 * x`] THEN
            MATCH_MP_TAC REAL_LE_RMUL THEN
            REWRITE_TAC[REAL_OF_NUM_LE] THEN ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];

            (* show e is biggest *)
            GEN_TAC THEN ONCE_REWRITE_TAC[GSYM CONTRAPOS_THM] THEN
            DISCH_TAC THEN
            REWRITE_TAC[ARITH_RULE `~((i:real) <= j) <=> j < i`] THEN
            MATCH_MP_TAC
                  (ARITH_RULE `!y. (x:real) < y /\ y <= z ==> x < z`) THEN
            EXISTS_TAC `&m * &(flr fmt) ipow e + finf (to_fformat fmt e)` THEN
            ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
            EXISTS_TAC `&(flr fmt) ipow (e + &1)` THEN CONJ_TAC THENL [
              (* one side *)
              REWRITE_TAC[finf] THEN dump_flformat_conv `e:int` THEN
              ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[ARITH_RULE `(x:real) * y + y = (x + &1) * y`] THEN
              REWRITE_TAC[GSYM(MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
              (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0))] THEN
              REWRITE_TAC[IPOW_TO_1] THEN
              GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
              [ARITH_RULE `(a:real) * b = b * a`] THEN
              MATCH_MP_TAC REAL_LE_RMUL THEN REWRITE_TAC[REAL_OF_NUM_ADD] THEN
              REWRITE_TAC[REAL_OF_NUM_LE] THEN
              CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];
              (* the other side *)
              MATCH_MP_TAC IPOW_MONOTONE_2 THEN
              REWRITE_TAC[REAL_OF_NUM_LE] THEN
              REWRITE_TAC[MATCH_MP (ARITH_RULE `0 < x ==> 1 <= x`)
                 (SPEC `fmt:flformat` FLFORMAT_RADIX_LT_0)] THEN
              ASM_ARITH_TAC]]; ALL_TAC] THEN
        ASM_REWRITE_TAC[] THEN
        (* show m is x's gm *)
        MATCH_MP_TAC FLOAT_GREATEST_M_UNIQUE THEN
        EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
        USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
        ASM_REWRITE_TAC[] THEN REWRITE_TAC[is_greatest_m] THEN CONJ_TAC THENL [
          (* lower bound is easy *)
          ASM_REWRITE_TAC[];
          (* show m is the biggest *)
          GEN_TAC THEN ONCE_REWRITE_TAC[GSYM CONTRAPOS_THM] THEN
          DISCH_TAC THEN
          REWRITE_TAC[ARITH_RULE `~((i:real) <= j) <=> j < i`] THEN
          MATCH_MP_TAC
                  (ARITH_RULE `!y. (x:real) < y /\ y <= z ==> x < z`) THEN
          EXISTS_TAC `&m * &(flr fmt) ipow e + finf (to_fformat fmt e)` THEN
          ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
          EXISTS_TAC `&(m + 1) * &(flr fmt) ipow e` THEN CONJ_TAC THENL [
            (* one side *)
            REWRITE_TAC[finf] THEN dump_flformat_conv `e:int` THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[ARITH_RULE `(x:real) * y + y = (x + &1) * y`] THEN
            REWRITE_TAC[REAL_OF_NUM_ADD] THEN
            ARITH_TAC;
            MATCH_MP_TAC REAL_LE_RMUL THEN
            REWRITE_TAC[REAL_OF_NUM_LE] THEN
            CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]]);;

(* -------------------------------------------------------------------------- *)
(* Rounding existence theorems                                                *)
(* -------------------------------------------------------------------------- *)

let FLOAT_RD_IS_FLOAT =
  prove(`!(fmt:flformat) (x:real) (mode:roundmode). ~(x = &0) ==>
          is_float(fmt) (flround(fmt) mode x)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        ASM_CASES_TAC `&0 <= (x:real)` THENL [
          REWRITE_TAC[is_float] THEN

          SUBGOAL_THEN `is_fixed(to_fformat fmt (greatest_e fmt x))
                                (fround (to_fformat fmt (greatest_e fmt x))
                                        mode
                                        (greatest_r fmt x))`
          (LABEL_TAC "froundfixed") THENL [
            MATCH_MP_TAC FIXED_RD_IS_FIXED THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
            ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC; ALL_TAC] THEN

          USE_THEN "froundfixed" (fun froundfixed ->
          DISJ_CASES_TAC (MATCH_MP
                 (ARITH_RULE `(x:num) <= y ==> x < y \/ x = y`)
                 (MATCH_MP (SPEC `(to_fformat fmt (greatest_e(fmt) x))`
                                  FIXED_FF_LE) froundfixed))) THENL [

            EXISTS_TAC `(greatest_m(fmt) x) * (flr fmt) EXP ((flp fmt) - 1) +
                        (ff(to_fformat fmt (greatest_e(fmt) x))
                         (fround(to_fformat fmt (greatest_e(fmt) x)) mode
                                 (greatest_r(fmt) x)))` THEN
            EXISTS_TAC `(greatest_e(fmt) x)` THEN
            REWRITE_TAC[is_frac_and_exp] THEN
            CONJ_TAC THENL [
              MATCH_MP_TAC (ARITH_RULE `0 < x ==> 0 < x + y`) THEN
              REWRITE_TAC[LT_MULT] THEN
              USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
              ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[ARITH_RULE `0 < x <=> 1 <= x`] THEN
              ASM_REWRITE_TAC[] THEN MATCH_MP_TAC EXP_LE_1 THEN
              ASM_REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0];
              ALL_TAC] THEN
            CONJ_TAC THENL [
              SUBGOAL_THEN `greatest_m fmt x * flr fmt EXP (flp fmt - 1) <=
                            ((flr fmt) - 1) * flr fmt EXP (flp fmt - 1)`
              (LABEL_TAC "mtimes") THENL [
                REWRITE_TAC[LE_MULT_RCANCEL] THEN DISJ1_TAC THEN
                USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                ASM_ARITH_TAC; ALL_TAC] THEN
              MATCH_MP_TAC
                (ARITH_RULE `!y. (x:num) < y /\ y = z ==> x < z`) THEN
              EXISTS_TAC `((flr fmt) - 1) * (flr fmt) EXP ((flp fmt) - 1) +
                            (flr fmt) EXP ((flp fmt) - 1)` THEN
              CONJ_TAC THENL [
                MATCH_MP_TAC LET_ADD2 THEN ASM_REWRITE_TAC[] THEN
                dump_flformat_conv `greatest_e(fmt) x` THEN
                USE_THEN "fmteqr" (fun fmteqr -> REWRITE_TAC[GSYM fmteqr]) THEN
                USE_THEN "fmteqp" (fun fmteqp -> REWRITE_TAC[GSYM fmteqp]) THEN
                USE_THEN "fmteq" (fun fmteq -> REWRITE_TAC[GSYM fmteq]) THEN
                REWRITE_TAC[ASSUME `ff (to_fformat fmt (greatest_e fmt x))
      (fround (to_fformat fmt (greatest_e fmt x)) mode (greatest_r fmt x)) <
      fr (to_fformat fmt (greatest_e fmt x)) EXP
      (fp (to_fformat fmt (greatest_e fmt x)) - 1)`];
                REWRITE_TAC[ARITH_RULE
                        `(n - 1) * z + z = ((n - 1) + 1) * z`] THEN
                REWRITE_TAC[REWRITE_RULE[ARITH_RULE
                                   `~(x = 0) <=> x - 1 + 1 = x`]
                 (REWRITE_RULE[REAL_OF_NUM_EQ] FLFORMAT_RADIX_NE_0)] THEN
                ONCE_REWRITE_TAC[GSYM EXP] THEN
                REWRITE_TAC[REWRITE_RULE[ARITH_RULE `(0 < x) <=>
                           SUC (x - 1) = x`]
                 (REWRITE_RULE[REAL_OF_NUM_EQ] FLFORMAT_PREC_LT_0)]];
              ALL_TAC] THEN
          REWRITE_TAC[flround] THEN LET_TAC THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
          REWRITE_TAC[ARITH_RULE
                `((x:real) + y) * z = x * z + y * z`] THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
          REWRITE_TAC[GSYM(MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                       (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                      (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`] THEN
          ASM_REWRITE_TAC[] THEN
          SUBGOAL_THEN `&0 <= &m * &(flr fmt) ipow e`
          (LABEL_TAC "mgeq0") THENL [
            MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN ARITH_TAC; ALL_TAC] THEN
          SUBGOAL_THEN `&0 <= fround (to_fformat fmt e) mode y`
          (LABEL_TAC "frgeq0") THENL [
            MATCH_MP_TAC FIXED_RD_LE_0 THEN CONJ_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_e fmt x = e`)] THEN
              ASM_ARITH_TAC;
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN ASM_REWRITE_TAC[]];
            ALL_TAC] THEN
          USE_THEN "mgeq0" (fun mgeq0 -> USE_THEN "frgeq0" (fun frgeq0 ->
          REWRITE_TAC[MATCH_MP (ARITH_RULE `&0 <= x /\ &0 <= y ==>
                               abs(x + y) = x + y`)
             (CONJ mgeq0 frgeq0)])) THEN
          REWRITE_TAC[REAL_EQ_ADD_LCANCEL] THEN
          USE_THEN "frgeq0" (fun frgeq0 ->
           GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
           [MATCH_MP (ARITH_RULE `&0 <= (x:real) ==>
                 x = abs(x)`) frgeq0]) THEN
          dump_flformat_conv `e:int` THEN
          USE_THEN "fmteq" (fun fmteq -> REWRITE_TAC[fmteq]) THEN
          USE_THEN "fmteqr" (fun fmteqr -> REWRITE_TAC[GSYM fmteqr]) THEN
          USE_THEN "fmteqp" (fun fmteqp -> REWRITE_TAC[GSYM fmteqp]) THEN
          USE_THEN "fmteqe" (fun fmteqe -> REWRITE_TAC[GSYM fmteqe]) THEN
          MATCH_MP_TAC FIXED_FF_REP THEN
          MATCH_MP_TAC FIXED_RD_IS_FIXED THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          REWRITE_TAC[GSYM (ASSUME `greatest_r fmt x = y`)] THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          USE_THEN "fmteq" (fun fmteq -> REWRITE_TAC[GSYM fmteq]) THEN
          REWRITE_TAC[GSYM (ASSUME `greatest_e fmt x = e`)] THEN
          ASM_ARITH_TAC;

        (* rounds to top *)
        ASM_CASES_TAC `(greatest_m(fmt) x) < (flr fmt) - 1` THENL [
          EXISTS_TAC
           `((greatest_m(fmt) x) + 1) * (flr fmt) EXP ((flp fmt) - 1)` THEN
          EXISTS_TAC `(greatest_e(fmt) x)` THEN
          REWRITE_TAC[is_frac_and_exp] THEN
          CONJ_TAC THENL [
            REWRITE_TAC[LT_MULT] THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[ARITH_RULE `0 < m + 1`] THEN
            MATCH_MP_TAC (ARITH_RULE `1 <= x ==> 0 < x`) THEN
            MATCH_MP_TAC EXP_LE_1 THEN
            ASM_REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
            REWRITE_TAC[FLFORMAT_RADIX_NE_0];
            ALL_TAC] THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC (ARITH_RULE `!y. (x:num) < y /\ y = z ==> x < z`) THEN
            EXISTS_TAC `(flr fmt) * flr fmt EXP (flp fmt - 1)` THEN
            CONJ_TAC THENL [
              REWRITE_TAC[LT_MULT_RCANCEL] THEN
              CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
              REWRITE_TAC[EXP_EQ_0] THEN REWRITE_TAC[DE_MORGAN_THM] THEN
              DISJ1_TAC THEN REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0];
              ONCE_REWRITE_TAC[GSYM EXP] THEN
              REWRITE_TAC[MATCH_MP (ARITH_RULE `0 < x ==> SUC(x - 1) = x`)
                 (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0)]]; ALL_TAC] THEN
          REWRITE_TAC[flround] THEN LET_TAC THEN
          ASM_REWRITE_TAC[] THEN
          SUBGOAL_THEN `&0 <= &m * &(flr fmt) ipow e`
          (LABEL_TAC "mgeq0") THENL [
            MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN ARITH_TAC; ALL_TAC] THEN
          SUBGOAL_THEN `&0 <= fround (to_fformat fmt e) mode y`
          (LABEL_TAC "frgeq0") THENL [
            MATCH_MP_TAC FIXED_RD_LE_0 THEN CONJ_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_e fmt x = e`)] THEN
              ASM_ARITH_TAC;
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN ASM_REWRITE_TAC[]];
            ALL_TAC] THEN
          USE_THEN "mgeq0" (fun mgeq0 -> USE_THEN "frgeq0" (fun frgeq0 ->
          REWRITE_TAC[MATCH_MP (ARITH_RULE `&0 <= x /\ &0 <= y ==>
                               abs(x + y) = x + y`)
             (CONJ mgeq0 frgeq0)])) THEN
          SUBGOAL_THEN `fround (to_fformat fmt e) mode y =
                       &(flr fmt) ipow e` (LABEL_TAC "froundeq") THENL [
            USE_THEN "frgeq0" (fun frgeq0 ->
              ONCE_REWRITE_TAC[MATCH_MP (ARITH_RULE
                `&0 <= (x:real) ==> x = abs(x)`) frgeq0]) THEN
            USE_THEN "froundfixed" (fun froundfixed ->
              REWRITE_TAC[MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_FF_REP)
                            froundfixed]) THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[GSYM(MATCH_MP
                (SPEC `(fr (to_fformat fmt e))` IPOW_EQ_EXP_P)
                       (SPEC `(to_fformat fmt e)` FFORMAT_PREC_LT_0))] THEN
            REWRITE_TAC[MATCH_MP (SPEC `&(fr (to_fformat fmt e))` IPOW_ADD_EXP)
                      (SPEC `(to_fformat fmt e)` FFORMAT_RADIX_NE_0)] THEN
            REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`] THEN
            dump_flformat_conv `e:int` THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `(x:real) * y + y = (x + &1) * y`] THEN
          REWRITE_TAC[REAL_OF_NUM_ADD] THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
          REWRITE_TAC[GSYM(MATCH_MP
                (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                       (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                      (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`];

          (* rounds to tip tip top *)
          EXISTS_TAC `(flr fmt) EXP ((flp fmt) - 1)` THEN
          EXISTS_TAC `(greatest_e(fmt) x) + &1` THEN
          REWRITE_TAC[is_frac_and_exp] THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC (ARITH_RULE `1 <= x ==> 0 < x`) THEN
            MATCH_MP_TAC EXP_LE_1 THEN
            ASM_REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
            REWRITE_TAC[FLFORMAT_RADIX_NE_0];
            ALL_TAC] THEN
          CONJ_TAC THENL [
            REWRITE_TAC[LT_EXP] THEN REWRITE_TAC[FLFORMAT_RADIX_LE_2] THEN
            DISJ1_TAC THEN
            REWRITE_TAC[ARITH_RULE `x - 1 < x <=> 0 < x`] THEN
            REWRITE_TAC[FLFORMAT_PREC_LT_0];
          ALL_TAC] THEN
          REWRITE_TAC[flround] THEN LET_TAC THEN
          ASM_REWRITE_TAC[] THEN
          SUBGOAL_THEN `&0 <= &m * &(flr fmt) ipow e`
          (LABEL_TAC "mgeq0") THENL [
            MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN ARITH_TAC; ALL_TAC] THEN
          SUBGOAL_THEN `&0 <= fround (to_fformat fmt e) mode y`
          (LABEL_TAC "frgeq0") THENL [
            MATCH_MP_TAC FIXED_RD_LE_0 THEN CONJ_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_e fmt x = e`)] THEN
              ASM_ARITH_TAC;
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN ASM_REWRITE_TAC[]];
            ALL_TAC] THEN
          USE_THEN "mgeq0" (fun mgeq0 -> USE_THEN "frgeq0" (fun frgeq0 ->
          REWRITE_TAC[MATCH_MP (ARITH_RULE `&0 <= x /\ &0 <= y ==>
                               abs(x + y) = x + y`)
             (CONJ mgeq0 frgeq0)])) THEN
          SUBGOAL_THEN `fround (to_fformat fmt e) mode y =
                       &(flr fmt) ipow e` (LABEL_TAC "froundeq") THENL [
            USE_THEN "frgeq0" (fun frgeq0 ->
              ONCE_REWRITE_TAC[MATCH_MP (ARITH_RULE
                `&0 <= (x:real) ==> x = abs(x)`) frgeq0]) THEN
            USE_THEN "froundfixed" (fun froundfixed ->
              REWRITE_TAC[MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_FF_REP)
                            froundfixed]) THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[GSYM(MATCH_MP
                (SPEC `(fr (to_fformat fmt e))` IPOW_EQ_EXP_P)
                       (SPEC `(to_fformat fmt e)` FFORMAT_PREC_LT_0))] THEN
            REWRITE_TAC[MATCH_MP (SPEC `&(fr (to_fformat fmt e))` IPOW_ADD_EXP)
                      (SPEC `(to_fformat fmt e)` FFORMAT_RADIX_NE_0)] THEN
            REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`] THEN
            dump_flformat_conv `e:int` THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `(x:real) * y + y = (x + &1) * y`] THEN
          REWRITE_TAC[REAL_OF_NUM_ADD] THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
          REWRITE_TAC[GSYM(MATCH_MP
                (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                       (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                      (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`] THEN
          SUBGOAL_THEN `m + 1= (flr fmt)` (fun thm -> REWRITE_TAC[thm]) THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_ARITH_TAC; ALL_TAC] THEN
          REWRITE_TAC[GSYM(MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0))] THEN
          REWRITE_TAC[IPOW_TO_1] THEN
          ARITH_TAC]]; ALL_TAC] THEN

  (* x < 0 *)
          REWRITE_TAC[is_float] THEN
          SUBGOAL_THEN `is_fixed(to_fformat fmt (greatest_e fmt x))
                                (fround (to_fformat fmt (greatest_e fmt x))
                                        mode
                                        (greatest_r fmt x))`
          (LABEL_TAC "froundfixed") THENL [
            MATCH_MP_TAC FIXED_RD_IS_FIXED THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
            ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC; ALL_TAC] THEN
          USE_THEN "froundfixed" (fun froundfixed ->
          DISJ_CASES_TAC (MATCH_MP
                 (ARITH_RULE `(x:num) <= y ==> x < y \/ x = y`)
                 (MATCH_MP (SPEC `(to_fformat fmt (greatest_e(fmt) x))`
                                  FIXED_FF_LE) froundfixed))) THENL [
            EXISTS_TAC `(greatest_m(fmt) x) * (flr fmt) EXP ((flp fmt) - 1) +
                        (ff(to_fformat fmt (greatest_e(fmt) x))
                         (fround(to_fformat fmt (greatest_e(fmt) x)) mode
                                 (greatest_r(fmt) x)))` THEN
            EXISTS_TAC `(greatest_e(fmt) x)` THEN
            REWRITE_TAC[is_frac_and_exp] THEN
            CONJ_TAC THENL [
              MATCH_MP_TAC (ARITH_RULE `0 < x ==> 0 < x + y`) THEN
              REWRITE_TAC[LT_MULT] THEN
              USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
              ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[ARITH_RULE `0 < x <=> 1 <= x`] THEN
              ASM_REWRITE_TAC[] THEN MATCH_MP_TAC EXP_LE_1 THEN
              ASM_REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0];
              ALL_TAC] THEN
            CONJ_TAC THENL [
              SUBGOAL_THEN `greatest_m fmt x * flr fmt EXP (flp fmt - 1) <=
                            ((flr fmt) - 1) * flr fmt EXP (flp fmt - 1)`
              (LABEL_TAC "mtimes") THENL [
                REWRITE_TAC[LE_MULT_RCANCEL] THEN DISJ1_TAC THEN
                USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                ASM_ARITH_TAC; ALL_TAC] THEN
              MATCH_MP_TAC
                (ARITH_RULE `!y. (x:num) < y /\ y = z ==> x < z`) THEN
              EXISTS_TAC `((flr fmt) - 1) * (flr fmt) EXP ((flp fmt) - 1) +
                            (flr fmt) EXP ((flp fmt) - 1)` THEN
              CONJ_TAC THENL [
                MATCH_MP_TAC LET_ADD2 THEN ASM_REWRITE_TAC[] THEN
                dump_flformat_conv `greatest_e(fmt) x` THEN
                USE_THEN "fmteqr" (fun fmteqr -> REWRITE_TAC[GSYM fmteqr]) THEN
                USE_THEN "fmteqp" (fun fmteqp -> REWRITE_TAC[GSYM fmteqp]) THEN
                USE_THEN "fmteq" (fun fmteq -> REWRITE_TAC[GSYM fmteq]) THEN
                REWRITE_TAC[ASSUME `ff (to_fformat fmt (greatest_e fmt x))
      (fround (to_fformat fmt (greatest_e fmt x)) mode (greatest_r fmt x)) <
      fr (to_fformat fmt (greatest_e fmt x)) EXP
      (fp (to_fformat fmt (greatest_e fmt x)) - 1)`];
                REWRITE_TAC[ARITH_RULE
                        `(n - 1) * z + z = ((n - 1) + 1) * z`] THEN
                REWRITE_TAC[REWRITE_RULE[ARITH_RULE
                                   `~(x = 0) <=> x - 1 + 1 = x`]
                 (REWRITE_RULE[REAL_OF_NUM_EQ] FLFORMAT_RADIX_NE_0)] THEN
                ONCE_REWRITE_TAC[GSYM EXP] THEN
                REWRITE_TAC[REWRITE_RULE[ARITH_RULE `(0 < x) <=>
                           SUC (x - 1) = x`]
                 (REWRITE_RULE[REAL_OF_NUM_EQ] FLFORMAT_PREC_LT_0)]];
              ALL_TAC] THEN
          REWRITE_TAC[flround] THEN LET_TAC THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
          REWRITE_TAC[ARITH_RULE
                `((x:real) + y) * z = x * z + y * z`] THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
          REWRITE_TAC[GSYM(MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                       (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                      (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`] THEN
          ASM_REWRITE_TAC[] THEN
          SUBGOAL_THEN `&0 <= &m * &(flr fmt) ipow e`
          (LABEL_TAC "mgeq0") THENL [
            MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN ARITH_TAC; ALL_TAC] THEN
          SUBGOAL_THEN `fround (to_fformat fmt e) mode y <= &0`
          (LABEL_TAC "frleq0") THENL [
            MATCH_MP_TAC FIXED_RD_LE_0_2 THEN CONJ_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_e fmt x = e`)] THEN
              ASM_ARITH_TAC;
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN ASM_REWRITE_TAC[]];
            ALL_TAC] THEN
          USE_THEN "mgeq0" (fun mgeq0 -> USE_THEN "frleq0" (fun frleq0 ->
          REWRITE_TAC[MATCH_MP (ARITH_RULE `&0 <= x /\ y <= &0 ==>
                               abs(-- x + y) = x + -- y`)
             (CONJ mgeq0 frleq0)])) THEN
          REWRITE_TAC[REAL_EQ_ADD_LCANCEL] THEN
          USE_THEN "frleq0" (fun frleq0 ->
           GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
           [MATCH_MP (ARITH_RULE `(x:real) <= &0 ==>
                 -- x = abs(x)`) frleq0]) THEN
          dump_flformat_conv `e:int` THEN
          USE_THEN "fmteq" (fun fmteq -> REWRITE_TAC[fmteq]) THEN
          USE_THEN "fmteqr" (fun fmteqr -> REWRITE_TAC[GSYM fmteqr]) THEN
          USE_THEN "fmteqp" (fun fmteqp -> REWRITE_TAC[GSYM fmteqp]) THEN
          USE_THEN "fmteqe" (fun fmteqe -> REWRITE_TAC[GSYM fmteqe]) THEN
          MATCH_MP_TAC FIXED_FF_REP THEN
          MATCH_MP_TAC FIXED_RD_IS_FIXED THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          REWRITE_TAC[GSYM (ASSUME `greatest_r fmt x = y`)] THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          USE_THEN "fmteq" (fun fmteq -> REWRITE_TAC[GSYM fmteq]) THEN
          REWRITE_TAC[GSYM (ASSUME `greatest_e fmt x = e`)] THEN
          ASM_ARITH_TAC;

        (* rounds to top *)
        ASM_CASES_TAC `(greatest_m(fmt) x) < (flr fmt) - 1` THENL [
          EXISTS_TAC
           `((greatest_m(fmt) x) + 1) * (flr fmt) EXP ((flp fmt) - 1)` THEN
          EXISTS_TAC `(greatest_e(fmt) x)` THEN
          REWRITE_TAC[is_frac_and_exp] THEN
          CONJ_TAC THENL [
            REWRITE_TAC[LT_MULT] THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[ARITH_RULE `0 < m + 1`] THEN
            MATCH_MP_TAC (ARITH_RULE `1 <= x ==> 0 < x`) THEN
            MATCH_MP_TAC EXP_LE_1 THEN
            ASM_REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
            REWRITE_TAC[FLFORMAT_RADIX_NE_0];
            ALL_TAC] THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC (ARITH_RULE `!y. (x:num) < y /\ y = z ==> x < z`) THEN
            EXISTS_TAC `(flr fmt) * flr fmt EXP (flp fmt - 1)` THEN
            CONJ_TAC THENL [
              REWRITE_TAC[LT_MULT_RCANCEL] THEN
              CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
              REWRITE_TAC[EXP_EQ_0] THEN REWRITE_TAC[DE_MORGAN_THM] THEN
              DISJ1_TAC THEN REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0];
              ONCE_REWRITE_TAC[GSYM EXP] THEN
              REWRITE_TAC[MATCH_MP (ARITH_RULE `0 < x ==> SUC(x - 1) = x`)
                 (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0)]]; ALL_TAC] THEN
          REWRITE_TAC[flround] THEN LET_TAC THEN
          ASM_REWRITE_TAC[] THEN
          SUBGOAL_THEN `&0 <= &m * &(flr fmt) ipow e`
          (LABEL_TAC "mgeq0") THENL [
            MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN ARITH_TAC; ALL_TAC] THEN
          SUBGOAL_THEN `fround (to_fformat fmt e) mode y <= &0`
          (LABEL_TAC "frleq0") THENL [
            MATCH_MP_TAC FIXED_RD_LE_0_2 THEN CONJ_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_e fmt x = e`)] THEN
              ASM_ARITH_TAC;
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN ASM_REWRITE_TAC[]];
            ALL_TAC] THEN
          USE_THEN "mgeq0" (fun mgeq0 -> USE_THEN "frleq0" (fun frleq0 ->
          REWRITE_TAC[MATCH_MP (ARITH_RULE `&0 <= x /\ y <= &0 ==>
                               abs(-- x + y) = x + -- y`)
             (CONJ mgeq0 frleq0)])) THEN
          SUBGOAL_THEN `-- fround (to_fformat fmt e) mode y =
                       &(flr fmt) ipow e` (LABEL_TAC "froundeq") THENL [
            USE_THEN "frleq0" (fun frleq0 ->
              ONCE_REWRITE_TAC[MATCH_MP (ARITH_RULE
                `(x:real) <= &0 ==> -- x = abs(x)`) frleq0]) THEN
            USE_THEN "froundfixed" (fun froundfixed ->
              REWRITE_TAC[MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_FF_REP)
                            froundfixed]) THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[GSYM(MATCH_MP
                (SPEC `(fr (to_fformat fmt e))` IPOW_EQ_EXP_P)
                       (SPEC `(to_fformat fmt e)` FFORMAT_PREC_LT_0))] THEN
            REWRITE_TAC[MATCH_MP (SPEC `&(fr (to_fformat fmt e))` IPOW_ADD_EXP)
                      (SPEC `(to_fformat fmt e)` FFORMAT_RADIX_NE_0)] THEN
            REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`] THEN
            dump_flformat_conv `e:int` THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `(x:real) * y + y = (x + &1) * y`] THEN
          REWRITE_TAC[REAL_OF_NUM_ADD] THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
          REWRITE_TAC[GSYM(MATCH_MP
                (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                       (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                      (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`];

          (* rounds to tip tip top *)
          EXISTS_TAC `(flr fmt) EXP ((flp fmt) - 1)` THEN
          EXISTS_TAC `(greatest_e(fmt) x) + &1` THEN
          REWRITE_TAC[is_frac_and_exp] THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC (ARITH_RULE `1 <= x ==> 0 < x`) THEN
            MATCH_MP_TAC EXP_LE_1 THEN
            ASM_REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
            REWRITE_TAC[FLFORMAT_RADIX_NE_0];
            ALL_TAC] THEN
          CONJ_TAC THENL [
            REWRITE_TAC[LT_EXP] THEN REWRITE_TAC[FLFORMAT_RADIX_LE_2] THEN
            DISJ1_TAC THEN
            REWRITE_TAC[ARITH_RULE `x - 1 < x <=> 0 < x`] THEN
            REWRITE_TAC[FLFORMAT_PREC_LT_0];
          ALL_TAC] THEN
          REWRITE_TAC[flround] THEN LET_TAC THEN
          ASM_REWRITE_TAC[] THEN
          SUBGOAL_THEN `&0 <= &m * &(flr fmt) ipow e`
          (LABEL_TAC "mgeq0") THENL [
            MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN ARITH_TAC; ALL_TAC] THEN
          SUBGOAL_THEN `fround (to_fformat fmt e) mode y <= &0`
          (LABEL_TAC "frleq0") THENL [
            MATCH_MP_TAC FIXED_RD_LE_0_2 THEN CONJ_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_e fmt x = e`)] THEN
              ASM_ARITH_TAC;
              REWRITE_TAC[GSYM(ASSUME `greatest_r fmt x = y`)] THEN
              MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN ASM_REWRITE_TAC[]];
            ALL_TAC] THEN
          USE_THEN "mgeq0" (fun mgeq0 -> USE_THEN "frleq0" (fun frleq0 ->
          REWRITE_TAC[MATCH_MP (ARITH_RULE `&0 <= x /\ y <= &0 ==>
                               abs(-- x + y) = x + -- y`)
             (CONJ mgeq0 frleq0)])) THEN
          SUBGOAL_THEN `-- fround (to_fformat fmt e) mode y =
                       &(flr fmt) ipow e` (LABEL_TAC "froundeq") THENL [
            USE_THEN "frleq0" (fun frleq0 ->
              ONCE_REWRITE_TAC[MATCH_MP (ARITH_RULE
                `(x:real) <= &0 ==> -- x = abs(x)`) frleq0]) THEN
            USE_THEN "froundfixed" (fun froundfixed ->
              REWRITE_TAC[MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_FF_REP)
                            froundfixed]) THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[GSYM(MATCH_MP
                (SPEC `(fr (to_fformat fmt e))` IPOW_EQ_EXP_P)
                       (SPEC `(to_fformat fmt e)` FFORMAT_PREC_LT_0))] THEN
            REWRITE_TAC[MATCH_MP (SPEC `&(fr (to_fformat fmt e))` IPOW_ADD_EXP)
                      (SPEC `(to_fformat fmt e)` FFORMAT_RADIX_NE_0)] THEN
            REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`] THEN
            dump_flformat_conv `e:int` THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `(x:real) * y + y = (x + &1) * y`] THEN
          REWRITE_TAC[REAL_OF_NUM_ADD] THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
          REWRITE_TAC[GSYM(MATCH_MP
                (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
                       (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
                      (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `(i:int) - &1 + e - i + &1 = e`] THEN
          SUBGOAL_THEN `m + 1= (flr fmt)` (fun thm -> REWRITE_TAC[thm]) THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_ARITH_TAC; ALL_TAC] THEN
          REWRITE_TAC[GSYM(MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0))] THEN
          REWRITE_TAC[IPOW_TO_1] THEN
          ARITH_TAC]]);;

let CLOSER_BETWEEN_3 =
  prove(`!(a:real) (x:real) (y:real).
          x < y /\ y <= a ==> (closer y x a)`,
        REPEAT GEN_TAC THEN REWRITE_TAC[closer] THEN ARITH_TAC);;

let CLOSER_BETWEEN_4 =
  prove(`!(a:real) (x:real) (y:real) (z:real).
          (closer x y a) /\ ((closer z x a) \/ ~(closer x z a)) ==>
          (closer z y a)`,
        REPEAT GEN_TAC THEN REWRITE_TAC[closer] THEN ARITH_TAC);;

let CLOSER_BETWEEN_5 =
  prove(`!(a:real) (x:real) (y:real).
          a <= y /\ y < x ==> (closer y x a)`,
        REPEAT GEN_TAC THEN REWRITE_TAC[closer] THEN ARITH_TAC);;

let fl_is_closest = define
  `fl_is_closest (fmt:flformat) (x:real) (y:real) =
  (!(s:real). is_float(fmt) s /\ ~(s = y) ==>
     ((closer y s x) \/ ~(closer s y x)))`;;

let FLOAT_RD_NEAREST_CLOSEST =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          ?(z:real). flround(fmt) To_near x = z /\  fl_is_closest(fmt) x z`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[flround] THEN LET_TAC THEN
        COND_CASES_TAC THENL [

          (* 0 <= x *)

          LABEL_TAC "xgeq0" (ASSUME `&0 <= (x:real)`) THEN
          USE_THEN "xneq0" (fun xneq0 -> USE_THEN "xgeq0" (fun xgeq0 ->
          real_normalize xneq0 xgeq0 "x")) THEN
          EXISTS_TAC `&m * &(flr fmt) ipow e +
                         fround (to_fformat fmt e) To_near y` THEN
          REWRITE_TAC[] THEN REWRITE_TAC[fl_is_closest] THEN
          GEN_TAC THEN
          DISCH_THEN (LABEL_CONJUNCTS_TAC ["sfloat"; "sneq"]) THEN

          (* run through cases *)
          ASM_CASES_TAC `s < &m * &(flr fmt) ipow e` THENL [
            (* s below the window *)
            DISJ1_TAC THEN MATCH_MP_TAC CLOSER_BETWEEN_4 THEN
            EXISTS_TAC `&m * &(flr fmt) ipow e` THEN CONJ_TAC THENL [
              MATCH_MP_TAC CLOSER_BETWEEN_3 THEN ASM_REWRITE_TAC[] THEN
              USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x" THEN
              dump_gm_info xneq0 "x") THEN
              USE_THEN "xgeq0" (fun xgeq0 ->
              ONCE_REWRITE_TAC[MATCH_MP
                (ARITH_RULE `&0 <= (x:real) ==> x = abs(x)`) xgeq0]) THEN
              ONCE_REWRITE_TAC[GSYM (CONJ (ASSUME `greatest_e(fmt) x = e`)
                                     (ASSUME `greatest_m(fmt) x = m`))] THEN
              USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
              USE_THEN "xgmbig1" (fun xgmbig1 -> REWRITE_TAC[xgmbig1]);
              ASM_CASES_TAC `fround (to_fformat fmt e) To_near y = &0` THENL [
                (* the remainder is zero *)
                ASM_REWRITE_TAC[] THEN REWRITE_TAC[closer] THEN ARITH_TAC;
                (* the remainder is non-zero *)
                REWRITE_TAC[closer] THEN
                USE_THEN "xnormed" (fun xnormed ->
                                     ONCE_REWRITE_TAC[xnormed]) THEN
                REWRITE_TAC[GSYM (CONJ (ASSUME `greatest_m fmt x = m`)
                                     (CONJ (ASSUME `greatest_e fmt x = e`)
                                     (ASSUME `greatest_r fmt x = y`)))] THEN
                REWRITE_TAC[ARITH_RULE `((x:real) + y) - (x + z) = y - z`] THEN
                REWRITE_TAC[ARITH_RULE `(x:real) - (x + z) = &0 - z`] THEN
                REWRITE_TAC[GSYM closer] THEN
                USE_THEN "xneq0" (fun xneq0 -> USE_THEN "xgeq0" (fun xgeq0 ->
                dump_gr_info xneq0 "x")) THEN
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                USE_THEN "xgrleq" (fun xgrleq ->
                CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["froundeq";
                 "froundfixed"; "closest"])
                (MATCH_MP FIXED_RD_NEAREST_CLOSEST
                 (MATCH_MP (ARITH_RULE `(x:real) < y ==> x <= y`) xgrleq))) THEN
                USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
                USE_THEN "closest" (fun closest -> MATCH_MP_TAC
                (REWRITE_RULE[is_closest] closest)) THEN CONJ_TAC THENL [
                  REWRITE_TAC[FIXED_ZERO_IN_FIXED];
                  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN USE_THEN "froundeq"
                  (fun froundeq -> REWRITE_TAC[GSYM froundeq]) THEN
                  REWRITE_TAC[ASSUME `greatest_e(fmt) x = e`] THEN
                  USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
                  REWRITE_TAC[ASSUME `greatest_r(fmt) x = y`] THEN
                  REWRITE_TAC[ASSUME `~(fround (to_fformat fmt e) To_near y =
                                            &0)`]]]]; ALL_TAC] THEN
          (* s above window *)
          ASM_CASES_TAC `&m * &(flr fmt) ipow e +
                               (finf (to_fformat fmt e)) < s` THENL [
            DISJ1_TAC THEN MATCH_MP_TAC CLOSER_BETWEEN_4 THEN
            EXISTS_TAC `&m * &(flr fmt) ipow e +
                              (finf (to_fformat fmt e))` THEN CONJ_TAC THENL [
              MATCH_MP_TAC CLOSER_BETWEEN_5 THEN ASM_REWRITE_TAC[] THEN
              USE_THEN "xnormed" (fun xnormed -> ONCE_REWRITE_TAC[xnormed]) THEN
              ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[ARITH_RULE `(x:real) + y <= x + z <=> y <= z`] THEN
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
              SUBGOAL_THEN `&0 <= (y':real)` (LABEL_TAC "ypgeq0") THENL [
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
                REWRITE_TAC[greatest_r] THEN ASM_REWRITE_TAC[] THEN
                REWRITE_TAC[ARITH_RULE `&0 <= (x:real) - y <=> y <= x`] THEN
                USE_THEN "xgeq0" (fun xgeq0 -> ONCE_REWRITE_TAC[MATCH_MP
                (ARITH_RULE `&0 <= (x:real) ==> x = abs(x)`) xgeq0]) THEN
                USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                REWRITE_TAC[GSYM(CONJ (ASSUME `greatest_e(fmt) x = e`)
                                      (ASSUME `greatest_m(fmt) x = m`))] THEN
                USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
                USE_THEN "xgmbig1" (fun xgmbig1 -> REWRITE_TAC[xgmbig1]);
                ALL_TAC] THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              USE_THEN "ypgeq0" (fun ypgreq0 -> ONCE_REWRITE_TAC[MATCH_MP
              (ARITH_RULE `&0 <= (x:real) ==> x = abs(x)`) ypgreq0]) THEN
              REWRITE_TAC[GSYM (ASSUME `greatest_e(fmt) x = e`)] THEN
              ASM_ARITH_TAC;

              ASM_CASES_TAC `fround (to_fformat fmt e) To_near y =
                               (finf (to_fformat fmt e))` THENL [
                (* the remainder is finf *)
                ASM_REWRITE_TAC[] THEN REWRITE_TAC[closer] THEN ARITH_TAC;
                (* the remainder is non-finf *)
                REWRITE_TAC[closer] THEN
                USE_THEN "xnormed" (fun xnormed ->
                                     ONCE_REWRITE_TAC[xnormed]) THEN
                REWRITE_TAC[GSYM (CONJ (ASSUME `greatest_m fmt x = m`)
                                     (CONJ (ASSUME `greatest_e fmt x = e`)
                                     (ASSUME `greatest_r fmt x = y`)))] THEN
                REWRITE_TAC[ARITH_RULE `((x:real) + y) - (x + z) = y - z`] THEN
                REWRITE_TAC[GSYM closer] THEN
                USE_THEN "xneq0" (fun xneq0 -> USE_THEN "xgeq0" (fun xgeq0 ->
                dump_gr_info xneq0 "x")) THEN
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                USE_THEN "xgrleq" (fun xgrleq ->
                CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["froundeq"; "froundfixed";
                  "closest"])
                (MATCH_MP FIXED_RD_NEAREST_CLOSEST
                 (MATCH_MP (ARITH_RULE `(x:real) < y ==> x <= y`) xgrleq))) THEN
                USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
                USE_THEN "closest" (fun closest -> MATCH_MP_TAC
                (REWRITE_RULE[is_closest] closest)) THEN CONJ_TAC THENL [
                  REWRITE_TAC[FIXED_FINF_IN_FIXED];
                  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN USE_THEN "froundeq"
                  (fun froundeq -> REWRITE_TAC[GSYM froundeq]) THEN
                  REWRITE_TAC[ASSUME `greatest_e(fmt) x = e`] THEN
                  USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
                  REWRITE_TAC[ASSUME `greatest_r(fmt) x = y`] THEN
                  REWRITE_TAC[ASSUME `~(fround (to_fformat fmt e) To_near y =
                                      finf (to_fformat fmt e))`]]]];
                 ALL_TAC] THEN

          (* s is inside the window, but could be at top *)
          ASM_CASES_TAC `s = &m * &(flr fmt) ipow e +
                                finf (to_fformat fmt e)` THENL [
            (* take care of trivial case *)
            ASM_CASES_TAC
              `fround (to_fformat fmt e) To_near y =
                  finf (to_fformat fmt e)` THENL [
              ASM_REWRITE_TAC[] THEN REWRITE_TAC[closer] THEN ARITH_TAC;
              ALL_TAC] THEN
            (* now may assume we're not rounding to finf *)
            ASM_REWRITE_TAC[] THEN REWRITE_TAC[closer] THEN
            USE_THEN "xnormed" (fun xnormed -> ONCE_REWRITE_TAC[xnormed]) THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[ARITH_RULE `((x:real) + y) - (x + z) = y - z`] THEN
            REWRITE_TAC[GSYM closer] THEN
            USE_THEN "xneq0" (fun xneq0 -> USE_THEN "xgeq0" (fun xgeq0 ->
            dump_gr_info xneq0 "x")) THEN
            USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
            USE_THEN "xgrleq" (fun xgrleq ->
            CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["froundeq"; "froundfixed";
              "closest"])
            (MATCH_MP FIXED_RD_NEAREST_CLOSEST
              (MATCH_MP (ARITH_RULE `(x:real) < y ==> x <= y`) xgrleq))) THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_e(fmt) x = e`)] THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
            USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
            USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
            USE_THEN "closest" (fun closest -> MATCH_MP_TAC
            (REWRITE_RULE[is_closest] closest)) THEN CONJ_TAC THENL [
              REWRITE_TAC[FIXED_FINF_IN_FIXED];
              ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN
              USE_THEN "froundeq" (fun froundeq ->
                                      REWRITE_TAC[GSYM froundeq]) THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
              ASM_REWRITE_TAC[]]; ALL_TAC] THEN

        (* we can now assume s is inside the window *)
        SUBGOAL_THEN `&0 <= (s:real)` (LABEL_TAC "sgeq0") THENL [
          MATCH_MP_TAC REAL_LE_TRANS THEN
          EXISTS_TAC `&m * &(flr fmt) ipow e` THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC REAL_LE_MUL THEN
            REWRITE_TAC[REAL_OF_NUM_LE] THEN
            CONJ_TAC THENL[ ARITH_TAC; ALL_TAC] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];
            ASM_ARITH_TAC]; ALL_TAC] THEN
        SUBGOAL_THEN `~(s = &0)` (LABEL_TAC "sneq0") THENL [
          MATCH_MP_TAC (ARITH_RULE `&0 < (s:real) ==> ~(s = &0)`) THEN
          MATCH_MP_TAC
             (ARITH_RULE `!y. &0 < (y:real) /\ y <= s ==> &0 < s`) THEN
          EXISTS_TAC `&m * &(flr fmt) ipow e` THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC REAL_LT_MUL THEN
            REWRITE_TAC[REAL_OF_NUM_LT] THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_m(fmt) x = m`)] THEN
            USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
            USE_THEN "xgmgeq1" (fun xgmgeq1 -> REWRITE_TAC[MATCH_MP
            (ARITH_RULE `1 <= m' ==> 0 < m'`) xgmgeq1]) THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0];
            ASM_ARITH_TAC]; ALL_TAC] THEN
          SUBGOAL_THEN `greatest_e(fmt) s = e /\ greatest_m(fmt) s = m`
          (LABEL_TAC "sgegm") THENL [
            MATCH_MP_TAC FLOAT_BETWEEN THEN ASM_REWRITE_TAC[] THEN
            USE_THEN "sgeq0" (fun sgeq0 -> REWRITE_TAC[MATCH_MP
            (ARITH_RULE `&0 <= (s:real) ==> abs(s) = s`) sgeq0]) THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_m(fmt) x = m`)] THEN
            USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
            ASM_REWRITE_TAC[] THEN
            CONJ_TAC THENL [
              USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[GSYM xgmeq]) THEN
              ASM_REWRITE_TAC[] THEN
              ASM_ARITH_TAC;
              USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[GSYM xgmeq]) THEN
              ASM_REWRITE_TAC[] THEN
              ASM_ARITH_TAC]; ALL_TAC] THEN
          USE_THEN "sfloat" (fun sfloat -> USE_THEN "sgeq0" (fun sgeq0 ->
          float_normalize sfloat sgeq0 "s")) THEN
          ONCE_ASM_REWRITE_TAC[] THEN
          USE_THEN "sgegm" (fun sgegm -> REWRITE_TAC[sgegm]) THEN
          REWRITE_TAC[closer] THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((x:real) + y) - (x + z) = y - z`] THEN
          REWRITE_TAC[GSYM closer] THEN
          USE_THEN "xneq0" (fun xneq0 -> USE_THEN "xgeq0" (fun xgeq0 ->
          dump_gr_info xneq0 "x")) THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          USE_THEN "xgrleq" (fun xgrleq ->
          CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["froundeq"; "froundfixed";
             "closest"])
          (MATCH_MP FIXED_RD_NEAREST_CLOSEST
            (MATCH_MP (ARITH_RULE `(x:real) < y ==> x <= y`) xgrleq))) THEN
          REWRITE_TAC[GSYM(ASSUME `greatest_e(fmt) x = e`)] THEN
          REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
          USE_THEN "closest" (fun closest -> MATCH_MP_TAC
          (REWRITE_RULE[is_closest] closest)) THEN CONJ_TAC THENL [
            REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
            ASM_REWRITE_TAC[] THEN
            USE_THEN "sgegm" (fun sgegm -> REWRITE_TAC[GSYM sgegm]) THEN
            USE_THEN "sgrfixed" (fun sgrfixed -> REWRITE_TAC[sgrfixed]);
            ONCE_REWRITE_TAC[ARITH_RULE `(x:real) = y <=>
            &(greatest_m fmt s) * &(flr fmt) ipow greatest_e fmt s + x =
            &(greatest_m fmt s) * &(flr fmt) ipow greatest_e fmt s + y`] THEN
            USE_THEN "snormed" (fun snormed -> REWRITE_TAC[GSYM snormed]) THEN
            USE_THEN "sgegm" (fun sgegm -> REWRITE_TAC[sgegm]) THEN
            USE_THEN "froundeq"
                 (fun froundeq -> REWRITE_TAC[GSYM froundeq]) THEN
            USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
            REWRITE_TAC[ASSUME `greatest_r(fmt) x = y`] THEN
            REWRITE_TAC[ASSUME `greatest_e(fmt) x = e`] THEN
            USE_THEN "sneq" (fun sneq -> REWRITE_TAC[sneq])];

   (* x < 0 ------------------------------------ *)

          LABEL_TAC "xlt0" (ASSUME `~(&0 <= (x:real))`) THEN
          USE_THEN "xneq0" (fun xneq0 -> USE_THEN "xlt0" (fun xlt0 ->
          real_normalize xneq0 xlt0 "x")) THEN
          EXISTS_TAC `-- (&m * &(flr fmt) ipow e) +
                         fround (to_fformat fmt e) To_near y` THEN
          REWRITE_TAC[] THEN REWRITE_TAC[fl_is_closest] THEN
          GEN_TAC THEN
          DISCH_THEN (LABEL_CONJUNCTS_TAC ["sfloat"; "sneq"]) THEN

          (* run through cases *)
          ASM_CASES_TAC `-- (&m * &(flr fmt) ipow e) < s` THENL [
            (* s above the window *)
            DISJ1_TAC THEN MATCH_MP_TAC CLOSER_BETWEEN_4 THEN
            EXISTS_TAC `-- (&m * &(flr fmt) ipow e)` THEN CONJ_TAC THENL [
              MATCH_MP_TAC CLOSER_BETWEEN_5 THEN ASM_REWRITE_TAC[] THEN
              USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x" THEN
              dump_gm_info xneq0 "x") THEN
              USE_THEN "xlt0" (fun xlt0 ->
              ONCE_REWRITE_TAC[MATCH_MP
                (ARITH_RULE `~(&0 <= (x:real)) ==> x = -- abs(x)`) xlt0]) THEN
              REWRITE_TAC[ARITH_RULE `(-- (x:real)) <= -- y <=> y <= x`] THEN
              ONCE_REWRITE_TAC[GSYM (CONJ (ASSUME `greatest_e(fmt) x = e`)
                                     (ASSUME `greatest_m(fmt) x = m`))] THEN
              USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
              USE_THEN "xgmbig1" (fun xgmbig1 -> REWRITE_TAC[xgmbig1]);
              ASM_CASES_TAC `fround (to_fformat fmt e) To_near y = &0` THENL [
                (* the remainder is zero *)
                ASM_REWRITE_TAC[] THEN REWRITE_TAC[closer] THEN ARITH_TAC;
                (* the remainder is non-zero *)
                REWRITE_TAC[closer] THEN
                USE_THEN "xnormed" (fun xnormed ->
                                     ONCE_REWRITE_TAC[xnormed]) THEN
                REWRITE_TAC[GSYM (CONJ (ASSUME `greatest_m fmt x = m`)
                                     (CONJ (ASSUME `greatest_e fmt x = e`)
                                     (ASSUME `greatest_r fmt x = y`)))] THEN
                REWRITE_TAC[ARITH_RULE `((x:real) + y) - (x + z) = y - z`] THEN
                REWRITE_TAC[ARITH_RULE `(x:real) - (x + z) = &0 - z`] THEN
                REWRITE_TAC[GSYM closer] THEN
                USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                USE_THEN "xgrleq" (fun xgrleq ->
                CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["froundeq"; "froundfixed";
                  "closest"])
                (MATCH_MP FIXED_RD_NEAREST_CLOSEST
                 (MATCH_MP (ARITH_RULE `(x:real) < y ==> x <= y`) xgrleq))) THEN
                USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
                USE_THEN "closest" (fun closest -> MATCH_MP_TAC
                (REWRITE_RULE[is_closest] closest)) THEN CONJ_TAC THENL [
                  REWRITE_TAC[FIXED_ZERO_IN_FIXED];
                  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN USE_THEN "froundeq"
                  (fun froundeq -> REWRITE_TAC[GSYM froundeq]) THEN
                  REWRITE_TAC[ASSUME `greatest_e(fmt) x = e`] THEN
                  USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
                  REWRITE_TAC[ASSUME `greatest_r(fmt) x = y`] THEN
                  REWRITE_TAC[ASSUME `~(fround (to_fformat fmt e) To_near y =
                                            &0)`]]]]; ALL_TAC] THEN
          (* s below window *)
          ASM_CASES_TAC `s < -- (&m * &(flr fmt) ipow e) -
                               (finf (to_fformat fmt e))` THENL [
            DISJ1_TAC THEN MATCH_MP_TAC CLOSER_BETWEEN_4 THEN
            EXISTS_TAC `-- (&m * &(flr fmt) ipow e) -
                              (finf (to_fformat fmt e))` THEN CONJ_TAC THENL [
              MATCH_MP_TAC CLOSER_BETWEEN_3 THEN ASM_REWRITE_TAC[] THEN
              USE_THEN "xnormed" (fun xnormed -> ONCE_REWRITE_TAC[xnormed]) THEN
              ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[ARITH_RULE `(x:real) + y <= x + z <=> y <= z`] THEN
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
              SUBGOAL_THEN `(y':real) <= &0` (LABEL_TAC "ypleq0") THENL [
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
                REWRITE_TAC[greatest_r] THEN ASM_REWRITE_TAC[] THEN
                REWRITE_TAC[ARITH_RULE `(x:real) + y <= &0 <=> x <= -- y`] THEN
                USE_THEN "xlt0" (fun xlt0 -> ONCE_REWRITE_TAC[MATCH_MP
                (ARITH_RULE `~(&0 <= (x:real)) ==> x = -- abs(x)`) xlt0]) THEN
                REWRITE_TAC[ARITH_RULE `-- x <= -- y <=> y <= x`] THEN
                USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                REWRITE_TAC[GSYM(CONJ (ASSUME `greatest_e(fmt) x = e`)
                                      (ASSUME `greatest_m(fmt) x = m`))] THEN
                USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
                USE_THEN "xgmbig1" (fun xgmbig1 -> REWRITE_TAC[xgmbig1]);
                ALL_TAC] THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              USE_THEN "ypleq0" (fun ypleq0 -> ONCE_REWRITE_TAC[MATCH_MP
              (ARITH_RULE `(x:real) <= &0 ==> x = -- abs(x)`) ypleq0]) THEN
              REWRITE_TAC[GSYM (ASSUME `greatest_e(fmt) x = e`)] THEN
              ASM_ARITH_TAC;

              ASM_CASES_TAC `fround (to_fformat fmt e) To_near y =
                               -- (finf (to_fformat fmt e))` THENL [
                (* the remainder is finf *)
                ASM_REWRITE_TAC[] THEN REWRITE_TAC[closer] THEN ARITH_TAC;
                (* the remainder is non-finf *)
                REWRITE_TAC[closer] THEN
                USE_THEN "xnormed" (fun xnormed ->
                                     ONCE_REWRITE_TAC[xnormed]) THEN
                REWRITE_TAC[GSYM (CONJ (ASSUME `greatest_m fmt x = m`)
                                     (CONJ (ASSUME `greatest_e fmt x = e`)
                                     (ASSUME `greatest_r fmt x = y`)))] THEN
                REWRITE_TAC[ARITH_RULE `((x:real) + y) - (x + z) = y - z`] THEN
                REWRITE_TAC[ARITH_RULE
                            `((x:real) - y) - (x + z) = -- y - z`] THEN
                REWRITE_TAC[GSYM closer] THEN
                USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                USE_THEN "xgrleq" (fun xgrleq ->
                CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["froundeq"; "froundfixed";
                  "closest"])
                (MATCH_MP FIXED_RD_NEAREST_CLOSEST
                 (MATCH_MP (ARITH_RULE `(x:real) < y ==> x <= y`) xgrleq))) THEN
                USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
                USE_THEN "closest" (fun closest -> MATCH_MP_TAC
                (REWRITE_RULE[is_closest] closest)) THEN CONJ_TAC THENL [
                  REWRITE_TAC[FIXED_FINF_IN_FIXED];
                  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN USE_THEN "froundeq"
                  (fun froundeq -> REWRITE_TAC[GSYM froundeq]) THEN
                  REWRITE_TAC[ASSUME `greatest_e(fmt) x = e`] THEN
                  USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
                  REWRITE_TAC[ASSUME `greatest_r(fmt) x = y`] THEN
                  REWRITE_TAC[ASSUME `~(fround (to_fformat fmt e) To_near y =
                                      -- finf (to_fformat fmt e))`]]]];
                 ALL_TAC] THEN

          (* s is inside the window, but could be at top *)
          ASM_CASES_TAC `s = -- (&m * &(flr fmt) ipow e) -
                                finf (to_fformat fmt e)` THENL [
            (* take care of trivial case *)
            ASM_CASES_TAC
              `fround (to_fformat fmt e) To_near y =
                  -- finf (to_fformat fmt e)` THENL [
              ASM_REWRITE_TAC[] THEN REWRITE_TAC[closer] THEN ARITH_TAC;
              ALL_TAC] THEN
            (* now may assume we're not rounding to finf *)
            ASM_REWRITE_TAC[] THEN REWRITE_TAC[closer] THEN
            USE_THEN "xnormed" (fun xnormed -> ONCE_REWRITE_TAC[xnormed]) THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[ARITH_RULE `((x:real) + y) - (x + z) = y - z`] THEN
            REWRITE_TAC[ARITH_RULE `((x:real) - y) - (x + z) = -- y - z`] THEN
            REWRITE_TAC[GSYM closer] THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
            USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
            USE_THEN "xgrleq" (fun xgrleq ->
            CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["froundeq"; "froundfixed";
                "closest"])
            (MATCH_MP FIXED_RD_NEAREST_CLOSEST
              (MATCH_MP (ARITH_RULE `(x:real) < y ==> x <= y`) xgrleq))) THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_e(fmt) x = e`)] THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
            USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
            USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
            USE_THEN "closest" (fun closest -> MATCH_MP_TAC
            (REWRITE_RULE[is_closest] closest)) THEN CONJ_TAC THENL [
              REWRITE_TAC[GSYM FIXED_NEG_SYM] THEN
              REWRITE_TAC[FIXED_FINF_IN_FIXED];
              ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN
              USE_THEN "froundeq" (fun froundeq ->
                                      REWRITE_TAC[GSYM froundeq]) THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
              ASM_REWRITE_TAC[]]; ALL_TAC] THEN

        (* we can now assume s is inside the window *)
        SUBGOAL_THEN `(s:real) <= &0` (LABEL_TAC "sleq0") THENL [
          MATCH_MP_TAC REAL_LE_TRANS THEN
          EXISTS_TAC `-- (&m * &(flr fmt) ipow e)` THEN
          CONJ_TAC THENL [
            ASM_ARITH_TAC;
            MATCH_MP_TAC (ARITH_RULE `&0 <= (x:real) ==> -- x <= &0`) THEN
            MATCH_MP_TAC REAL_LE_MUL THEN
            REWRITE_TAC[REAL_OF_NUM_LE] THEN
            CONJ_TAC THENL[ ARITH_TAC; ALL_TAC] THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]; ALL_TAC] THEN
        SUBGOAL_THEN `~(s = &0)` (LABEL_TAC "sneq0") THENL [
          MATCH_MP_TAC (ARITH_RULE `(s:real) < &0 ==> ~(s = &0)`) THEN
          MATCH_MP_TAC
             (ARITH_RULE `!y. (y:real) < &0 /\ s <= y ==> s < &0`) THEN
          EXISTS_TAC `-- (&m * &(flr fmt) ipow e)` THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC (ARITH_RULE `&0 < (x:real) ==> -- x < &0`) THEN
            MATCH_MP_TAC REAL_LT_MUL THEN
            REWRITE_TAC[REAL_OF_NUM_LT] THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_m(fmt) x = m`)] THEN
            USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
            USE_THEN "xgmgeq1" (fun xgmgeq1 -> REWRITE_TAC[MATCH_MP
            (ARITH_RULE `1 <= m' ==> 0 < m'`) xgmgeq1]) THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0];
            ASM_ARITH_TAC]; ALL_TAC] THEN
          SUBGOAL_THEN `greatest_e(fmt) s = e /\ greatest_m(fmt) s = m`
          (LABEL_TAC "sgegm") THENL [
            MATCH_MP_TAC FLOAT_BETWEEN THEN ASM_REWRITE_TAC[] THEN
            USE_THEN "sleq0" (fun sleq0 -> REWRITE_TAC[MATCH_MP
            (ARITH_RULE `(s:real) <= &0 ==> abs(s) = -- s`) sleq0]) THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_m(fmt) x = m`)] THEN
            USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
            ASM_REWRITE_TAC[] THEN
            CONJ_TAC THENL [
              USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[GSYM xgmeq]) THEN
              ASM_REWRITE_TAC[] THEN
              ASM_ARITH_TAC;
              USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[GSYM xgmeq]) THEN
              ASM_REWRITE_TAC[] THEN
              ASM_ARITH_TAC]; ALL_TAC] THEN
          USE_THEN "sfloat" (fun sfloat -> USE_THEN "sleq0" (fun sleq0 ->
          USE_THEN "sneq0" (fun sneq0 -> float_normalize sfloat (MATCH_MP
            (ARITH_RULE `~(s = &0) /\ s <= &0 ==> ~(&0 <= (s:real))`)
            (CONJ sneq0 sleq0)) "s"))) THEN
          ONCE_ASM_REWRITE_TAC[] THEN
          USE_THEN "sgegm" (fun sgegm -> REWRITE_TAC[sgegm]) THEN
          REWRITE_TAC[closer] THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((x:real) + y) - (x + z) = y - z`] THEN
          REWRITE_TAC[GSYM closer] THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          USE_THEN "xgrleq" (fun xgrleq ->
          CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["froundeq"; "froundfixed";
             "closest"])
          (MATCH_MP FIXED_RD_NEAREST_CLOSEST
            (MATCH_MP (ARITH_RULE `(x:real) < y ==> x <= y`) xgrleq))) THEN
          REWRITE_TAC[GSYM(ASSUME `greatest_e(fmt) x = e`)] THEN
          REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
          USE_THEN "closest" (fun closest -> MATCH_MP_TAC
          (REWRITE_RULE[is_closest] closest)) THEN CONJ_TAC THENL [
            REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
            ASM_REWRITE_TAC[] THEN
            USE_THEN "sgegm" (fun sgegm -> REWRITE_TAC[GSYM sgegm]) THEN
            USE_THEN "sgrfixed" (fun sgrfixed -> REWRITE_TAC[sgrfixed]);
            ONCE_REWRITE_TAC[ARITH_RULE `(x:real) = y <=>
         -- (&(greatest_m fmt s) * &(flr fmt) ipow greatest_e fmt s) + x =
         -- (&(greatest_m fmt s) * &(flr fmt) ipow greatest_e fmt s) + y`] THEN
            USE_THEN "snormed" (fun snormed -> REWRITE_TAC[GSYM snormed]) THEN
            USE_THEN "sgegm" (fun sgegm -> REWRITE_TAC[sgegm]) THEN
            USE_THEN "froundeq"
                 (fun froundeq -> REWRITE_TAC[GSYM froundeq]) THEN
            USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[GSYM xgreq]) THEN
            REWRITE_TAC[ASSUME `greatest_r(fmt) x = y`] THEN
            REWRITE_TAC[ASSUME `greatest_e(fmt) x = e`] THEN
            USE_THEN "sneq" (fun sneq -> REWRITE_TAC[sneq])]]);;

let FLOAT_M_POW_E_IS_FLOAT =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          is_float(fmt)
          (&(greatest_m(fmt) x) *
           &(flr fmt) ipow (greatest_e(fmt) x))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[is_float] THEN REWRITE_TAC[is_frac_and_exp] THEN
        EXISTS_TAC `(greatest_m(fmt) x) * (flr fmt) EXP ((flp fmt) - 1)` THEN
        EXISTS_TAC `(greatest_e(fmt) x)` THEN
        CONJ_TAC THENL [
          REWRITE_TAC[LT_MULT] THEN
          CONJ_TAC THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_ARITH_TAC;
            REWRITE_TAC[EXP_LT_0] THEN DISJ1_TAC THEN
            REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
            REWRITE_TAC[FLFORMAT_RADIX_NE_0]]; ALL_TAC] THEN
        CONJ_TAC THENL [
          MATCH_MP_TAC (ARITH_RULE `!y. (x:num) < y /\ y = z ==> x < z`) THEN
          EXISTS_TAC `(flr fmt) * flr fmt EXP ((flp fmt) - 1)` THEN
          CONJ_TAC THENL [
            REWRITE_TAC[LT_MULT_RCANCEL] THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_REWRITE_TAC[] THEN REWRITE_TAC[EXP_EQ_0] THEN
            REWRITE_TAC[DE_MORGAN_THM] THEN DISJ1_TAC THEN
            REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
            REWRITE_TAC[FLFORMAT_RADIX_NE_0];
            ONCE_REWRITE_TAC[GSYM EXP] THEN
            REWRITE_TAC[MATCH_MP (ARITH_RULE `0 < x ==> SUC(x - 1) = x`)
              (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0)]]; ALL_TAC] THEN

        SUBGOAL_THEN `&0 <=
                &(greatest_m fmt x) * &(flr fmt) ipow (greatest_e fmt x)`
         (LABEL_TAC "mgeq0") THENL [
           MATCH_MP_TAC REAL_LE_MUL THEN
           REWRITE_TAC[REAL_OF_NUM_LE] THEN
           USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
           CONJ_TAC THENL [ ASM_ARITH_TAC; ALL_TAC ] THEN
           REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]; ALL_TAC] THEN

        USE_THEN "mgeq0" (fun mgeq0 -> REWRITE_TAC[MATCH_MP
          (ARITH_RULE `&0 <= (x:real) ==> abs(x) = x`) mgeq0]) THEN
        REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
        REWRITE_TAC[GSYM(MATCH_MP IPOW_EQ_EXP_P
          (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
        REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
        REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
         (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
        REWRITE_TAC[ARITH_RULE `(e:int) - &1 + (e2:int) - e + &1 = e2`]);;

let FLOAT_NEG_IS_FLOAT =
  prove(`!(fmt:flformat) (x:real). is_float(fmt) x <=> is_float(fmt) (-- x)`,
        REPEAT GEN_TAC THEN REWRITE_TAC[is_float] THEN
        REWRITE_TAC[is_frac_and_exp] THEN
        REWRITE_TAC[ARITH_RULE `abs(-- x) = abs(x)`]);;

let FLOAT_PLUS_FIXED_IS_FLOAT =
  prove(`!(fmt:flformat) (x:real) (z:real).
          ~(x = &0) /\ &0 <= z /\
            is_fixed(to_fformat(fmt) (greatest_e(fmt) x)) z ==>
          is_float(fmt)
          (&(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x) + z)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
         ["xneq0"; "zgeq0"; "zisfixed"]) THEN REWRITE_TAC[is_float] THEN
        REWRITE_TAC[is_frac_and_exp] THEN

        SUBGOAL_THEN `!(m:num).
            abs(&m * &(flr fmt) ipow (greatest_e(fmt) x) + z) =
                &m * &(flr fmt) ipow (greatest_e(fmt) x) + z`
        (LABEL_TAC "mgeq0") THENL [
          GEN_TAC THEN
          MATCH_MP_TAC
            (ARITH_RULE `&0 <= (x:real) /\ &0 <= y ==> abs(x + y) = x + y`) THEN
          ASM_REWRITE_TAC[] THEN
          MATCH_MP_TAC REAL_LE_MUL THEN
          REWRITE_TAC[REAL_OF_NUM_LE] THEN
          CONJ_TAC THENL[ ARITH_TAC; ALL_TAC] THEN
          REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]; ALL_TAC] THEN

        (* take care of edge case when z = finf *)
        ASM_CASES_TAC `z = (finf (to_fformat fmt (greatest_e(fmt) x)))` THENL [
          (* take care of edge case when m = r - 1 *)
          ASM_CASES_TAC `greatest_m(fmt) x = (flr fmt) - 1` THENL [
            EXISTS_TAC `(flr fmt) EXP ((flp fmt) - 1)` THEN
            EXISTS_TAC `greatest_e(fmt) x + &1` THEN
            (* show fraction is > 0 *)
            CONJ_TAC THENL [
              REWRITE_TAC[EXP_LT_0] THEN DISJ1_TAC THEN
              REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0]; ALL_TAC] THEN
            (* show fraction is < r^p *)
            CONJ_TAC THENL [
              GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
              [MATCH_MP (ARITH_RULE `0 < (n:num) ==> n = SUC(n - 1)`)
                (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0)] THEN
              REWRITE_TAC[EXP] THEN
              GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
              [ARITH_RULE `n:num = 1 * n`] THEN
              REWRITE_TAC[LT_MULT_RCANCEL] THEN
              REWRITE_TAC[FLFORMAT_RADIX_LT_1] THEN REWRITE_TAC[EXP_EQ_0] THEN
              REWRITE_TAC[DE_MORGAN_THM] THEN DISJ1_TAC THEN
              REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0]; ALL_TAC] THEN
        (* show magnitude is equal *)
        ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[finf] THEN dump_flformat_conv `(greatest_e(fmt) x)` THEN
        ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
           (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
        REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
         (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
        REWRITE_TAC[ARITH_RULE `(e:int) - &1 + (e2:int) - e + &1 = e2`] THEN

        SUBGOAL_THEN `1 <= (flr fmt)`
        (fun thm -> REWRITE_TAC[GSYM (MATCH_MP REAL_OF_NUM_SUB thm)]) THENL [
          ASSUME_TAC (SPEC `fmt:flformat` FLFORMAT_RADIX_LT_1) THEN
          ASM_ARITH_TAC; ALL_TAC] THEN

        REWRITE_TAC[ARITH_RULE
          `((x:real) - &1) * (z:real) + z = x * z`] THEN

        GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RATOR_CONV o RAND_CONV o
                           ONCE_DEPTH_CONV)
        [GSYM IPOW_TO_1] THEN
        REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
         (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
        GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
        [ARITH_RULE `(a:int) + b = b + a`] THEN ARITH_TAC; ALL_TAC] THEN

     (* may assume now that m < r - 1 *)
     EXISTS_TAC `((greatest_m(fmt) x) + 1) * (flr fmt) EXP ((flp fmt) - 1)` THEN
     EXISTS_TAC `greatest_e(fmt) x` THEN
     (* show fraction is > 0 *)
     CONJ_TAC THENL [
       REWRITE_TAC[LT_MULT] THEN
       CONJ_TAC THENL [
         USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
         ASM_ARITH_TAC;
         REWRITE_TAC[EXP_LT_0] THEN DISJ1_TAC THEN
         REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
         REWRITE_TAC[FLFORMAT_RADIX_NE_0]]; ALL_TAC] THEN
    (* show fraction is < r^p *)
    CONJ_TAC THENL [
      MATCH_MP_TAC
        (ARITH_RULE `!y. (x:num) < y /\ y = z ==> x < z`) THEN
      EXISTS_TAC `(flr fmt) * (flr fmt) EXP ((flp fmt) - 1)` THEN
      CONJ_TAC THENL [
        REWRITE_TAC[LT_MULT_RCANCEL] THEN
        CONJ_TAC THENL [
          USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
          ASM_ARITH_TAC;
          REWRITE_TAC[EXP_EQ_0] THEN
          REWRITE_TAC[DE_MORGAN_THM] THEN DISJ1_TAC THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
          REWRITE_TAC[FLFORMAT_RADIX_NE_0]];
        SUBGOAL_THEN `(flp fmt) = SUC((flp fmt) - 1)`
        (fun thm -> GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV) [thm]) THENL [
          ASSUME_TAC (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0) THEN
          ASM_ARITH_TAC; ALL_TAC] THEN
        REWRITE_TAC[EXP]]; ALL_TAC] THEN
     (* show magnitude is equal *)
     ASM_REWRITE_TAC[] THEN
     REWRITE_TAC[finf] THEN dump_flformat_conv `(greatest_e(fmt) x)` THEN
     ASM_REWRITE_TAC[] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
           (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
     REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
     REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
         (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
     REWRITE_TAC[ARITH_RULE `(e:int) - &1 + (e2:int) - e + &1 = e2`] THEN
     REWRITE_TAC[ARITH_RULE `(x:real) * z + z = (x + &1) * z`] THEN
     REWRITE_TAC[REAL_OF_NUM_ADD]; ALL_TAC] THEN

   (* okay, edge cases out of the way, we can now assume z < finf *)
   EXISTS_TAC `(greatest_m(fmt) x) * (flr fmt) EXP ((flp fmt) - 1) +
                    ff(to_fformat fmt (greatest_e(fmt) x)) z` THEN
   EXISTS_TAC `(greatest_e(fmt) x)` THEN
   (* show frac > 0 *)
   CONJ_TAC THENL [
     MATCH_MP_TAC (ARITH_RULE `0 < x ==> 0 < x + y`) THEN
     REWRITE_TAC[LT_MULT] THEN
     CONJ_TAC THENL [
       USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
       ASM_ARITH_TAC;
       REWRITE_TAC[EXP_LT_0] THEN DISJ1_TAC THEN
       REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
       REWRITE_TAC[FLFORMAT_RADIX_NE_0]]; ALL_TAC] THEN
   (* show frac < r^p *)
   CONJ_TAC THENL [
     MATCH_MP_TAC (ARITH_RULE `!y. (x:num) < y /\ y = z ==> x < z`) THEN
     EXISTS_TAC `(flr fmt) * (flr fmt) EXP ((flp fmt) - 1)` THEN
     CONJ_TAC THENL [

       MATCH_MP_TAC (ARITH_RULE `!y. (x:num) < y /\ y <= z ==> x < z`) THEN
       EXISTS_TAC `(greatest_m(fmt) x) * (flr fmt) EXP ((flp fmt) - 1) +
                      (flr fmt) EXP ((flp fmt) - 1)` THEN
       CONJ_TAC THENL [

         SUBGOAL_THEN `abs(z) < finf (to_fformat fmt (greatest_e(fmt) x))`
         (LABEL_TAC "abszlt") THENL [
           USE_THEN "zisfixed" (fun zisfixed ->
           ASSUME_TAC (MATCH_MP (REWRITE_RULE[IN_ELIM_THM]
             (REWRITE_RULE[fixed] (SPEC `(to_fformat fmt (greatest_e(fmt) x))`
                                     FIXED_FINF_BOUNDS))) zisfixed)) THEN
           ASM_ARITH_TAC; ALL_TAC] THEN

         USE_THEN "zisfixed" (fun zisfixed -> USE_THEN "abszlt" (fun abszlt ->
           LABEL_TAC "fflt" (MATCH_MP
             (SPEC `(to_fformat fmt (greatest_e(fmt) x))` FIXED_FF_LT)
             (CONJ zisfixed abszlt)))) THEN
         REWRITE_TAC[LT_ADD_LCANCEL] THEN
         dump_flformat_conv `(greatest_e(fmt) x)` THEN
         USE_THEN "fmteqr" (fun fmteqr -> REWRITE_TAC[GSYM fmteqr]) THEN
         USE_THEN "fmteqp" (fun fmteqp -> REWRITE_TAC[GSYM fmteqp]) THEN
         USE_THEN "fmteq" (fun fmteq -> REWRITE_TAC[GSYM fmteq]) THEN
         USE_THEN "fflt" (fun fflt -> REWRITE_TAC[fflt]);

         REWRITE_TAC[ARITH_RULE `(m:num) * n + n = (m + 1) * n`] THEN
         REWRITE_TAC[LE_MULT_RCANCEL] THEN DISJ1_TAC THEN
         USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
         ASM_ARITH_TAC];

       SUBGOAL_THEN `(flp fmt) = SUC((flp fmt) - 1)`
       (fun thm -> GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV) [thm]) THENL [
         ASSUME_TAC (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0) THEN
         ASM_ARITH_TAC; ALL_TAC] THEN
       REWRITE_TAC[EXP]]; ALL_TAC] THEN

    (* show magnitude is equal *)
    ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
    REWRITE_TAC[ARITH_RULE `((a:real) + b) * c = a * c + b * c`] THEN
    REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
    REWRITE_TAC[GSYM (MATCH_MP (SPEC `(flr fmt)` IPOW_EQ_EXP_P)
           (SPEC `fmt:flformat` FLFORMAT_PREC_LT_0))] THEN
    REWRITE_TAC[ARITH_RULE `((a:real) * b) * c = a * (b * c)`] THEN
    REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
         (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
    REWRITE_TAC[ARITH_RULE `(e:int) - &1 + (e2:int) - e + &1 = e2`] THEN
    REWRITE_TAC[ARITH_RULE `(x:real) * z + z = (x + &1) * z`] THEN
    REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
    REWRITE_TAC[REAL_EQ_ADD_LCANCEL] THEN

    SUBGOAL_THEN `z = abs(z)`
    (fun thm -> GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o ONCE_DEPTH_CONV)
      [thm]) THENL [
      ASM_ARITH_TAC; ALL_TAC] THEN

    dump_flformat_conv `(greatest_e(fmt) x)` THEN
    ASM_REWRITE_TAC[] THEN
    USE_THEN "fmteqr" (fun fmteqr -> REWRITE_TAC[GSYM fmteqr]) THEN
    USE_THEN "fmteqp" (fun fmteqp -> REWRITE_TAC[GSYM fmteqp]) THEN
    USE_THEN "fmteqe" (fun fmteqe ->
      GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o ONCE_DEPTH_CONV)
        [GSYM fmteqe]) THEN
    USE_THEN "fmteq" (fun fmteq -> ONCE_REWRITE_TAC[GSYM fmteq]) THEN
    USE_THEN "zisfixed" (fun zisfixed ->
      REWRITE_TAC[MATCH_MP (SPEC `(to_fformat fmt (greatest_e(fmt) x))`
           FIXED_FF_REP) zisfixed]));;

let FLOAT_PLUS_FIXED_IS_FLOAT_2 =
  prove(`!(fmt:flformat) (x:real) (z:real).
          ~(x = &0) /\ ~(&0 <= z) /\
            is_fixed(to_fformat(fmt) (greatest_e(fmt) x)) z ==>
          is_float(fmt)
       ((-- (&(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x))) + z)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
         ["xneq0"; "zlt0"; "zisfixed"]) THEN

        SUBGOAL_THEN `is_fixed (to_fformat fmt (greatest_e fmt x)) (-- z)`
        (LABEL_TAC "negzfixed") THENL [
          USE_THEN "zisfixed" (fun zisfixed ->
            REWRITE_TAC[ONCE_REWRITE_RULE[
              REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed] FIXED_NEG_SYM)]
                 zisfixed]); ALL_TAC] THEN

        SUBGOAL_THEN `&0 <= (-- z)` (LABEL_TAC "negzgeq0") THENL [
          ASM_ARITH_TAC; ALL_TAC] THEN

        ONCE_REWRITE_TAC[FLOAT_NEG_IS_FLOAT] THEN
        REWRITE_TAC[ARITH_RULE `-- ( (-- (x:real)) + z) = x + (-- z)`] THEN
        MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT THEN ASM_REWRITE_TAC[]);;

let FLOAT_REVERSE_NORMALIZE_FLOAT =
  prove(`!(fmt:flformat) (x:real) (y:real).
          ~(x = &0) /\ is_float(fmt) y /\ fl_is_closest(fmt) x y ==>
          (~(abs(y) = &(greatest_m fmt x) *
                         &(flr fmt) ipow greatest_e fmt x +
                         (finf (to_fformat fmt (greatest_e(fmt) x)))) ==>
            (greatest_m(fmt) y) = (greatest_m(fmt) x) /\
            (greatest_e(fmt) y) = (greatest_e(fmt) x)) /\
          ?(z:real). is_fixed(to_fformat fmt (greatest_e(fmt) x)) z /\
          (if (&0 <= y)
           then
               y = &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x) +
                  z
           else
               y = -- (&(greatest_m(fmt) x) *
                      &(flr fmt) ipow (greatest_e(fmt) x)) + z)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
         ["xneq0"; "yisfloat"; "yisclosest"]) THEN

        (* easy case 1 *)
        ASM_CASES_TAC `abs(y) = &(greatest_m fmt x) *
                         &(flr fmt) ipow greatest_e fmt x` THENL [
          CONJ_TAC THENL [
            DISCH_TAC THEN
            ONCE_REWRITE_TAC[TAUT `a /\ b <=> b /\ a`] THEN
            MATCH_MP_TAC FLOAT_EQ_IPOW THEN
            ASM_REWRITE_TAC[] THEN
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_REWRITE_TAC[] THEN
            MATCH_MP_TAC (SPEC `fmt:flformat` FLOAT_NOT_ZERO) THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN

          EXISTS_TAC `&0` THEN
          REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed]
            FIXED_ZERO_IN_FIXED)] THEN
          COND_CASES_TAC THENL [ASM_ARITH_TAC; ASM_ARITH_TAC]; ALL_TAC] THEN

       (* easy case 2 *)
       ASM_CASES_TAC `abs(y) = &(greatest_m fmt x) *
                         &(flr fmt) ipow greatest_e fmt x +
                         (finf (to_fformat fmt (greatest_e(fmt) x)))` THENL [
          CONJ_TAC THENL [
            ASM_SIMP_TAC[]; ALL_TAC] THEN

          ASM_CASES_TAC `&0 <= (y:real)` THENL [
            ASM_REWRITE_TAC[] THEN
            EXISTS_TAC `(finf (to_fformat fmt (greatest_e(fmt) x)))` THEN
            REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed]
              FIXED_FINF_IN_FIXED)] THEN
            ASM_ARITH_TAC;
            ASM_REWRITE_TAC[] THEN
            EXISTS_TAC `-- (finf (to_fformat fmt (greatest_e(fmt) x)))` THEN
            REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed]
              (ONCE_REWRITE_RULE[FIXED_NEG_SYM] FIXED_FINF_IN_FIXED))] THEN
            ASM_ARITH_TAC]; ALL_TAC] THEN

      (* easy cases out of the way, now re-use float between theorem *)

      (* first show lower bound *)
      SUBGOAL_THEN `&(greatest_m(fmt) x) *
                     &(flr fmt) ipow (greatest_e(fmt) x) <= abs y`
      (LABEL_TAC "absylower") THENL [

        ASM_CASES_TAC `&0 <= (x:real)` THENL [

          (* we will use MP with the float m * r^e and defn of is closest *)
          SUBGOAL_THEN `&0 <= &(greatest_m(fmt) x) *
                           &(flr fmt) ipow (greatest_e(fmt) x)`
          ASSUME_TAC THENL [
            ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_MUL THEN
            CONJ_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
              ASM_ARITH_TAC;
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]; ALL_TAC] THEN

          USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "misfloat"
              (MATCH_MP
                (SPEC `fmt:flformat` FLOAT_M_POW_E_IS_FLOAT) xneq0)) THEN

            SUBGOAL_THEN `~(&(greatest_m fmt x) *
                              &(flr fmt) ipow (greatest_e fmt x) = y)`
            (LABEL_TAC "mneq") THENL [
              ASM_ARITH_TAC; ALL_TAC] THEN

            SUBGOAL_THEN `abs ((&(greatest_m fmt x) *
                         &(flr fmt) ipow (greatest_e fmt x)) - x) =
               x - &(greatest_m fmt x) * &(flr fmt) ipow (greatest_e fmt x)`
            ASSUME_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
              ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC; ALL_TAC] THEN

            USE_THEN "yisclosest" (fun yisclosest ->
            USE_THEN "misfloat" (fun misfloat ->
            USE_THEN "mneq" (fun mneq ->
            DISJ_CASES_TAC (MATCH_MP (REWRITE_RULE[fl_is_closest] yisclosest)
             (CONJ misfloat mneq))))) THENL [

              (* y closer to x *)
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `closer y
           (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x) x`)) THEN
              ASM_ARITH_TAC;
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `~(closer
        (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x) y x)`)) THEN
              ASM_ARITH_TAC];

        (* x < 0 *)
        SUBGOAL_THEN `&0 < &(greatest_m(fmt) x) *
                           &(flr fmt) ipow (greatest_e(fmt) x)`
        ASSUME_TAC THENL [
          ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LT_MUL THEN
          CONJ_TAC THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            REWRITE_TAC[REAL_OF_NUM_LT] THEN
            ASM_ARITH_TAC;
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]]; ALL_TAC] THEN

         USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "misfloat"
           (ONCE_REWRITE_RULE[FLOAT_NEG_IS_FLOAT]
          (MATCH_MP (SPEC `fmt:flformat` FLOAT_M_POW_E_IS_FLOAT) xneq0))) THEN

         SUBGOAL_THEN `abs (-- (&(greatest_m fmt x) *
                         &(flr fmt) ipow (greatest_e fmt x)) - x) =
             (-- x) - &(greatest_m fmt x) * &(flr fmt) ipow (greatest_e fmt x)`
          ASSUME_TAC THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC; ALL_TAC] THEN

          SUBGOAL_THEN `~(-- (&(greatest_m fmt x) *
                              &(flr fmt) ipow (greatest_e fmt x)) = y)`
            (LABEL_TAC "mneq") THENL [
              ASM_ARITH_TAC; ALL_TAC] THEN

          USE_THEN "yisclosest" (fun yisclosest ->
          USE_THEN "misfloat" (fun misfloat ->
          USE_THEN "mneq" (fun mneq ->
            DISJ_CASES_TAC (MATCH_MP (REWRITE_RULE[fl_is_closest] yisclosest)
             (CONJ misfloat mneq))))) THENL [

              (* y closer to x *)
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `closer y
         (-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) x`)) THEN
              ASM_ARITH_TAC;
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `~(closer
      (-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) y x)`)) THEN
              ASM_ARITH_TAC]]; ALL_TAC] THEN

    (* show upper bound on abs(y) *)
      SUBGOAL_THEN `abs(y) < &(greatest_m(fmt) x) *
                     &(flr fmt) ipow (greatest_e(fmt) x) +
                    (finf (to_fformat fmt (greatest_e(fmt) x)))`
      (LABEL_TAC "absyupper") THENL [

        ASM_CASES_TAC `&0 <= (x:real)` THENL [

          (* we will use MP with the float m * r^e + finf and defn of closest *)
          SUBGOAL_THEN `&0 <= &(greatest_m(fmt) x) *
                           &(flr fmt) ipow (greatest_e(fmt) x) +
                           (finf (to_fformat fmt (greatest_e(fmt) x)))`
          ASSUME_TAC THENL [
            MATCH_MP_TAC REAL_LE_ADD THEN
            CONJ_TAC THENL [
              ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_MUL THEN
              CONJ_TAC THENL [
                USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                ASM_ARITH_TAC;
                REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]];
              REWRITE_TAC[finf] THEN REWRITE_TAC[FFORMAT_RADIX_IPOW_LE_0]];
            ALL_TAC] THEN

          SUBGOAL_THEN `is_float(fmt)
                           (&(greatest_m(fmt) x) *
                            &(flr fmt) ipow (greatest_e(fmt) x) +
                            (finf (to_fformat fmt (greatest_e(fmt) x))))`
          (LABEL_TAC "misfloat") THENL [
            MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT THEN
            ASM_REWRITE_TAC[] THEN
            CONJ_TAC THENL [
              REWRITE_TAC[finf] THEN REWRITE_TAC[FFORMAT_RADIX_IPOW_LE_0];
              REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed]
                             FIXED_FINF_IN_FIXED)]]; ALL_TAC] THEN

            SUBGOAL_THEN `~(
              &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
                (finf (to_fformat fmt (greatest_e fmt x))) = y)`
            (LABEL_TAC "mneq") THENL [
              ASM_ARITH_TAC; ALL_TAC] THEN

            SUBGOAL_THEN `abs (
        &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
        (finf (to_fformat fmt (greatest_e fmt x))) - x) =

        &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
        (finf (to_fformat fmt (greatest_e fmt x))) - x`
         ASSUME_TAC THENL [
           USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "xnormed" (
             REWRITE_RULE[ASSUME `&0 <= (x:real)`]
             (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))) THEN
           USE_THEN "xnormed" (fun xnormed ->
            GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RAND_CONV o
                ONCE_DEPTH_CONV)
            [xnormed]) THEN
           USE_THEN "xnormed" (fun xnormed ->
            GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RAND_CONV o RAND_CONV o
                  RAND_CONV o ONCE_DEPTH_CONV)
            [xnormed]) THEN
           REWRITE_TAC[ARITH_RULE `(x:real) + (y - (x + z)) = y - z`] THEN
           USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
           ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC; ALL_TAC] THEN

        USE_THEN "yisclosest" (fun yisclosest ->
        USE_THEN "misfloat" (fun misfloat ->
        USE_THEN "mneq" (fun mneq ->
            DISJ_CASES_TAC (MATCH_MP (REWRITE_RULE[fl_is_closest] yisclosest)
             (CONJ misfloat mneq))))) THENL [

              (* y closer to x *)
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME
        `closer y
          (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
          finf (to_fformat fmt (greatest_e fmt x)))
          x`)) THEN
              ASM_ARITH_TAC;

              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME
             `~closer
            (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
            finf (to_fformat fmt (greatest_e fmt x)))
            y
            x`)) THEN
              ASM_ARITH_TAC];

        (* x < 0 *)
          SUBGOAL_THEN `&0 < &(greatest_m(fmt) x) *
                           &(flr fmt) ipow (greatest_e(fmt) x) +
                           (finf (to_fformat fmt (greatest_e(fmt) x)))`
          ASSUME_TAC THENL [
            MATCH_MP_TAC REAL_LT_ADD THEN
            CONJ_TAC THENL [
              ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LT_MUL THEN
              CONJ_TAC THENL [
                USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                REWRITE_TAC[REAL_OF_NUM_LT] THEN
                ASM_ARITH_TAC;
                REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]];
              REWRITE_TAC[finf] THEN REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0]];
            ALL_TAC] THEN


          SUBGOAL_THEN `is_float(fmt)
                           ((-- (&(greatest_m(fmt) x) *
                            &(flr fmt) ipow (greatest_e(fmt) x))) +
                            (-- (finf (to_fformat fmt (greatest_e(fmt) x)))))`
          (LABEL_TAC "misfloat") THENL [
            MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT_2 THEN
            ASM_REWRITE_TAC[] THEN
            CONJ_TAC THENL [
              REWRITE_TAC[finf] THEN
              REWRITE_TAC[ARITH_RULE `~(&0 <= -- (x:real)) <=> &0 < x`] THEN
              REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0];
              REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed]
                             FIXED_FINF_IN_FIXED)]]; ALL_TAC] THEN

            SUBGOAL_THEN `~(
              (-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) +
                (-- (finf (to_fformat fmt (greatest_e fmt x)))) = y)`
            (LABEL_TAC "mneq") THENL [
              ASM_ARITH_TAC; ALL_TAC] THEN

            SUBGOAL_THEN `abs (
        (-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) +
        (-- (finf (to_fformat fmt (greatest_e fmt x)))) - x) =

        &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
        (finf (to_fformat fmt (greatest_e fmt x))) - (-- x)`
         ASSUME_TAC THENL [
           USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "xnormed" (
             REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
             (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))) THEN
           USE_THEN "xnormed" (fun xnormed ->
            GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RAND_CONV o
                ONCE_DEPTH_CONV)
            [xnormed]) THEN
           USE_THEN "xnormed" (fun xnormed ->
            GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RAND_CONV o RAND_CONV o
                  RAND_CONV o ONCE_DEPTH_CONV)
            [xnormed]) THEN
           REWRITE_TAC[ARITH_RULE `(x:real) + (y - (x + z)) = y - z`] THEN
           REWRITE_TAC[ARITH_RULE `(x:real) + (y - (-- ((-- x) + z))) =
                                     y - (-- z)`] THEN
           USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
           ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC; ALL_TAC] THEN


          USE_THEN "yisclosest" (fun yisclosest ->
          USE_THEN "misfloat" (fun misfloat ->
          USE_THEN "mneq" (fun mneq ->
            DISJ_CASES_TAC (MATCH_MP (REWRITE_RULE[fl_is_closest] yisclosest)
             (CONJ misfloat mneq))))) THENL [

              (* y closer to x *)
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `closer y
      (--(&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x) +
       --finf (to_fformat fmt (greatest_e fmt x)))
      x`)) THEN
              ASM_ARITH_TAC;
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `~closer
       (--(&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x) +
        --finf (to_fformat fmt (greatest_e fmt x)))
       y
       x`)) THEN
              ASM_ARITH_TAC]]; ALL_TAC] THEN

   (* OKAY: now most of the hard work is done *)

   SUBGOAL_THEN `greatest_e(fmt) y = greatest_e(fmt) x /\
                 greatest_m(fmt) y = greatest_m(fmt) x`
   (LABEL_TAC "ygegmeq") THENL [
     (* use float between theorem *)
     MATCH_MP_TAC FLOAT_BETWEEN THEN
     CONJ_TAC THENL [
       MATCH_MP_TAC (SPEC `fmt:flformat` FLOAT_NOT_ZERO) THEN
       ASM_REWRITE_TAC[]; ALL_TAC] THEN
     CONJ_TAC THENL [
       USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
       ASM_REWRITE_TAC[]; ALL_TAC] THEN
     CONJ_TAC THENL [
       USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
       ASM_REWRITE_TAC[]; ALL_TAC] THEN
     ASM_REWRITE_TAC[]; ALL_TAC] THEN

     ASM_SIMP_TAC[] THEN

     EXISTS_TAC `greatest_r(fmt) y` THEN
     USE_THEN "ygegmeq" (fun ygegmeq -> REWRITE_TAC[GSYM ygegmeq]) THEN
   MATCH_MP_TAC FLOAT_NORMALIZE_FLOAT THEN ASM_REWRITE_TAC[]);;

let FLOAT_REVERSE_NORMALIZE_LE =
  prove(`!(fmt:flformat) (x:real) (y:real).
          ~(x = &0) /\ &0 <= x /\ fl_is_closest(fmt) x y ==>
          &0 <= y`,

        (* we will use MP with the float m * r^e and defn of is closest *)
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
          ["xneq0"; "xgeq0"; "yisclosest"]) THEN

        SUBGOAL_THEN `&0 <= &(greatest_m(fmt) x) *
                           &(flr fmt) ipow (greatest_e(fmt) x)`
        ASSUME_TAC THENL [
          ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_MUL THEN
          CONJ_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
              ASM_ARITH_TAC;
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]; ALL_TAC] THEN

        USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "misfloat"
              (MATCH_MP
                (SPEC `fmt:flformat` FLOAT_M_POW_E_IS_FLOAT) xneq0)) THEN

        (* get edge case out of the way *)
        ASM_CASES_TAC `&(greatest_m fmt x) *
                              &(flr fmt) ipow (greatest_e fmt x) = y` THENL [
          ASM_ARITH_TAC; ALL_TAC] THEN

        LABEL_TAC "mneq" (ASSUME `~(&(greatest_m fmt x) *
                              &(flr fmt) ipow (greatest_e fmt x) = y)`) THEN

        SUBGOAL_THEN `abs ((&(greatest_m fmt x) *
                         &(flr fmt) ipow (greatest_e fmt x)) - x) =
               x - &(greatest_m fmt x) * &(flr fmt) ipow (greatest_e fmt x)`
        ASSUME_TAC THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
              ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC; ALL_TAC] THEN

        USE_THEN "yisclosest" (fun yisclosest ->
        USE_THEN "misfloat" (fun misfloat ->
        USE_THEN "mneq" (fun mneq ->
          DISJ_CASES_TAC (MATCH_MP (REWRITE_RULE[fl_is_closest] yisclosest)
             (CONJ misfloat mneq))))) THENL [

              (* y closer to x *)
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `closer y
           (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x) x`)) THEN
              ASM_ARITH_TAC;
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `~(closer
        (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x) y x)`)) THEN
              ASM_ARITH_TAC]);;

let FLOAT_REVERSE_NORMALIZE_LE_2 =
  prove(`!(fmt:flformat) (x:real) (y:real).
          ~(x = &0) /\ ~(&0 <= x) /\ fl_is_closest(fmt) x y ==>
          ~(&0 <= y)`,

        (* we will use MP with the float m * r^e and defn of is closest *)
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
          ["xneq0"; "xlt0"; "yisclosest"]) THEN

        SUBGOAL_THEN `&0 < &(greatest_m(fmt) x) *
                           &(flr fmt) ipow (greatest_e(fmt) x)`
        ASSUME_TAC THENL [
          ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LT_MUL THEN
          CONJ_TAC THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            REWRITE_TAC[REAL_OF_NUM_LT] THEN
            ASM_ARITH_TAC;
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]]; ALL_TAC] THEN

         USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "misfloat"
           (ONCE_REWRITE_RULE[FLOAT_NEG_IS_FLOAT]
          (MATCH_MP (SPEC `fmt:flformat` FLOAT_M_POW_E_IS_FLOAT) xneq0))) THEN

         SUBGOAL_THEN `abs (-- (&(greatest_m fmt x) *
                         &(flr fmt) ipow (greatest_e fmt x)) - x) =
             (-- x) - &(greatest_m fmt x) * &(flr fmt) ipow (greatest_e fmt x)`
          ASSUME_TAC THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
            ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC; ALL_TAC] THEN

        (* get edge case out of the way *)
        ASM_CASES_TAC `(-- (&(greatest_m fmt x) *
                              &(flr fmt) ipow (greatest_e fmt x))) = y` THENL [
          ASM_ARITH_TAC; ALL_TAC] THEN

        LABEL_TAC "mneq" (ASSUME `~((-- (&(greatest_m fmt x) *
                              &(flr fmt) ipow (greatest_e fmt x))) = y)`) THEN

          USE_THEN "yisclosest" (fun yisclosest ->
          USE_THEN "misfloat" (fun misfloat ->
          USE_THEN "mneq" (fun mneq ->
            DISJ_CASES_TAC (MATCH_MP (REWRITE_RULE[fl_is_closest] yisclosest)
             (CONJ misfloat mneq))))) THENL [

              (* y closer to x *)
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `closer y
         (-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) x`)) THEN
              ASM_ARITH_TAC;
              ASSUME_TAC
               (REWRITE_RULE[closer] (ASSUME `~(closer
      (-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) y x)`)) THEN
              ASM_ARITH_TAC]);;

let CLOSEST_LEMMA_1 =
  prove(`!(a:real) (x:real) (y:real) (z:real).
          ((closer x y a) \/ ~(closer y x a)) /\ y <= a /\ z < y ==>
          (closer x z a)`,
          REPEAT GEN_TAC THEN REWRITE_TAC[closer] THEN ARITH_TAC);;

let CLOSEST_LEMMA_2 =
  prove(`!(a:real) (x:real) (y:real) (z:real).
          ((closer x y a) \/ ~(closer y x a)) /\ (a <= y) /\ y < z ==>
          (closer x z a)`,
          REPEAT GEN_TAC THEN REWRITE_TAC[closer] THEN ARITH_TAC);;

let FLOAT_IS_CLOSEST_FIXED =
  prove(`!(fmt:flformat) (x:real) (y:real).
          ~(x = &0) /\ is_float(fmt) y /\ fl_is_closest(fmt) x y ==>
          ?(z:real). is_fixed(to_fformat fmt (greatest_e(fmt) x)) z /\
     is_closest(to_fformat fmt (greatest_e(fmt) x)) (greatest_r(fmt) x) z /\
          (if (&0 <= y)
           then
               y = &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x) +
                  z
           else
               y = -- (&(greatest_m(fmt) x) *
                      &(flr fmt) ipow (greatest_e(fmt) x)) + z) /\
          (EVEN (ff(to_fformat fmt (greatest_e(fmt) y))
               (greatest_r(fmt) y)) <=>
              EVEN (ff(to_fformat fmt (greatest_e(fmt) x)) z))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC
         ["xneq0"; "yisfloat"; "yisclosest"; "yfracexp"]) THEN

        USE_THEN "xneq0" (fun xneq0 ->
        USE_THEN "yisfloat" (fun yisfloat ->
        USE_THEN "yisclosest" (fun yisclosest ->
          LABEL_CONJUNCTS_TAC ["eqclauses"; "zexists"]
          (MATCH_MP (SPEC `fmt:flformat` FLOAT_REVERSE_NORMALIZE_FLOAT)
            (CONJ xneq0 (CONJ yisfloat yisclosest)))))) THEN

        REMOVE_THEN "zexists" (fun zexists ->
          CHOOSE_THEN (LABEL_CONJUNCTS_TAC ["zfixed"; "ynormed"]) zexists) THEN

        EXISTS_TAC `z:real` THEN ASM_REWRITE_TAC[] THEN

        (* edge case when z = 0 *)
        ASM_CASES_TAC `(z:real) = &0` THENL [

          SUBGOAL_THEN `abs(y) =
                 &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x`
          (LABEL_TAC "absyeq") THENL [
            ASM_ARITH_TAC; ALL_TAC] THEN

          SUBGOAL_THEN `~(abs y =
        &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
        finf (to_fformat fmt (greatest_e fmt x)))`
          (LABEL_TAC "absyneq") THENL [
            ASM_REWRITE_TAC[] THEN
            MATCH_MP_TAC (ARITH_RULE `~(&0 = y) ==> ~((x:real) = x + y)`) THEN
            REWRITE_TAC[finf] THEN REWRITE_TAC[FFORMAT_RADIX_IPOW_NEQ_0];
            ALL_TAC] THEN

          ASM_REWRITE_TAC[] THEN
          ONCE_REWRITE_TAC[TAUT `a /\ b <=> b /\ a`] THEN

          (* show ff = 0 *)
          REWRITE_TAC[FIXED_FF_ZERO] THEN
          REWRITE_TAC[EVEN] THEN
          SUBGOAL_THEN `(greatest_r(fmt) y) = &0`
             (fun thm -> REWRITE_TAC[thm]) THENL [
               MATCH_MP_TAC FLOAT_EQ_IPOW_R_0 THEN
               EXISTS_TAC `(greatest_e(fmt) x)` THEN
               EXISTS_TAC `(greatest_m(fmt) x)` THEN
               ASM_REWRITE_TAC[] THEN
               USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
               ASM_REWRITE_TAC[] THEN
               MATCH_MP_TAC (SPEC `fmt:flformat` FLOAT_NOT_ZERO) THEN
               ASM_REWRITE_TAC[]; ALL_TAC] THEN

          REWRITE_TAC[FIXED_FF_ZERO] THEN
          REWRITE_TAC[EVEN] THEN

          (* show 0 is closest *)
          REWRITE_TAC[is_closest] THEN GEN_TAC THEN
          DISCH_THEN (LABEL_CONJUNCTS_TAC ["sinfixed"; "sneq0"]) THEN

          (* time for a tedious case analysis ... *)
          ASM_CASES_TAC `&0 <= (x:real)` THENL [

            (* 0 <= s *)
            ASM_CASES_TAC `&0 <= (s:real)` THENL [

              REWRITE_TAC[closer] THEN

              (* construct floating point nums *)
              REWRITE_TAC[ARITH_RULE `abs((z:real) - y) =
        abs(&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + z -
            (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + y))`] THEN

              SUBGOAL_THEN `&0 <= (y:real)` (LABEL_TAC "ygeq0") THENL [
                MATCH_MP_TAC
             (SPECL [`fmt:flformat`; `x:real`] FLOAT_REVERSE_NORMALIZE_LE) THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN

             USE_THEN "xneq0" (fun xneq0 ->
                REWRITE_TAC[GSYM(REWRITE_RULE[ASSUME `&0 <= (x:real)`]
                  (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                          xneq0))]) THEN

             SUBGOAL_THEN
       `&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x = y`
             (LABEL_TAC "eqy") THENL [
               ASM_ARITH_TAC; ALL_TAC] THEN

           USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RATOR_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           REWRITE_TAC[ARITH_RULE `(x:real) + (&0 - y) = x - y`] THEN

           SUBGOAL_THEN
      `is_float(fmt)
         (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + s)`
           (LABEL_TAC "splusfloat") THENL [
             MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT THEN
             ASM_REWRITE_TAC[] THEN
             USE_THEN "sinfixed" (fun sinfixed -> REWRITE_TAC[
               REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed] sinfixed)]);
              ALL_TAC] THEN

           SUBGOAL_THEN
   `~(&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + s = y)`
           (LABEL_TAC "sneq") THENL [
             ASM_ARITH_TAC; ALL_TAC] THEN

           REWRITE_TAC[ARITH_RULE `(a:real) + (b - c) = (a + b) - c`] THEN
           REWRITE_TAC[GSYM closer] THEN
           USE_THEN "yisclosest" (fun yisclosest -> MATCH_MP_TAC
            (REWRITE_RULE[fl_is_closest] yisclosest)) THEN ASM_REWRITE_TAC[];
           ALL_TAC] THEN

         (* s < 0 *)
         DISJ1_TAC THEN MATCH_MP_TAC CLOSER_LOWER THEN
         CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
         MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN ASM_REWRITE_TAC[];
         ALL_TAC] THEN

       (* x < 0 *)
         ASM_CASES_TAC `&0 <= (s:real)` THENL [
           (* 0 <= s *)
           SUBGOAL_THEN `&0 < (s:real)` ASSUME_TAC THENL [
             ASM_ARITH_TAC; ALL_TAC] THEN
           DISJ1_TAC THEN MATCH_MP_TAC CLOSER_HIGHER THEN
           ASM_REWRITE_TAC[] THEN
           MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN ASM_REWRITE_TAC[];
           ALL_TAC] THEN

           (* s < 0 *)
            REWRITE_TAC[closer] THEN

              (* construct floating point nums *)
              REWRITE_TAC[ARITH_RULE `abs((z:real) - y) =
        abs((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + z -
     ((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + y))`] THEN

              SUBGOAL_THEN `~(&0 <= (y:real))` (LABEL_TAC "ygeq0") THENL [
                MATCH_MP_TAC
            (SPECL [`fmt:flformat`; `x:real`] FLOAT_REVERSE_NORMALIZE_LE_2) THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN

             USE_THEN "xneq0" (fun xneq0 ->
                REWRITE_TAC[GSYM(REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
                  (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                          xneq0))]) THEN

             SUBGOAL_THEN
       `(-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) = y`
             (LABEL_TAC "eqy") THENL [
               ASM_ARITH_TAC; ALL_TAC] THEN

           USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RATOR_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           REWRITE_TAC[ARITH_RULE `(x:real) + (&0 - y) = x - y`] THEN

           SUBGOAL_THEN
      `is_float(fmt)
         ((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + s)`
           (LABEL_TAC "splusfloat") THENL [
             MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT_2 THEN
             ASM_REWRITE_TAC[] THEN
             USE_THEN "sinfixed" (fun sinfixed -> REWRITE_TAC[
               REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed] sinfixed)]);
              ALL_TAC] THEN

           SUBGOAL_THEN
   `~((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + s = y)`
           (LABEL_TAC "sneq") THENL [
             ASM_ARITH_TAC; ALL_TAC] THEN

        REWRITE_TAC[ARITH_RULE `(a:real) + (b - c) = (a + b) - c`] THEN
        REWRITE_TAC[GSYM closer] THEN
        USE_THEN "yisclosest" (fun yisclosest -> MATCH_MP_TAC
        (REWRITE_RULE[fl_is_closest] yisclosest)) THEN ASM_REWRITE_TAC[];
        ALL_TAC] THEN


     (* OKAY: now we can assume z != 0, so z is just as or closer to *)
     (* to x's  remainder as zero is *)
     SUBGOAL_THEN `closer z (&0) (greatest_r(fmt) x) \/
                   ~(closer (&0) z (greatest_r(fmt) x))`
     (LABEL_TAC "zcloser0") THENL [

       REWRITE_TAC[closer] THEN
       ASM_CASES_TAC `&0 <= (x:real)` THENL [

         REWRITE_TAC[ARITH_RULE `abs((z:real) - y) =
        abs(&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + z -
        (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + y))`] THEN

         SUBGOAL_THEN `&0 <= (y:real)` (LABEL_TAC "ygeq0") THENL [
                MATCH_MP_TAC
             (SPECL [`fmt:flformat`; `x:real`] FLOAT_REVERSE_NORMALIZE_LE) THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN

         USE_THEN "xneq0" (fun xneq0 ->
                REWRITE_TAC[GSYM(REWRITE_RULE[ASSUME `&0 <= (x:real)`]
                  (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                          xneq0))]) THEN

         SUBGOAL_THEN
       `&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + z= y`
             (LABEL_TAC "eqy") THENL [
               ASM_ARITH_TAC; ALL_TAC] THEN

         REWRITE_TAC[ARITH_RULE `(a:real) + (b - y) = (a + b) - y`] THEN
         USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RATOR_CONV o
                  ONCE_DEPTH_CONV)
              [eqy]) THEN

         USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RAND_CONV o
                  ONCE_DEPTH_CONV)
              [eqy]) THEN

         SUBGOAL_THEN
      `is_float(fmt)
         (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + (&0))`
           (LABEL_TAC "splusfloat") THENL [
             MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT THEN ASM_REWRITE_TAC[] THEN
             CONJ_TAC THENL [ ARITH_TAC; ALL_TAC] THEN
             REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed]
                    FIXED_ZERO_IN_FIXED)]; ALL_TAC] THEN

           SUBGOAL_THEN
   `~(&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + (&0) = y)`
           (LABEL_TAC "sneq") THENL [
             ASM_ARITH_TAC; ALL_TAC] THEN

           REWRITE_TAC[GSYM closer] THEN
           USE_THEN "yisclosest" (fun yisclosest -> MATCH_MP_TAC
              (REWRITE_RULE[fl_is_closest] yisclosest)) THEN
           ASM_REWRITE_TAC[]; ALL_TAC] THEN

       (* x < 0 *)
       REWRITE_TAC[closer] THEN

         REWRITE_TAC[ARITH_RULE `abs((z:real) - y) =
        abs((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + z -
     ((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + y))`] THEN

        SUBGOAL_THEN `~(&0 <= (y:real))` (LABEL_TAC "ygeq0") THENL [
                MATCH_MP_TAC
            (SPECL [`fmt:flformat`; `x:real`] FLOAT_REVERSE_NORMALIZE_LE_2) THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN

        USE_THEN "xneq0" (fun xneq0 ->
                REWRITE_TAC[GSYM(REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
                  (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                          xneq0))]) THEN

        SUBGOAL_THEN
       `(-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + z = y`
             (LABEL_TAC "eqy") THENL [
               ASM_ARITH_TAC; ALL_TAC] THEN

        REWRITE_TAC[ARITH_RULE `(a:real) + (b - c) = (a + b) - c`] THEN
        USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

        USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RATOR_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           REWRITE_TAC[ARITH_RULE `(x:real) + (&0 - y) = x - y`] THEN

         REWRITE_TAC[ARITH_RULE `(x:real) + (&0) = x`] THEN
       SUBGOAL_THEN
      `is_float(fmt)
         ((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)))`
           (LABEL_TAC "splusfloat") THENL [
             REWRITE_TAC[GSYM FLOAT_NEG_IS_FLOAT] THEN
             ONCE_REWRITE_TAC[ARITH_RULE `(x:real) = x + (&0)`] THEN
             MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT THEN
             ASM_REWRITE_TAC[] THEN
             CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
             REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed]
                    FIXED_ZERO_IN_FIXED)]; ALL_TAC] THEN

           SUBGOAL_THEN
   `~((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) = y)`
           (LABEL_TAC "sneq") THENL [
             ASM_ARITH_TAC; ALL_TAC] THEN

           REWRITE_TAC[GSYM closer] THEN
           USE_THEN "yisclosest" (fun yisclosest -> MATCH_MP_TAC
            (REWRITE_RULE[fl_is_closest] yisclosest)) THEN ASM_REWRITE_TAC[];
       ALL_TAC] THEN

   (* OK: now we've shown closer z (&0) (greatest_r ... *)

   (* show z is closest *)
   CONJ_TAC THENL [
     REWRITE_TAC[is_closest] THEN GEN_TAC THEN
     DISCH_THEN (LABEL_CONJUNCTS_TAC ["sinfixed"; "sneqz"]) THEN
     REMOVE_THEN "sinfixed" (fun sinfixed -> LABEL_TAC "sfixed"
       (REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed] sinfixed))) THEN

     (* no choice but to do cases again :( ... ) *)
     ASM_CASES_TAC `&0 <= (x:real)` THENL [
       (* 0 <= x *)

       ASM_CASES_TAC `&0 <= (s:real)` THENL [
         (* 0 <= s *)

              REWRITE_TAC[closer] THEN

              (* construct floating point nums *)
              REWRITE_TAC[ARITH_RULE `abs((z:real) - y) =
        abs(&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + z -
            (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + y))`] THEN

              SUBGOAL_THEN `&0 <= (y:real)` (LABEL_TAC "ygeq0") THENL [
                MATCH_MP_TAC
             (SPECL [`fmt:flformat`; `x:real`] FLOAT_REVERSE_NORMALIZE_LE) THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN

             USE_THEN "xneq0" (fun xneq0 ->
                REWRITE_TAC[GSYM(REWRITE_RULE[ASSUME `&0 <= (x:real)`]
                  (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                          xneq0))]) THEN

          REWRITE_TAC[ARITH_RULE `(a:real) + (b - c) = (a + b) - c`] THEN

             SUBGOAL_THEN
       `&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + z= y`
             (LABEL_TAC "eqy") THENL [
               ASM_ARITH_TAC; ALL_TAC] THEN

           USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RATOR_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           SUBGOAL_THEN
      `is_float(fmt)
         (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + s)`
           (LABEL_TAC "splusfloat") THENL [
             MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT THEN
             ASM_REWRITE_TAC[]; ALL_TAC] THEN

           SUBGOAL_THEN
   `~(&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x + s = y)`
           (LABEL_TAC "sneq") THENL [
             ASM_ARITH_TAC; ALL_TAC] THEN

           REWRITE_TAC[GSYM closer] THEN
           USE_THEN "yisclosest" (fun yisclosest -> MATCH_MP_TAC
            (REWRITE_RULE[fl_is_closest] yisclosest)) THEN ASM_REWRITE_TAC[];

        ALL_TAC] THEN

      (* 0 <= x, s < 0 *)
      DISJ1_TAC THEN MATCH_MP_TAC CLOSEST_LEMMA_1 THEN
      EXISTS_TAC `(&0):real` THEN ASM_REWRITE_TAC[] THEN
      CONJ_TAC THENL [
        MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN ASM_REWRITE_TAC[];
        ASM_ARITH_TAC]; ALL_TAC] THEN

       (* x < 0 *)
       ASM_CASES_TAC `&0 <= (s:real)` THENL [
           (* 0 <= s *)

         ASM_CASES_TAC `(s:real) = &0` THENL [
           ASM_REWRITE_TAC[]; ALL_TAC] THEN

         SUBGOAL_THEN `&0 < (s:real)` ASSUME_TAC THENL [
             ASM_ARITH_TAC; ALL_TAC] THEN

         DISJ1_TAC THEN MATCH_MP_TAC CLOSEST_LEMMA_2 THEN
         EXISTS_TAC `(&0):real` THEN
         ASM_REWRITE_TAC[] THEN
         MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN ASM_REWRITE_TAC[];
         ALL_TAC] THEN

         (* s < 0 *)
         REWRITE_TAC[closer] THEN

         (* construct floating point nums *)
         REWRITE_TAC[ARITH_RULE `abs((z:real) - y) =
        abs((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + z -
     ((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + y))`] THEN

         SUBGOAL_THEN `~(&0 <= (y:real))` (LABEL_TAC "ygeq0") THENL [
                MATCH_MP_TAC
            (SPECL [`fmt:flformat`; `x:real`] FLOAT_REVERSE_NORMALIZE_LE_2) THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN

         USE_THEN "xneq0" (fun xneq0 ->
                REWRITE_TAC[GSYM(REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
                  (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                          xneq0))]) THEN

         SUBGOAL_THEN
       `(-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + z = y`
             (LABEL_TAC "eqy") THENL [
               ASM_ARITH_TAC; ALL_TAC] THEN

           REWRITE_TAC[ARITH_RULE `(a:real) + (b - c) = (a + b) - c`] THEN
           USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RAND_CONV o RAND_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           USE_THEN "eqy" (fun eqy ->
              GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RATOR_CONV o RAND_CONV o
                 ONCE_DEPTH_CONV)
              [eqy]) THEN

           SUBGOAL_THEN
      `is_float(fmt)
         ((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + s)`
           (LABEL_TAC "splusfloat") THENL [
             MATCH_MP_TAC FLOAT_PLUS_FIXED_IS_FLOAT_2 THEN
             ASM_REWRITE_TAC[]; ALL_TAC] THEN

        SUBGOAL_THEN
   `~((-- (&(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x)) + s = y)`
           (LABEL_TAC "sneq") THENL [
             ASM_ARITH_TAC; ALL_TAC] THEN

        REWRITE_TAC[GSYM closer] THEN
        USE_THEN "yisclosest" (fun yisclosest -> MATCH_MP_TAC
        (REWRITE_RULE[fl_is_closest] yisclosest)) THEN ASM_REWRITE_TAC[];
       ALL_TAC] THEN

    (* DONE SHOWING IS CLOSEST *)

    (* take care of edge case first *)
    ASM_CASES_TAC `abs y =
        &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
        finf (to_fformat fmt (greatest_e fmt x))` THENL [

      SUBGOAL_THEN `(greatest_r(fmt) y) = &0`
      (fun thm -> REWRITE_TAC[thm]) THENL [

        ASM_CASES_TAC `(greatest_m(fmt) x) = (flr fmt) - 1` THENL [
          MATCH_MP_TAC FLOAT_EQ_IPOW_R_0 THEN
          EXISTS_TAC `(greatest_e(fmt) x) + &1` THEN
          EXISTS_TAC `1` THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC (SPEC `fmt:flformat` FLOAT_NOT_ZERO) THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN
          CONJ_TAC THENL [ ARITH_TAC; ALL_TAC] THEN
          CONJ_TAC THENL [ REWRITE_TAC[FLFORMAT_RADIX_LT_1]; ALL_TAC ] THEN

          REWRITE_TAC[GSYM(MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0))] THEN
          REWRITE_TAC[IPOW_TO_1] THEN
          REWRITE_TAC[ARITH_RULE `(&1) * (x:real) * y = y * x`] THEN
          ONCE_REWRITE_TAC[ARITH_RULE `(x:real) * y = (x - &1) * y + y`] THEN

          SUBGOAL_THEN `(&(flr fmt) - &1) = &((flr fmt) - 1)`
          (fun thm -> REWRITE_TAC[thm]) THENL [
            MATCH_MP_TAC REAL_OF_NUM_SUB THEN
            MATCH_MP_TAC (ARITH_RULE `1 < n ==> 1 <= n`) THEN
            REWRITE_TAC[FLFORMAT_RADIX_LT_1]; ALL_TAC] THEN

          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[finf] THEN dump_flformat_conv `(greatest_e(fmt) x)` THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN

          (* m != r - 1 *)
          MATCH_MP_TAC FLOAT_EQ_IPOW_R_0 THEN
          EXISTS_TAC `(greatest_e(fmt) x)` THEN
          EXISTS_TAC `(greatest_m(fmt) x) + 1` THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC (SPEC `fmt:flformat` FLOAT_NOT_ZERO) THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN
          CONJ_TAC THENL [ ARITH_TAC; ALL_TAC] THEN

          USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
          CONJ_TAC THENL [
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[ARITH_RULE
                 `m + 1 < (flr fmt) <=> m < (flr fmt) - 1`] THEN
            MATCH_MP_TAC (ARITH_RULE
               `(x:num) < y /\ ~(x = y - 1) ==> x < y - 1`) THEN
            CONJ_TAC THENL [ ASM_REWRITE_TAC[]; ALL_TAC] THEN
            USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[GSYM xgmeq]) THEN
            REWRITE_TAC[ASSUME `~(greatest_m fmt x = flr fmt - 1)`];
            ALL_TAC] THEN

          REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
          REWRITE_TAC[ARITH_RULE `((x:real) + &1) * z = x * z + z`] THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[finf] THEN
          dump_flformat_conv `(greatest_e(fmt) x)` THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN

      (* (abs(y) = mr^e + finf) done showing fraction is zero *)

      REWRITE_TAC[FIXED_FF_ZERO] THEN REWRITE_TAC[EVEN] THEN

      ASM_CASES_TAC `&0 <= (y:real)` THENL [
        SUBGOAL_THEN `z = (finf (to_fformat fmt (greatest_e fmt x)))`
        (fun thm -> REWRITE_TAC[thm]) THENL [
          ASM_ARITH_TAC; ALL_TAC] THEN

        REWRITE_TAC[FIXED_FF_FINF] THEN
        REWRITE_TAC[EVEN_EXP] THEN
        REWRITE_TAC[FFORMAT_RADIX_EVEN] THEN
        MATCH_MP_TAC (ARITH_RULE `1 < x ==> ~(x - 1 = 0)`) THEN
        dump_flformat_conv `(greatest_e(fmt) x)` THEN
        ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[FLFORMAT_PREC_LT_1];

        (* y < 0 *)
        SUBGOAL_THEN `z = -- (finf (to_fformat fmt (greatest_e fmt x)))`
        (fun thm -> REWRITE_TAC[thm]) THENL [
          ASM_ARITH_TAC; ALL_TAC] THEN

        SUBGOAL_THEN ` (ff (to_fformat fmt (greatest_e fmt x))
                     (--finf (to_fformat fmt (greatest_e fmt x)))) =
                 (ff (to_fformat fmt (greatest_e fmt x))
                      (finf (to_fformat fmt (greatest_e fmt x))))`
         (fun thm -> REWRITE_TAC[thm]) THENL [
           MATCH_MP_TAC FIXED_FF_NEG THEN
           REWRITE_TAC[REWRITE_RULE[IN_ELIM_THM] (REWRITE_RULE[fixed]
            FIXED_FINF_IN_FIXED)]; ALL_TAC] THEN

        REWRITE_TAC[FIXED_FF_FINF] THEN
        REWRITE_TAC[EVEN_EXP] THEN
        REWRITE_TAC[FFORMAT_RADIX_EVEN] THEN
        MATCH_MP_TAC (ARITH_RULE `1 < x ==> ~(x - 1 = 0)`) THEN
        dump_flformat_conv `(greatest_e(fmt) x)` THEN
        ASM_REWRITE_TAC[] THEN
        REWRITE_TAC[FLFORMAT_PREC_LT_1]]; ALL_TAC] THEN

   (* done with fraction edge case ! *)

   USE_THEN "eqclauses" (fun eqclauses ->
        LABEL_CONJUNCTS_TAC ["ygmeq"; "ygeeq"]
        (MATCH_MP eqclauses (ASSUME `~(abs y =
        &(greatest_m fmt x) * &(flr fmt) ipow greatest_e fmt x +
        finf (to_fformat fmt (greatest_e fmt x)))`))) THEN

   ASM_REWRITE_TAC[] THEN

   SUBGOAL_THEN `(greatest_r(fmt) y) = z` (fun thm -> REWRITE_TAC[thm]) THENL [
     REWRITE_TAC[greatest_r] THEN
     COND_CASES_TAC THENL [
       REWRITE_TAC[ARITH_RULE `(y:real) - x = z <=> y = x + z`] THEN
       ASM_REWRITE_TAC[] THEN
       ASM_ARITH_TAC;
       REWRITE_TAC[ARITH_RULE `(y:real) + x = z <=> y = (-- x) + z`] THEN
       REWRITE_TAC[ARITH_RULE `(-- x:real) * y = -- (x * y)`] THEN
       ASM_REWRITE_TAC[] THEN
       ASM_ARITH_TAC]]);;

(* A floating point number's normalized frac is m * r^(p - 1) + the fraction  *)
(* of its fixed point remainder.                                              *)
let fl_norm_frac = define
  `fl_norm_frac (fmt:flformat) (y:real) =
  ( (greatest_m(fmt) y) * (flr fmt) EXP ((flp fmt) - 1) +
    (ff (to_fformat fmt (greatest_e(fmt) y)) (greatest_r(fmt) y)) )`;;

let fl_to_even = define
  `fl_to_even (fmt:flformat) (x:real) (y:real) = (!(y2:real).
   is_float(fmt) y2 /\
   (fl_is_closest(fmt) x y) /\
   (fl_is_closest(fmt) x y2) /\
   ~(y2 = y) ==>
   (EVEN (fl_norm_frac(fmt) y)))`;;

let FLOAT_RD_NEAREST_EVEN =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          fl_to_even(fmt) x (flround(fmt) To_near x)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
          REWRITE_TAC[fl_to_even] THEN GEN_TAC THEN
          DISCH_THEN (LABEL_CONJUNCTS_TAC
           ["y2float"; "roundclose"; "y2close"; "y2neq"]) THEN

          SUBGOAL_THEN `is_float(fmt) (flround(fmt) To_near x)`
          (LABEL_TAC "roundfloat") THENL [
            MATCH_MP_TAC FLOAT_RD_IS_FLOAT THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN

          USE_THEN "xneq0" (fun xneq0 ->
          USE_THEN "y2float" (fun y2float ->
          USE_THEN "y2close" (fun y2close ->
            CHOOSE_THEN
            (LABEL_CONJUNCTS_TAC ["zpfixed"; "zpeq"; "zpclose"; "zpfrac"])
            (MATCH_MP (SPEC `fmt:flformat` FLOAT_IS_CLOSEST_FIXED)
              (CONJ xneq0 (CONJ y2float y2close)))))) THEN

          USE_THEN "xneq0" (fun xneq0 ->
          USE_THEN "roundfloat" (fun roundfloat ->
          USE_THEN "roundclose" (fun roundclose ->
            CHOOSE_THEN
            (LABEL_CONJUNCTS_TAC ["zfixed"; "zeq"; "zclose"; "zfrac"])
            (MATCH_MP (SPEC `fmt:flformat` FLOAT_IS_CLOSEST_FIXED)
              (CONJ xneq0 (CONJ roundfloat roundclose)))))) THEN

          SUBGOAL_THEN
 `fround (to_fformat fmt (greatest_e(fmt) x)) To_near (greatest_r(fmt) x) = z'`
          (LABEL_TAC "eqzp") THENL [
            ASM_CASES_TAC `&0 <= (x:real)` THENL [
              ONCE_REWRITE_TAC[ARITH_RULE `(x:real) = y <=>
  &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x) +
       x = &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x) + y`] THEN
                SUBGOAL_THEN `&0 <= (flround(fmt) To_near x)` ASSUME_TAC THENL [
                  MATCH_MP_TAC FLOAT_REVERSE_NORMALIZE_LE THEN
                  EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
                  ASM_REWRITE_TAC[]; ALL_TAC] THEN

                SUBGOAL_THEN
   `&(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x) +
    fround (to_fformat fmt (greatest_e(fmt) x)) To_near (greatest_r(fmt) x) =
            (flround(fmt) To_near x)`
                ASSUME_TAC THENL [
                  REWRITE_TAC[flround] THEN LET_TAC THEN ASM_REWRITE_TAC[];
                  ALL_TAC] THEN

                ASM_REWRITE_TAC[] THEN
                ASM_ARITH_TAC;

              (* x < 0 *)
              ONCE_REWRITE_TAC[ARITH_RULE `(x:real) = y <=>
   (-- (&(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x))) + x =
 (-- (&(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x))) + y`] THEN
                SUBGOAL_THEN `~(&0 <= (flround(fmt) To_near x))`
                ASSUME_TAC THENL [
                  MATCH_MP_TAC FLOAT_REVERSE_NORMALIZE_LE_2 THEN
                  EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
                  ASM_REWRITE_TAC[]; ALL_TAC] THEN

                SUBGOAL_THEN
    `(-- (&(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x))) +
 fround (to_fformat fmt (greatest_e(fmt) x)) To_near (greatest_r(fmt) x) =
       (flround(fmt) To_near x)`
                ASSUME_TAC THENL [
                  REWRITE_TAC[flround] THEN LET_TAC THEN ASM_REWRITE_TAC[];
                  ALL_TAC] THEN

                ASM_REWRITE_TAC[] THEN
                ASM_ARITH_TAC]; ALL_TAC ] THEN

          (* showed z' = fround *)

          REWRITE_TAC[fl_norm_frac] THEN REWRITE_TAC[EVEN_ADD] THEN
          REWRITE_TAC[EVEN_MULT] THEN REWRITE_TAC[EVEN_EXP] THEN
          REWRITE_TAC[FLFORMAT_RADIX_EVEN] THEN
          REWRITE_TAC[ARITH_RULE `~(x - 1 = 0) <=> 1 < x`] THEN
          REWRITE_TAC[FLFORMAT_PREC_LT_1] THEN
          ASM_REWRITE_TAC[] THEN

          SUBGOAL_THEN `abs(greatest_r(fmt) x) <=
                    (finf (to_fformat fmt (greatest_e(fmt) x)))`
          (LABEL_TAC "grbnd") THENL [
            MATCH_MP_TAC (ARITH_RULE `(x:real) < y ==> x <= y`) THEN
            USE_THEN "xneq0" (fun xneq0 ->
              CHOOSE_THEN (fun thm -> REWRITE_TAC[thm])
              (MATCH_MP (SPEC `fmt:flformat` FLOAT_GREATEST_R_EXISTS)
                   xneq0)); ALL_TAC] THEN

          USE_THEN "grbnd" (fun grbnd ->
           CHOOSE_THEN
           (LABEL_CONJUNCTS_TAC ["froundeq"; "frisfixed"; "frtoeven"])
           (MATCH_MP (SPEC `(to_fformat fmt (greatest_e(fmt) x))`
                        FIXED_RD_NEAREST_EVEN)
              grbnd)) THEN

          SUBGOAL_THEN `z IN (fixed (to_fformat fmt (greatest_e(fmt) x)))`
          (LABEL_TAC "zpinfixed") THENL [
            REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN

          SUBGOAL_THEN `~((z:real) = z')` (LABEL_TAC "zneq") THENL [
            ASM_CASES_TAC `&0 <= (x:real)` THENL [
              SUBGOAL_THEN `&0 <= (flround(fmt) To_near x)` ASSUME_TAC THENL [
                MATCH_MP_TAC FLOAT_REVERSE_NORMALIZE_LE THEN
                EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN
              SUBGOAL_THEN `&0 <= (y2:real)` ASSUME_TAC THENL [
                MATCH_MP_TAC FLOAT_REVERSE_NORMALIZE_LE THEN
                EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN
              ASM_ARITH_TAC;

            SUBGOAL_THEN `~(&0 <= (flround(fmt) To_near x))` ASSUME_TAC THENL [
                MATCH_MP_TAC FLOAT_REVERSE_NORMALIZE_LE_2 THEN
                EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN
              SUBGOAL_THEN `~(&0 <= (y2:real))` ASSUME_TAC THENL [
                MATCH_MP_TAC FLOAT_REVERSE_NORMALIZE_LE_2 THEN
                EXISTS_TAC `fmt:flformat` THEN EXISTS_TAC `x:real` THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN
              ASM_ARITH_TAC]; ALL_TAC] THEN

        SUBGOAL_THEN `is_frac (to_fformat fmt (greatest_e(fmt) x))
                       z'
                      (ff (to_fformat fmt (greatest_e(fmt) x)) z')`
         (LABEL_TAC "zfrac") THENL [
           REWRITE_TAC[ff] THEN SELECT_ELIM_TAC THEN
           REWRITE_TAC[GSYM is_fixed] THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN

       SUBGOAL_THEN `to_even (to_fformat fmt (greatest_e fmt x))
              (greatest_r fmt x) z'`
       (LABEL_TAC "frtoeven2") THENL [
         USE_THEN "eqzp" (fun eqzp -> REWRITE_TAC[GSYM eqzp]) THEN
         USE_THEN "froundeq" (fun froundeq -> REWRITE_TAC[froundeq]) THEN
         ASM_REWRITE_TAC[]; ALL_TAC] THEN

       (* OK! now we're ready ... *)

       USE_THEN "frtoeven2" (fun frtoeven2 ->
         MATCH_MP_TAC (REWRITE_RULE[to_even] frtoeven2)) THEN
       EXISTS_TAC `z:real` THEN ASM_REWRITE_TAC[]);;

(* -------------------------------------------------------------------------- *)
(* Round to zero                                                              *)
(* -------------------------------------------------------------------------- *)

let fl_to_zero = define
  `fl_to_zero (fmt:flformat) (x:real) (y:real) =
  (if (&0 <= x)
   then
     (&0 <= y) /\ (y <= x) /\
       !(y':real). is_float(fmt) y' /\ y' <= x ==> y' <= y
   else
     (y <= &0) /\ (x <= y) /\
       !(y':real). is_float(fmt) y' /\ x <= y' ==> y <= y')`;;

let FLOAT_RD_ZERO_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          fl_to_zero(fmt) x (flround (fmt) To_zero x)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[fl_to_zero] THEN

        COND_CASES_TAC THENL [
          (* 0 <= x *)
          CONJ_TAC THENL [
            (* show round is non-negative *)
            REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN
            MATCH_MP_TAC REAL_LE_ADD THEN
            CONJ_TAC THENL [

              MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
              CONJ_TAC THENL [ ARITH_TAC; ALL_TAC] THEN
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];

              MATCH_MP_TAC FIXED_RD_LE_0 THEN
              CONJ_TAC THENL [

                USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                EXPAND_TAC "y" THEN
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                EXPAND_TAC "e" THEN ASM_ARITH_TAC;

                EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN
                ASM_REWRITE_TAC[]]];

            ALL_TAC] THEN

          (* show to zero is below x *)
          CONJ_TAC THENL [
            REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN
            USE_THEN "xneq0" (fun xneq0 -> ONCE_REWRITE_TAC[
              REWRITE_RULE[ASSUME `&0 <= (x:real)`]
              (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                        xneq0)]) THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[REAL_LE_LADD] THEN

            SUBGOAL_THEN `abs(y) <= (finf (to_fformat fmt e))`
             (LABEL_TAC "yleqfinf") THENL [
               USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
               EXPAND_TAC "y" THEN EXPAND_TAC "e" THEN
               USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
               ASM_ARITH_TAC; ALL_TAC] THEN

            USE_THEN "yleqfinf" (fun yleqfinf ->
              CHOOSE_THEN
              (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "tozero"])
              (MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_RD_ZERO_EXISTS)
                        yleqfinf)) THEN
            ASM_REWRITE_TAC[] THEN

            SUBGOAL_THEN `&0 <= (y:real)` (LABEL_TAC "ygeq0") THENL [
              EXPAND_TAC "y" THEN
              MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN ASM_REWRITE_TAC[];
              ALL_TAC] THEN

            USE_THEN "tozero" (fun tozero -> USE_THEN "ygeq0" (fun ygeq0 ->
              REWRITE_TAC[REWRITE_RULE[ygeq0] (REWRITE_RULE[to_zero] tozero)]));
            ALL_TAC] THEN

            (* show no other float below x is closer *)
            GEN_TAC THEN
            DISCH_THEN (LABEL_CONJUNCTS_TAC ["ypfloat"; "ypleqx"]) THEN

            ASM_CASES_TAC `y' <
             &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x)` THENL [
               (* case 1 of 2: y' < m * r^e *)
               REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN
               MATCH_MP_TAC
                (ARITH_RULE `(x:real) < y /\ &0 <= z ==> x <= y + z`) THEN
               ASM_REWRITE_TAC[] THEN
               MATCH_MP_TAC FIXED_RD_LE_0 THEN
               CONJ_TAC THENL [

                 USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                 EXPAND_TAC "y" THEN EXPAND_TAC "e" THEN
                 USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                 ASM_ARITH_TAC;

                 EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN
                 ASM_REWRITE_TAC[]];

               (* case 2 of 2: y >= m * r^e *)
               REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN

               (* prepare to reverse normalize ... *)
               SUBGOAL_THEN `&m * &(flr fmt) ipow e <= abs(y')`
                (LABEL_TAC "absypgeq") THENL [
                  ASM_ARITH_TAC; ALL_TAC] THEN

               SUBGOAL_THEN `&0 <= &m * &(flr fmt) ipow e` ASSUME_TAC THENL [
                 MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
                 CONJ_TAC THENL [ ARITH_TAC; ALL_TAC] THEN
                 REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]; ALL_TAC] THEN

               SUBGOAL_THEN
     `abs(y') < &m * &(flr fmt) ipow e + (finf (to_fformat fmt e))`
               (LABEL_TAC "absyplt") THENL [
                 MATCH_MP_TAC REAL_LET_TRANS THEN
                 EXISTS_TAC `abs(x)` THEN
                 CONJ_TAC THENL [ ASM_ARITH_TAC; ALL_TAC] THEN

                 SUBGOAL_THEN `abs(x) = x` (fun thm -> REWRITE_TAC[thm]) THENL [
                   ASM_ARITH_TAC; ALL_TAC] THEN

                 USE_THEN "xneq0" (fun xneq0 -> ONCE_REWRITE_TAC[
                   REWRITE_RULE[ASSUME `&0 <= (x:real)`]
                   (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
                 ASM_REWRITE_TAC[] THEN
                 REWRITE_TAC[REAL_LT_LADD] THEN
                 USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                 EXPAND_TAC "y" THEN EXPAND_TAC "e" THEN
                 USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN

                 SUBGOAL_THEN `y'' = abs(y'')`
                  (fun thm -> ONCE_REWRITE_TAC[thm]) THENL [
                    SUBGOAL_THEN `&0 <= (y'':real)` ASSUME_TAC THENL [
                      EXPAND_TAC "y''" THEN
                      MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN
                      ASM_REWRITE_TAC[]; ALL_TAC] THEN
                    ASM_ARITH_TAC; ALL_TAC] THEN

                  USE_THEN "xgrleq" (fun xgrleq -> REWRITE_TAC[xgrleq]);
                 ALL_TAC] THEN

                 (* now ready for reverse norm *)
                 SUBGOAL_THEN `(greatest_e(fmt) y') = e /\
                               (greatest_m(fmt) y') = m`
                  (LABEL_CONJUNCTS_TAC ["ype"; "ypm"]) THENL [
                    MATCH_MP_TAC FLOAT_BETWEEN THEN
                    USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                    EXPAND_TAC "m" THEN
                    USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
                    ASM_REWRITE_TAC[] THEN
                    EXPAND_TAC "m'" THEN ASM_REWRITE_TAC[] THEN
                    MATCH_MP_TAC
                      (ARITH_RULE `!z. &0 < z /\ z <= y ==> ~(y = &0)`) THEN
                    EXISTS_TAC `&m * &(flr fmt) ipow e` THEN
                    CONJ_TAC THENL [

                      MATCH_MP_TAC REAL_LT_MUL THEN
                      REWRITE_TAC[REAL_OF_NUM_LT] THEN EXPAND_TAC "m" THEN
                      USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
                      CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
                      REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0];

                      ASM_ARITH_TAC]; ALL_TAC] THEN

                SUBGOAL_THEN `&0 <= (y':real)` (LABEL_TAC "ypgeq0") THENL [
                  ASM_ARITH_TAC; ALL_TAC] THEN

                USE_THEN "ypfloat" (fun ypfloat ->
                USE_THEN "ypgeq0" (fun ypgeq0 ->
                  LABEL_CONJUNCTS_TAC ["remfloat"; "ypnorm"]
                      (REWRITE_RULE[ypgeq0]
                              (MATCH_MP FLOAT_NORMALIZE_FLOAT ypfloat)))) THEN
                ONCE_ASM_REWRITE_TAC[] THEN
                USE_THEN "ype" (fun ype -> REWRITE_TAC[ype]) THEN
                USE_THEN "ypm" (fun ypm -> REWRITE_TAC[ypm]) THEN
                REWRITE_TAC[REAL_LE_LADD] THEN

                SUBGOAL_THEN `greatest_r(fmt) y' <= y`
                 (LABEL_TAC "grypleqy") THENL [
                   ONCE_REWRITE_TAC[GSYM
                     (SPEC `&m * &(flr fmt) ipow e` REAL_LE_LADD)] THEN
                   USE_THEN "ypm" (fun ypm ->
                     GEN_REWRITE_TAC (RATOR_CONV o ONCE_DEPTH_CONV)
                     [GSYM ypm]) THEN
                   USE_THEN "ype" (fun ype ->
                     GEN_REWRITE_TAC (RATOR_CONV o ONCE_DEPTH_CONV)
                     [GSYM ype]) THEN
                   USE_THEN "ypnorm" (fun ypnorm ->
                              ONCE_REWRITE_TAC[GSYM ypnorm]) THEN
                   USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "xnormed"
                    (REWRITE_RULE[ASSUME `&0 <= (x:real)`]
                       (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                                 xneq0))) THEN
                   REWRITE_TAC[GSYM (ASSUME `greatest_m(fmt) x = m`)] THEN
                   REWRITE_TAC[GSYM (ASSUME `greatest_e(fmt) x = e`)] THEN
                   REWRITE_TAC[GSYM (ASSUME `greatest_r(fmt) x = y`)] THEN
                   USE_THEN "xnormed" (fun xnormed ->
                             REWRITE_TAC[GSYM xnormed]) THEN
                   ASM_REWRITE_TAC[]; ALL_TAC] THEN

                 SUBGOAL_THEN `abs(y) <= (finf (to_fformat fmt e))`
                 (LABEL_TAC "absyleq") THENL [
                   USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                   EXPAND_TAC "y" THEN
                   REWRITE_TAC[GSYM (ASSUME `greatest_e(fmt) x = e`)] THEN
                   ASM_ARITH_TAC; ALL_TAC] THEN

                 USE_THEN "absyleq" (fun absyleq ->
                   CHOOSE_THEN
                   (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frtozero"])
                   (MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_RD_ZERO_EXISTS)
                         absyleq)) THEN

                 SUBGOAL_THEN `&0 <= (y:real)` (LABEL_TAC "ygeq0") THENL [
                   EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN
                   ASM_REWRITE_TAC[]; ALL_TAC] THEN

                 USE_THEN "frtozero" (fun frtozero ->
                 USE_THEN "ygeq0" (fun ygeq0 ->
                   LABEL_CONJUNCTS_TAC ["frgeq0"; "frleqx"; "frclose"]
                   (REWRITE_RULE[ygeq0]
                    (REWRITE_RULE[to_zero] frtozero)))) THEN
                 ASM_REWRITE_TAC[] THEN
                 USE_THEN "frclose" (fun frclose -> MATCH_MP_TAC frclose) THEN
                 REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
                 ASM_REWRITE_TAC[] THEN EXPAND_TAC "e" THEN
                 ASM_REWRITE_TAC[]]; ALL_TAC] THEN

  (* x < 0 ---------------------------------------- *)

          CONJ_TAC THENL [
            (* show round is non-positive *)
            REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN
            REWRITE_TAC[ARITH_RULE
                 `-- (z:real) + y <= &0 <=> &0 <= z + (-- y)`] THEN
            MATCH_MP_TAC REAL_LE_ADD THEN
            CONJ_TAC THENL [

              MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
              CONJ_TAC THENL [ ARITH_TAC; ALL_TAC] THEN
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];

              REWRITE_TAC[ARITH_RULE `&0 <= (-- x) <=> x <= &0`] THEN
              MATCH_MP_TAC FIXED_RD_LE_0_2 THEN
              CONJ_TAC THENL [

                USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                EXPAND_TAC "y" THEN
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                EXPAND_TAC "e" THEN ASM_ARITH_TAC;

                EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
                ASM_REWRITE_TAC[]]];

            ALL_TAC] THEN

          (* show to-zero is above x *)
          CONJ_TAC THENL [
            REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN
            USE_THEN "xneq0" (fun xneq0 -> ONCE_REWRITE_TAC[
              REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
              (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                        xneq0)]) THEN
            ASM_REWRITE_TAC[] THEN
            REWRITE_TAC[REAL_LE_LADD] THEN

            SUBGOAL_THEN `abs(y) <= (finf (to_fformat fmt e))`
             (LABEL_TAC "yleqfinf") THENL [
               USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
               EXPAND_TAC "y" THEN EXPAND_TAC "e" THEN
               USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
               ASM_ARITH_TAC; ALL_TAC] THEN

            USE_THEN "yleqfinf" (fun yleqfinf ->
              CHOOSE_THEN
              (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "tozero"])
              (MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_RD_ZERO_EXISTS)
                        yleqfinf)) THEN
            ASM_REWRITE_TAC[] THEN

            SUBGOAL_THEN `(y:real) <= &0` (LABEL_TAC "ygeq0") THENL [
              EXPAND_TAC "y" THEN
              MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN ASM_REWRITE_TAC[];
              ALL_TAC] THEN

            SUBGOAL_THEN `(y':real) <= &0` (LABEL_TAC "ypleq0") THENL [
              EXPAND_TAC "y'" THEN
              MATCH_MP_TAC FIXED_RD_LE_0_2 THEN
              CONJ_TAC THENL [

                USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                EXPAND_TAC "y" THEN
                USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                EXPAND_TAC "e" THEN ASM_ARITH_TAC;

                EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
                ASM_REWRITE_TAC[]]; ALL_TAC] THEN

            ASM_CASES_TAC `~(&0 <= (y:real))` THENL [

              USE_THEN "tozero" (fun tozero ->
              REWRITE_TAC[REWRITE_RULE[ASSUME `~(&0 <= (y:real))`]
                      (REWRITE_RULE[to_zero] tozero)]);

              SUBGOAL_THEN `&0 <= (y:real)` (LABEL_TAC "ygeq0") THENL [
                ASM_ARITH_TAC; ALL_TAC] THEN

              USE_THEN "tozero" (fun tozero -> USE_THEN "ygeq0" (fun ygeq0 ->
                ASSUME_TAC (REWRITE_RULE[ygeq0]
                              (REWRITE_RULE[to_zero] tozero)))) THEN

              ASM_ARITH_TAC]; ALL_TAC] THEN

            (* show no other float above x is closer *)
            GEN_TAC THEN
            DISCH_THEN (LABEL_CONJUNCTS_TAC ["ypfloat"; "ypgeqx"]) THEN

            ASM_CASES_TAC
  `-- (&(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x)) < y'` THENL [
               (* case 1 of 2: - m * r^e < y' *)
               REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN
               REWRITE_TAC[
            ARITH_RULE `(-- (z:real)) + y <= y' <=> (-- y') <= z + (-- y)`] THEN
               MATCH_MP_TAC
                (ARITH_RULE `(x:real) < y /\ &0 <= z ==> x <= y + z`) THEN
               CONJ_TAC THENL [ ASM_ARITH_TAC; ALL_TAC] THEN
               REWRITE_TAC[ARITH_RULE `&0 <= (-- (x:real)) <=> x <= &0`] THEN
               MATCH_MP_TAC FIXED_RD_LE_0_2 THEN
               CONJ_TAC THENL [

                 USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                 EXPAND_TAC "y" THEN EXPAND_TAC "e" THEN
                 USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
                 ASM_ARITH_TAC;

                 EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
                 ASM_REWRITE_TAC[]];

               (* case 2 of 2: y <= - m * r^e *)
               REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN

               (* prepare to reverse normalize ... *)
               SUBGOAL_THEN `&m * &(flr fmt) ipow e <= abs(y')`
                (LABEL_TAC "absypgeq") THENL [
                  ASM_ARITH_TAC; ALL_TAC] THEN

               SUBGOAL_THEN `&0 <= &m * &(flr fmt) ipow e` ASSUME_TAC THENL [
                 MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
                 CONJ_TAC THENL [ ARITH_TAC; ALL_TAC] THEN
                 REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]; ALL_TAC] THEN

               SUBGOAL_THEN
     `abs(y') < &m * &(flr fmt) ipow e + (finf (to_fformat fmt e))`
               (LABEL_TAC "absyplt") THENL [
                 MATCH_MP_TAC REAL_LET_TRANS THEN
                 EXISTS_TAC `abs(x)` THEN
                 CONJ_TAC THENL [ ASM_ARITH_TAC; ALL_TAC] THEN

              SUBGOAL_THEN `abs(x) = -- x` (fun thm -> REWRITE_TAC[thm]) THENL [
                   ASM_ARITH_TAC; ALL_TAC] THEN

                 USE_THEN "xneq0" (fun xneq0 -> ONCE_REWRITE_TAC[
                   REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
                   (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
                 ASM_REWRITE_TAC[] THEN
                 REWRITE_TAC[
                   ARITH_RULE `-- ((-- (z:real)) + y) = z + (-- y)`] THEN
                 REWRITE_TAC[REAL_LT_LADD] THEN
                 USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                 EXPAND_TAC "y" THEN EXPAND_TAC "e" THEN
                 USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN

                 SUBGOAL_THEN `(-- y'') = abs(y'')`
                  (fun thm -> ONCE_REWRITE_TAC[thm]) THENL [
                    SUBGOAL_THEN `(y'':real) <= &0` ASSUME_TAC THENL [
                      EXPAND_TAC "y''" THEN
                      MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
                      ASM_REWRITE_TAC[]; ALL_TAC] THEN
                    ASM_ARITH_TAC; ALL_TAC] THEN

                  USE_THEN "xgrleq" (fun xgrleq -> REWRITE_TAC[xgrleq]);
                 ALL_TAC] THEN

                 (* now ready for reverse norm *)
                 SUBGOAL_THEN `(greatest_e(fmt) y') = e /\
                               (greatest_m(fmt) y') = m`
                  (LABEL_CONJUNCTS_TAC ["ype"; "ypm"]) THENL [
                    MATCH_MP_TAC FLOAT_BETWEEN THEN
                    USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                    EXPAND_TAC "m" THEN
                    USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
                    ASM_REWRITE_TAC[] THEN
                    EXPAND_TAC "m'" THEN ASM_REWRITE_TAC[] THEN
                    MATCH_MP_TAC
                    (ARITH_RULE `!z. &0 < z /\ y <= (-- z) ==> ~(y = &0)`) THEN
                    EXISTS_TAC `&m * &(flr fmt) ipow e` THEN
                    CONJ_TAC THENL [

                      MATCH_MP_TAC REAL_LT_MUL THEN
                      REWRITE_TAC[REAL_OF_NUM_LT] THEN EXPAND_TAC "m" THEN
                      USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
                      CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
                      REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0];

                      ASM_ARITH_TAC]; ALL_TAC] THEN

                SUBGOAL_THEN `&0 < &m * &(flr fmt) ipow e` ASSUME_TAC THENL [
                 MATCH_MP_TAC REAL_LT_MUL THEN REWRITE_TAC[REAL_OF_NUM_LT] THEN
                 USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
                 REWRITE_TAC[GSYM (ASSUME `greatest_m(fmt) x = m`)] THEN
                 USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
                 CONJ_TAC THENL [ ASM_ARITH_TAC; ALL_TAC] THEN
                 REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]; ALL_TAC] THEN

                SUBGOAL_THEN `~(&0 <= (y':real))` (LABEL_TAC "yplt0") THENL [
                  ASM_ARITH_TAC; ALL_TAC] THEN

                USE_THEN "ypfloat" (fun ypfloat ->
                USE_THEN "yplt0" (fun yplt0 ->
                  LABEL_CONJUNCTS_TAC ["remfloat"; "ypnorm"]
                      (REWRITE_RULE[yplt0]
                              (MATCH_MP FLOAT_NORMALIZE_FLOAT ypfloat)))) THEN
                ONCE_ASM_REWRITE_TAC[] THEN
                USE_THEN "ype" (fun ype -> REWRITE_TAC[ype]) THEN
                USE_THEN "ypm" (fun ypm -> REWRITE_TAC[ypm]) THEN
                REWRITE_TAC[REAL_LE_LADD] THEN

                SUBGOAL_THEN `y <= greatest_r(fmt) y'`
                 (LABEL_TAC "yleqgryp") THENL [
                   ONCE_REWRITE_TAC[GSYM
                     (SPEC `-- (&m * &(flr fmt) ipow e)` REAL_LE_LADD)] THEN
                   USE_THEN "ypm" (fun ypm ->
                     GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
                     [GSYM ypm]) THEN
                   USE_THEN "ype" (fun ype ->
                     GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
                     [GSYM ype]) THEN
                   USE_THEN "ypnorm" (fun ypnorm ->
                              ONCE_REWRITE_TAC[GSYM ypnorm]) THEN
                   USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "xnormed"
                    (REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
                       (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                                 xneq0))) THEN
                   REWRITE_TAC[GSYM (ASSUME `greatest_m(fmt) x = m`)] THEN
                   REWRITE_TAC[GSYM (ASSUME `greatest_e(fmt) x = e`)] THEN
                   REWRITE_TAC[GSYM (ASSUME `greatest_r(fmt) x = y`)] THEN
                   USE_THEN "xnormed" (fun xnormed ->
                             REWRITE_TAC[GSYM xnormed]) THEN
                   ASM_REWRITE_TAC[]; ALL_TAC] THEN

                 SUBGOAL_THEN `abs(y) <= (finf (to_fformat fmt e))`
                 (LABEL_TAC "absyleq") THENL [
                   USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
                   EXPAND_TAC "y" THEN
                   REWRITE_TAC[GSYM (ASSUME `greatest_e(fmt) x = e`)] THEN
                   ASM_ARITH_TAC; ALL_TAC] THEN

                 USE_THEN "absyleq" (fun absyleq ->
                   CHOOSE_THEN
                   (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frtozero"])
                   (MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_RD_ZERO_EXISTS)
                         absyleq)) THEN

                 SUBGOAL_THEN `(y:real) <= &0` (LABEL_TAC "yleq0") THENL [
                   EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
                   ASM_REWRITE_TAC[]; ALL_TAC] THEN

                 ASM_CASES_TAC `~(&0 <= (y:real))` THENL [

                   (* interesting case ... *)

                   USE_THEN "frtozero" (fun frtozero ->
                     LABEL_CONJUNCTS_TAC ["frgeq0"; "frleqx"; "frclose"]
                     (REWRITE_RULE[ASSUME `~(&0 <= (y:real))`]
                      (REWRITE_RULE[to_zero] frtozero))) THEN
                   ASM_REWRITE_TAC[] THEN
                   USE_THEN "frclose" (fun frclose -> MATCH_MP_TAC frclose) THEN
                   REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
                   ASM_REWRITE_TAC[] THEN EXPAND_TAC "e" THEN
                   ASM_REWRITE_TAC[];

                   (* annoying edge case when y = 0 *)
                   SUBGOAL_THEN `&0 <= (y:real)` (LABEL_TAC "ygeq0") THENL [
                     ASM_ARITH_TAC; ALL_TAC] THEN

                   SUBGOAL_THEN `(y:real) = &0` (LABEL_TAC "yeq0") THENL [
                     ASM_ARITH_TAC; ALL_TAC] THEN

                   USE_THEN "frtozero" (fun frtozero ->
                   USE_THEN "ygeq0" (fun ygeq0 ->
                     LABEL_CONJUNCTS_TAC ["frgeq0"; "frleqx"; "frclose"]
                     (REWRITE_RULE[ygeq0]
                      (REWRITE_RULE[to_zero] frtozero)))) THEN

                   ASM_REWRITE_TAC[] THEN

                   SUBGOAL_THEN `y'' = &0` (fun thm -> REWRITE_TAC[thm]) THENL [
                     EXPAND_TAC "y''" THEN
                     USE_THEN "yeq0" (fun yeq0 -> REWRITE_TAC[yeq0]) THEN
                     REWRITE_TAC[FIXED_RD_EQ_0]; ALL_TAC] THEN

                   ASM_ARITH_TAC]]);;

(* -------------------------------------------------------------------------- *)
(* Round to pinf                                                              *)
(* -------------------------------------------------------------------------- *)

let fl_to_pinf = define
  `fl_to_pinf (fmt:flformat) (x:real) (y:real) =
  (x <= y /\ !(y':real). is_float(fmt) y' /\ x <= y' ==> y <= y')`;;

let FLOAT_RD_PINF_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          fl_to_pinf(fmt) x (flround(fmt) To_pinf x)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[fl_to_pinf] THEN
        CONJ_TAC THENL [
          (* show x <= to-pinf *)
          REWRITE_TAC[flround] THEN
          ASM_CASES_TAC `&0 <= (x:real)` THENL [

            (* 0 <= x *)

            ASM_REWRITE_TAC[] THEN LET_TAC THEN
            USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "xnormed"
             (REWRITE_RULE[ASSUME `&0 <= (x:real)`]
              (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))) THEN
            ONCE_ASM_REWRITE_TAC[] THEN
            EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN
            REWRITE_TAC[REAL_LE_LADD] THEN
            ASM_REWRITE_TAC[] THEN

            SUBGOAL_THEN `abs(y) <= (finf (to_fformat fmt e))`
            (LABEL_TAC "absyleq") THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              EXPAND_TAC "y" THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              EXPAND_TAC "e" THEN
              ASM_ARITH_TAC; ALL_TAC] THEN

            USE_THEN "absyleq" (fun absyleq ->
            CHOOSE_THEN
            (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frpinf"])
            (MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_RD_PINF_EXISTS)
                   absyleq)) THEN
            ASM_REWRITE_TAC[] THEN
            USE_THEN "frpinf" (fun frpinf ->
             REWRITE_TAC[REWRITE_RULE[to_pinf] frpinf]);

            (* x < 0 *)

            ASM_REWRITE_TAC[] THEN LET_TAC THEN
            USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "xnormed"
             (REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
              (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))) THEN
            ONCE_ASM_REWRITE_TAC[] THEN
            EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN
            REWRITE_TAC[REAL_LE_LADD] THEN
            ASM_REWRITE_TAC[] THEN

            SUBGOAL_THEN `abs(y) <= (finf (to_fformat fmt e))`
            (LABEL_TAC "absyleq") THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              EXPAND_TAC "y" THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              EXPAND_TAC "e" THEN
              ASM_ARITH_TAC; ALL_TAC] THEN

            USE_THEN "absyleq" (fun absyleq ->
            CHOOSE_THEN
            (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frpinf"])
            (MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_RD_PINF_EXISTS)
                   absyleq)) THEN
            ASM_REWRITE_TAC[] THEN
            USE_THEN "frpinf" (fun frpinf ->
             REWRITE_TAC[REWRITE_RULE[to_pinf] frpinf])]; ALL_TAC] THEN

   (* show to-pinf is closest *)
   GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC ["ypfloat"; "xleqyp"]) THEN
   REWRITE_TAC[flround] THEN LET_TAC THEN
   ASM_CASES_TAC `&0 <= (x:real)` THENL [
     ASM_REWRITE_TAC[] THEN

     ASM_CASES_TAC
        `&m * &(flr fmt) ipow e + (finf (to_fformat fmt e)) <= y'` THENL [
       MATCH_MP_TAC REAL_LE_TRANS THEN
       EXISTS_TAC `&m * &(flr fmt) ipow e + (finf (to_fformat fmt e))` THEN
       ASM_REWRITE_TAC[] THEN
       REWRITE_TAC[REAL_LE_LADD] THEN

       SUBGOAL_THEN `(fround (to_fformat fmt e) To_pinf y) IN
                     (fixed (to_fformat fmt e))` (LABEL_TAC "frfixed") THENL [
        REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
        MATCH_MP_TAC FIXED_RD_IS_FIXED THEN
        USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
        EXPAND_TAC "y" THEN
        USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
        EXPAND_TAC "e" THEN
        ASM_ARITH_TAC; ALL_TAC] THEN

      USE_THEN "frfixed" (fun frfixed ->
        REWRITE_TAC[MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_FINF_BOUNDS)
                      frfixed]);

      (* interesting case when m * r^e <= y < (m+1)*r^e *)

      (* get ready to reverse normalize *)
      SUBGOAL_THEN `&m * &(flr fmt) ipow e <= abs(y')`
       (LABEL_TAC "absygeq") THENL [
         MATCH_MP_TAC REAL_LE_TRANS THEN
         EXISTS_TAC `abs(x)` THEN
         CONJ_TAC THENL [
           USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
           EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN
           USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
           ASM_REWRITE_TAC[];
           ASM_ARITH_TAC]; ALL_TAC] THEN

       SUBGOAL_THEN `abs(y') < &m * &(flr fmt) ipow e +
                               (finf (to_fformat fmt e))`
        (LABEL_TAC "absylt") THENL [
          ASM_ARITH_TAC; ALL_TAC] THEN

       SUBGOAL_THEN `greatest_e(fmt) y' = e /\
                     greatest_m(fmt) y' = m`
        (LABEL_TAC "emeq") THENL [
          MATCH_MP_TAC FLOAT_BETWEEN THEN

          CONJ_TAC THENL [
            MATCH_MP_TAC FLOAT_NOT_ZERO THEN EXISTS_TAC `fmt:flformat` THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN

          USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
          ASM_REWRITE_TAC[] THEN
          EXPAND_TAC "m" THEN
          USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN

       SUBGOAL_THEN `&0 <= (y':real)` (LABEL_TAC "ypgeq0") THENL [
         ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "ypfloat" (fun ypfloat ->
       USE_THEN "ypgeq0" (fun ypgeq0 ->
         LABEL_CONJUNCTS_TAC ["ypremfloat"; "ypnormed"]
         (REWRITE_RULE[ypgeq0] (MATCH_MP FLOAT_NORMALIZE_FLOAT ypfloat)))) THEN

       ONCE_ASM_REWRITE_TAC[] THEN
       USE_THEN "emeq" (fun emeq -> REWRITE_TAC[emeq]) THEN
       REWRITE_TAC[REAL_LE_LADD] THEN

       USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN

       SUBGOAL_THEN `abs(y) <=
                       finf (to_fformat fmt (greatest_e fmt x))`
         (LABEL_TAC "absyleq") THENL [
           EXPAND_TAC "y" THEN
           USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
           ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "absyleq" (fun absyleq ->
          CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frtopinf"])
          (MATCH_MP FIXED_RD_PINF_EXISTS absyleq)) THEN

       USE_THEN "frtopinf" (fun frtopinf ->
          LABEL_CONJUNCTS_TAC ["frlower"; "frclose"]
          (REWRITE_RULE[to_pinf] frtopinf)) THEN

       EXPAND_TAC "e" THEN ASM_REWRITE_TAC[] THEN
       USE_THEN "frclose" (fun frclose -> MATCH_MP_TAC frclose) THEN

       CONJ_TAC THENL [

         REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
         USE_THEN "ypremfloat" (fun ypremfloat -> REWRITE_TAC[ypremfloat]) THEN
         ASM_REWRITE_TAC[] THEN
         USE_THEN "emeq" (fun emeq -> REWRITE_TAC[GSYM emeq]) THEN
         ASM_REWRITE_TAC[];

         ONCE_REWRITE_TAC[ARITH_RULE `a <= b <=>
             &m * &(flr fmt) ipow e + a <= &m * &(flr fmt) ipow e + b`] THEN

         EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN EXPAND_TAC "y" THEN
         USE_THEN "xneq0" (fun xneq0 ->
           ONCE_REWRITE_TAC[GSYM (REWRITE_RULE[ASSUME `&0 <= (x:real)`]
             (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))]) THEN
         ASM_REWRITE_TAC[] THEN
         USE_THEN "emeq" (fun emeq -> REWRITE_TAC[GSYM emeq]) THEN
         USE_THEN "ypnormed" (fun ypnormed -> REWRITE_TAC[GSYM ypnormed]) THEN
         USE_THEN "xleqyp" (fun xleqyp -> REWRITE_TAC[xleqyp])]];

    (* x < 0 *)
     ASM_REWRITE_TAC[] THEN

     ASM_CASES_TAC
        `-- (&m * &(flr fmt) ipow e) <= y'` THENL [
       MATCH_MP_TAC REAL_LE_TRANS THEN
       EXISTS_TAC `-- (&m * &(flr fmt) ipow e)` THEN
       ASM_REWRITE_TAC[] THEN
       GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV)
        [ARITH_RULE `(z:real) = z + &0`] THEN
       REWRITE_TAC[REAL_LE_LADD] THEN
       MATCH_MP_TAC FIXED_RD_LE_0_2 THEN
       CONJ_TAC THENL [
         USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
         EXPAND_TAC "y" THEN
         USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
         EXPAND_TAC "e" THEN ASM_ARITH_TAC;
         EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
         ASM_REWRITE_TAC[]];

      (* interesting case when -- m * r^e - finf <= y < m * r^e *)

      (* get ready to reverse normalize *)
      SUBGOAL_THEN `(&m * &(flr fmt) ipow e) <= abs(y')`
       (LABEL_TAC "absygeq") THENL [
         ASM_ARITH_TAC; ALL_TAC] THEN

      SUBGOAL_THEN `(y':real) < &0` ASSUME_TAC THENL [
        MATCH_MP_TAC REAL_LT_TRANS THEN
        EXISTS_TAC `--(&m * &(flr fmt) ipow e)` THEN
        CONJ_TAC THENL [ ASM_ARITH_TAC; ALL_TAC ] THEN
        REWRITE_TAC[ARITH_RULE `-- (x:real) < &0 <=> &0 < x`] THEN
        MATCH_MP_TAC REAL_LT_MUL THEN
        REWRITE_TAC[REAL_OF_NUM_LT] THEN
        USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
        CONJ_TAC THENL [ ASM_ARITH_TAC; ALL_TAC ] THEN
        REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]; ALL_TAC] THEN

      SUBGOAL_THEN `abs(y') < (&m * &(flr fmt) ipow e) +
                                (finf (to_fformat fmt e))`
       (LABEL_TAC "absylt") THENL [
         MATCH_MP_TAC REAL_LET_TRANS THEN
         EXISTS_TAC `abs(x)` THEN
         CONJ_TAC THENL [
           ASM_ARITH_TAC;

           SUBGOAL_THEN `abs(x) = -- x`
             (fun thm -> GEN_REWRITE_TAC (RATOR_CONV o ONCE_DEPTH_CONV)
               [thm]) THENL [
               ASM_ARITH_TAC; ALL_TAC] THEN

           USE_THEN "xneq0" (fun xneq0 ->
             GEN_REWRITE_TAC (RATOR_CONV o ONCE_DEPTH_CONV)
             [REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
               (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL)
                 xneq0)]) THEN

           REWRITE_TAC[ARITH_RULE `-- (-- (a:real) + b) = a + (-- b)`] THEN
           EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN
           REWRITE_TAC[REAL_LT_LADD] THEN

           ASM_REWRITE_TAC[] THEN
           SUBGOAL_THEN `--(y:real) = abs(y)`
             (fun thm -> REWRITE_TAC[thm]) THENL [

             SUBGOAL_THEN `(y:real) <= &0` ASSUME_TAC THENL [
               EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
               ASM_REWRITE_TAC[]; ALL_TAC] THEN
             ASM_ARITH_TAC; ALL_TAC ] THEN

           USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
           EXPAND_TAC "y" THEN
           USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
           EXPAND_TAC "e" THEN
           ASM_ARITH_TAC]; ALL_TAC ] THEN

       SUBGOAL_THEN `greatest_e(fmt) y' = e /\
                     greatest_m(fmt) y' = m`
        (LABEL_TAC "emeq") THENL [
          MATCH_MP_TAC FLOAT_BETWEEN THEN

          CONJ_TAC THENL [
            MATCH_MP_TAC FLOAT_NOT_ZERO THEN EXISTS_TAC `fmt:flformat` THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN

          ASM_REWRITE_TAC[] THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
          ASM_REWRITE_TAC[] THEN
          EXPAND_TAC "m" THEN
          USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN

       SUBGOAL_THEN `~(&0 <= (y':real))` (LABEL_TAC "yplt0") THENL [
         ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "ypfloat" (fun ypfloat ->
       USE_THEN "yplt0" (fun yplt0 ->
         LABEL_CONJUNCTS_TAC ["ypremfloat"; "ypnormed"]
         (REWRITE_RULE[yplt0] (MATCH_MP FLOAT_NORMALIZE_FLOAT ypfloat)))) THEN

       ONCE_ASM_REWRITE_TAC[] THEN
       USE_THEN "emeq" (fun emeq -> REWRITE_TAC[emeq]) THEN
       REWRITE_TAC[REAL_LE_LADD] THEN

       USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN

       SUBGOAL_THEN `abs(y) <=
                       finf (to_fformat fmt (greatest_e fmt x))`
         (LABEL_TAC "absyleq") THENL [
           EXPAND_TAC "y" THEN
           USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
           ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "absyleq" (fun absyleq ->
          CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frtopinf"])
          (MATCH_MP FIXED_RD_PINF_EXISTS absyleq)) THEN

       USE_THEN "frtopinf" (fun frtopinf ->
          LABEL_CONJUNCTS_TAC ["frlower"; "frclose"]
          (REWRITE_RULE[to_pinf] frtopinf)) THEN

       EXPAND_TAC "e" THEN ASM_REWRITE_TAC[] THEN
       USE_THEN "frclose" (fun frclose -> MATCH_MP_TAC frclose) THEN

       CONJ_TAC THENL [

         REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
         USE_THEN "ypremfloat" (fun ypremfloat -> REWRITE_TAC[ypremfloat]) THEN
         ASM_REWRITE_TAC[] THEN
         USE_THEN "emeq" (fun emeq -> REWRITE_TAC[GSYM emeq]) THEN
         ASM_REWRITE_TAC[];

         ONCE_REWRITE_TAC[ARITH_RULE `a <= b <=>
             (-- (&m * &(flr fmt) ipow e)) + a <=
             (-- (&m * &(flr fmt) ipow e)) + b`] THEN

         EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN EXPAND_TAC "y" THEN
         USE_THEN "xneq0" (fun xneq0 ->
           ONCE_REWRITE_TAC[GSYM (REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
             (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))]) THEN
         ASM_REWRITE_TAC[] THEN
         USE_THEN "emeq" (fun emeq -> REWRITE_TAC[GSYM emeq]) THEN
         USE_THEN "ypnormed" (fun ypnormed -> REWRITE_TAC[GSYM ypnormed]) THEN
         USE_THEN "xleqyp" (fun xleqyp -> REWRITE_TAC[xleqyp])]]]);;

(* -------------------------------------------------------------------------- *)
(* Round to ninf                                                              *)
(* -------------------------------------------------------------------------- *)

let fl_to_ninf = define
  `fl_to_ninf (fmt:flformat) (x:real) (y:real) =
  (y <= x /\ !(y':real). is_float(fmt) y' /\ y' <= x ==> y' <= y)`;;

let FLOAT_RD_NINF_EXISTS =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          fl_to_ninf(fmt) x (flround(fmt) To_ninf x)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[fl_to_ninf] THEN
        CONJ_TAC THENL [
          (* show to-ninf <= x *)
          REWRITE_TAC[flround] THEN
          ASM_CASES_TAC `&0 <= (x:real)` THENL [

            (* 0 <= x *)

            ASM_REWRITE_TAC[] THEN LET_TAC THEN
            USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "xnormed"
             (REWRITE_RULE[ASSUME `&0 <= (x:real)`]
              (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))) THEN
            ONCE_ASM_REWRITE_TAC[] THEN
            EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN
            REWRITE_TAC[REAL_LE_LADD] THEN
            ASM_REWRITE_TAC[] THEN

            SUBGOAL_THEN `abs(y) <= (finf (to_fformat fmt e))`
            (LABEL_TAC "absyleq") THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              EXPAND_TAC "y" THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              EXPAND_TAC "e" THEN
              ASM_ARITH_TAC; ALL_TAC] THEN

            USE_THEN "absyleq" (fun absyleq ->
            CHOOSE_THEN
            (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frpinf"])
            (MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_RD_NINF_EXISTS)
                   absyleq)) THEN
            ASM_REWRITE_TAC[] THEN
            USE_THEN "frpinf" (fun frpinf ->
             REWRITE_TAC[REWRITE_RULE[to_ninf] frpinf]);

            (* x < 0 *)

            ASM_REWRITE_TAC[] THEN LET_TAC THEN
            USE_THEN "xneq0" (fun xneq0 -> LABEL_TAC "xnormed"
             (REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
              (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))) THEN
            ONCE_ASM_REWRITE_TAC[] THEN
            EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN
            REWRITE_TAC[REAL_LE_LADD] THEN
            ASM_REWRITE_TAC[] THEN

            SUBGOAL_THEN `abs(y) <= (finf (to_fformat fmt e))`
            (LABEL_TAC "absyleq") THENL [
              USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
              EXPAND_TAC "y" THEN
              USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
              EXPAND_TAC "e" THEN
              ASM_ARITH_TAC; ALL_TAC] THEN

            USE_THEN "absyleq" (fun absyleq ->
            CHOOSE_THEN
            (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frpinf"])
            (MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_RD_NINF_EXISTS)
                   absyleq)) THEN
            ASM_REWRITE_TAC[] THEN
            USE_THEN "frpinf" (fun frpinf ->
             REWRITE_TAC[REWRITE_RULE[to_ninf] frpinf])]; ALL_TAC] THEN

   (* show to-ninf is closest *)
   GEN_TAC THEN DISCH_THEN (LABEL_CONJUNCTS_TAC ["ypfloat"; "xleqyp"]) THEN
   REWRITE_TAC[flround] THEN LET_TAC THEN
   ASM_CASES_TAC `&0 <= (x:real)` THENL [
     ASM_REWRITE_TAC[] THEN

     ASM_CASES_TAC
        `y' < &m * &(flr fmt) ipow e` THENL [
       MATCH_MP_TAC (ARITH_RULE `(a:real) < b ==> a <= b`) THEN
       MATCH_MP_TAC REAL_LTE_TRANS THEN
       EXISTS_TAC `&m * &(flr fmt) ipow e` THEN
       ASM_REWRITE_TAC[] THEN
       GEN_REWRITE_TAC (RATOR_CONV o ONCE_DEPTH_CONV)
        [ARITH_RULE `(x:real) = x + &0`] THEN
       REWRITE_TAC[REAL_LE_LADD] THEN

       MATCH_MP_TAC FIXED_RD_LE_0 THEN
       CONJ_TAC THENL [
         USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
         EXPAND_TAC "y" THEN EXPAND_TAC "e" THEN
         USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
         ASM_ARITH_TAC;
         EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN
         ASM_REWRITE_TAC[]];


      (* interesting case when m * r^e <= y < (m+1)*r^e *)

      (* get ready to reverse normalize *)
      SUBGOAL_THEN `&m * &(flr fmt) ipow e <= abs(y')`
       (LABEL_TAC "absygeq") THENL [
         ASM_ARITH_TAC; ALL_TAC] THEN

       SUBGOAL_THEN `&0 <= (y':real)` ASSUME_TAC THENL [
           MATCH_MP_TAC REAL_LE_TRANS THEN
           EXISTS_TAC `&m * &(flr fmt) ipow e` THEN
           CONJ_TAC THENL [

             MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[REAL_OF_NUM_LE] THEN
             CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
             REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];

             ASM_ARITH_TAC]; ALL_TAC] THEN

      SUBGOAL_THEN `abs(y') < &m * &(flr fmt) ipow e +
                               (finf (to_fformat fmt e))`
        (LABEL_TAC "absylt") THENL [


         MATCH_MP_TAC REAL_LET_TRANS THEN
         EXISTS_TAC `abs(x)` THEN
         CONJ_TAC THENL [

           ASM_ARITH_TAC;

           SUBGOAL_THEN `abs(x) = x` (fun thm -> REWRITE_TAC[thm]) THENL [
               ASM_ARITH_TAC; ALL_TAC] THEN
           USE_THEN "xneq0" (fun xneq0 ->
             ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `&0 <= (x:real)`]
                     (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
           ASM_REWRITE_TAC[] THEN
           REWRITE_TAC[REAL_LT_LADD] THEN

           SUBGOAL_THEN `y = abs(y)`
            (fun thm -> ONCE_REWRITE_TAC[thm]) THENL [

              SUBGOAL_THEN `&0 <= (y:real)` ASSUME_TAC THENL [
                EXPAND_TAC "y" THEN MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN
                ASM_REWRITE_TAC[]; ALL_TAC] THEN

              ASM_ARITH_TAC; ALL_TAC] THEN

           USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
           EXPAND_TAC "y" THEN EXPAND_TAC "e" THEN
           USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
           ASM_REWRITE_TAC[]]; ALL_TAC] THEN

       SUBGOAL_THEN `greatest_e(fmt) y' = e /\
                     greatest_m(fmt) y' = m`
        (LABEL_TAC "emeq") THENL [
          MATCH_MP_TAC FLOAT_BETWEEN THEN

          CONJ_TAC THENL [
            MATCH_MP_TAC FLOAT_NOT_ZERO THEN EXISTS_TAC `fmt:flformat` THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN

          USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
          ASM_REWRITE_TAC[] THEN
          EXPAND_TAC "m" THEN
          USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN

       SUBGOAL_THEN `&0 <= (y':real)` (LABEL_TAC "ypgeq0") THENL [
         ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "ypfloat" (fun ypfloat ->
       USE_THEN "ypgeq0" (fun ypgeq0 ->
         LABEL_CONJUNCTS_TAC ["ypremfloat"; "ypnormed"]
         (REWRITE_RULE[ypgeq0] (MATCH_MP FLOAT_NORMALIZE_FLOAT ypfloat)))) THEN

       ONCE_ASM_REWRITE_TAC[] THEN
       USE_THEN "emeq" (fun emeq -> REWRITE_TAC[emeq]) THEN
       REWRITE_TAC[REAL_LE_LADD] THEN

       USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN

       SUBGOAL_THEN `abs(y) <=
                       finf (to_fformat fmt (greatest_e fmt x))`
         (LABEL_TAC "absyleq") THENL [
           EXPAND_TAC "y" THEN
           USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
           ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "absyleq" (fun absyleq ->
          CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frtopinf"])
          (MATCH_MP FIXED_RD_NINF_EXISTS absyleq)) THEN

       USE_THEN "frtopinf" (fun frtopinf ->
          LABEL_CONJUNCTS_TAC ["frlower"; "frclose"]
          (REWRITE_RULE[to_ninf] frtopinf)) THEN

       EXPAND_TAC "e" THEN ASM_REWRITE_TAC[] THEN
       USE_THEN "frclose" (fun frclose -> MATCH_MP_TAC frclose) THEN

       CONJ_TAC THENL [

         REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
         USE_THEN "ypremfloat" (fun ypremfloat -> REWRITE_TAC[ypremfloat]) THEN
         ASM_REWRITE_TAC[] THEN
         USE_THEN "emeq" (fun emeq -> REWRITE_TAC[GSYM emeq]) THEN
         ASM_REWRITE_TAC[];

         ONCE_REWRITE_TAC[ARITH_RULE `a <= b <=>
             &m * &(flr fmt) ipow e + a <= &m * &(flr fmt) ipow e + b`] THEN

         EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN EXPAND_TAC "y" THEN
         USE_THEN "xneq0" (fun xneq0 ->
           ONCE_REWRITE_TAC[GSYM (REWRITE_RULE[ASSUME `&0 <= (x:real)`]
             (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))]) THEN
         ASM_REWRITE_TAC[] THEN
         USE_THEN "emeq" (fun emeq -> REWRITE_TAC[GSYM emeq]) THEN
         USE_THEN "ypnormed" (fun ypnormed -> REWRITE_TAC[GSYM ypnormed]) THEN
         USE_THEN "xleqyp" (fun xleqyp -> REWRITE_TAC[xleqyp])]];

    (* x < 0 *)
     ASM_REWRITE_TAC[] THEN

     ASM_CASES_TAC
    `y' <= -- (&m * &(flr fmt) ipow e) + (-- (finf (to_fformat fmt e)))` THENL [
       MATCH_MP_TAC REAL_LE_TRANS THEN
 EXISTS_TAC `-- (&m * &(flr fmt) ipow e) + (-- (finf (to_fformat fmt e)))` THEN
       ASM_REWRITE_TAC[] THEN
       REWRITE_TAC[REAL_LE_LADD] THEN

       SUBGOAL_THEN `(fround (to_fformat fmt e) To_ninf y) IN
            (fixed (to_fformat fmt e))` (LABEL_TAC "frinfixed") THENL [
         REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
         MATCH_MP_TAC FIXED_RD_IS_FIXED THEN
         USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
         EXPAND_TAC "y" THEN
         USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
         EXPAND_TAC "e" THEN
         ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "frinfixed" (fun frinfixed ->
         REWRITE_TAC[MATCH_MP (SPEC `(to_fformat fmt e)` FIXED_FINF_BOUNDS)
                      frinfixed]);

      (* interesting case when -- m * r^e - finf < y <= m * r^e *)

      (* get ready to reverse normalize *)
      SUBGOAL_THEN `(y':real) < &0` ASSUME_TAC THENL [
        ASM_ARITH_TAC; ALL_TAC] THEN

      SUBGOAL_THEN `abs(y') < (&m * &(flr fmt) ipow e) +
                                (finf (to_fformat fmt e))`
       (LABEL_TAC "absylt") THENL [
         ASM_ARITH_TAC; ALL_TAC] THEN

      SUBGOAL_THEN `(&m * &(flr fmt) ipow e) <= abs(y')`
       (LABEL_TAC "absygeq") THENL [

        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `abs(x)` THEN
        CONJ_TAC THENL [
          USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
          EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN
          USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
          ASM_REWRITE_TAC[];
          ASM_ARITH_TAC]; ALL_TAC] THEN

       SUBGOAL_THEN `greatest_e(fmt) y' = e /\
                     greatest_m(fmt) y' = m`
        (LABEL_TAC "emeq") THENL [
          MATCH_MP_TAC FLOAT_BETWEEN THEN

          CONJ_TAC THENL [
            MATCH_MP_TAC FLOAT_NOT_ZERO THEN EXISTS_TAC `fmt:flformat` THEN
            ASM_REWRITE_TAC[]; ALL_TAC] THEN

          ASM_REWRITE_TAC[] THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
          ASM_REWRITE_TAC[] THEN
          EXPAND_TAC "m" THEN
          USE_THEN "xgmeq" (fun xgmeq -> REWRITE_TAC[xgmeq]) THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN

       SUBGOAL_THEN `~(&0 <= (y':real))` (LABEL_TAC "yplt0") THENL [
         ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "ypfloat" (fun ypfloat ->
       USE_THEN "yplt0" (fun yplt0 ->
         LABEL_CONJUNCTS_TAC ["ypremfloat"; "ypnormed"]
         (REWRITE_RULE[yplt0] (MATCH_MP FLOAT_NORMALIZE_FLOAT ypfloat)))) THEN

       ONCE_ASM_REWRITE_TAC[] THEN
       USE_THEN "emeq" (fun emeq -> REWRITE_TAC[emeq]) THEN
       REWRITE_TAC[REAL_LE_LADD] THEN

       USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN

       SUBGOAL_THEN `abs(y) <=
                       finf (to_fformat fmt (greatest_e fmt x))`
         (LABEL_TAC "absyleq") THENL [
           EXPAND_TAC "y" THEN
           USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
           ASM_ARITH_TAC; ALL_TAC] THEN

       USE_THEN "absyleq" (fun absyleq ->
          CHOOSE_THEN
          (LABEL_CONJUNCTS_TAC ["freq"; "frfixed"; "frtopinf"])
          (MATCH_MP FIXED_RD_NINF_EXISTS absyleq)) THEN

       USE_THEN "frtopinf" (fun frtopinf ->
          LABEL_CONJUNCTS_TAC ["frlower"; "frclose"]
          (REWRITE_RULE[to_ninf] frtopinf)) THEN

       EXPAND_TAC "e" THEN ASM_REWRITE_TAC[] THEN
       USE_THEN "frclose" (fun frclose -> MATCH_MP_TAC frclose) THEN

       CONJ_TAC THENL [

         REWRITE_TAC[fixed] THEN REWRITE_TAC[IN_ELIM_THM] THEN
         USE_THEN "ypremfloat" (fun ypremfloat -> REWRITE_TAC[ypremfloat]) THEN
         ASM_REWRITE_TAC[] THEN
         USE_THEN "emeq" (fun emeq -> REWRITE_TAC[GSYM emeq]) THEN
         ASM_REWRITE_TAC[];

         ONCE_REWRITE_TAC[ARITH_RULE `a <= b <=>
             (-- (&m * &(flr fmt) ipow e)) + a <=
             (-- (&m * &(flr fmt) ipow e)) + b`] THEN

         EXPAND_TAC "m" THEN EXPAND_TAC "e" THEN EXPAND_TAC "y" THEN
         USE_THEN "xneq0" (fun xneq0 ->
           ONCE_REWRITE_TAC[GSYM (REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
             (MATCH_MP (SPEC `fmt:flformat` FLOAT_NORMALIZE_REAL) xneq0))]) THEN
         ASM_REWRITE_TAC[] THEN
         USE_THEN "emeq" (fun emeq -> REWRITE_TAC[GSYM emeq]) THEN
         USE_THEN "ypnormed" (fun ypnormed -> REWRITE_TAC[GSYM ypnormed]) THEN
         USE_THEN "xleqyp" (fun xleqyp -> REWRITE_TAC[xleqyp])]]]);;

(* -------------------------------------------------------------------------- *)
(* Absolute Error bounds                                                      *)
(* -------------------------------------------------------------------------- *)

(* these are refreshingly easy ... *)

let FLOAT_RD_NEAR_ABS_ERR =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          abs( (flround(fmt) To_near x) - x ) <=
              (fulp (to_fformat fmt (greatest_e(fmt) x))) / &2`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[flround] THEN
        ASM_CASES_TAC `&0 <= (x:real)` THENL [

          ASM_REWRITE_TAC[] THEN LET_TAC THEN
          USE_THEN "xneq0" (fun xneq0 ->
            ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `&0 <= (x:real)`]
              (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) + b) - (a + c) = b - c`] THEN
          MATCH_MP_TAC FIXED_RD_NEAREST_ABS_ERROR THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          EXPAND_TAC "y" THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          EXPAND_TAC "e" THEN
          ASM_ARITH_TAC;

          ASM_REWRITE_TAC[] THEN LET_TAC THEN
          USE_THEN "xneq0" (fun xneq0 ->
            ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
              (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) + b) - (a + c) = b - c`] THEN
          MATCH_MP_TAC FIXED_RD_NEAREST_ABS_ERROR THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          EXPAND_TAC "y" THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          EXPAND_TAC "e" THEN
          ASM_ARITH_TAC]);;

let FLOAT_RD_ZERO_ABS_ERR =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          abs( (flround(fmt) To_zero x) - x ) <=
              (fulp (to_fformat fmt (greatest_e(fmt) x)))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[flround] THEN
        ASM_CASES_TAC `&0 <= (x:real)` THENL [

          ASM_REWRITE_TAC[] THEN LET_TAC THEN
          USE_THEN "xneq0" (fun xneq0 ->
            ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `&0 <= (x:real)`]
              (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) + b) - (a + c) = b - c`] THEN
          MATCH_MP_TAC FIXED_RD_ZERO_ABS_ERROR THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          EXPAND_TAC "y" THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          EXPAND_TAC "e" THEN
          ASM_ARITH_TAC;

          ASM_REWRITE_TAC[] THEN LET_TAC THEN
          USE_THEN "xneq0" (fun xneq0 ->
            ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
              (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) + b) - (a + c) = b - c`] THEN
          MATCH_MP_TAC FIXED_RD_ZERO_ABS_ERROR THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          EXPAND_TAC "y" THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          EXPAND_TAC "e" THEN
          ASM_ARITH_TAC]);;

let FLOAT_RD_PINF_ABS_ERR =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          abs( (flround(fmt) To_pinf x) - x ) <=
              (fulp (to_fformat fmt (greatest_e(fmt) x)))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[flround] THEN
        ASM_CASES_TAC `&0 <= (x:real)` THENL [

          ASM_REWRITE_TAC[] THEN LET_TAC THEN
          USE_THEN "xneq0" (fun xneq0 ->
            ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `&0 <= (x:real)`]
              (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) + b) - (a + c) = b - c`] THEN
          MATCH_MP_TAC FIXED_RD_PINF_ABS_ERROR THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          EXPAND_TAC "y" THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          EXPAND_TAC "e" THEN
          ASM_ARITH_TAC;

          ASM_REWRITE_TAC[] THEN LET_TAC THEN
          USE_THEN "xneq0" (fun xneq0 ->
            ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
              (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) + b) - (a + c) = b - c`] THEN
          MATCH_MP_TAC FIXED_RD_PINF_ABS_ERROR THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          EXPAND_TAC "y" THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          EXPAND_TAC "e" THEN
          ASM_ARITH_TAC]);;

let FLOAT_RD_NINF_ABS_ERR =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          abs( (flround(fmt) To_ninf x) - x ) <=
              (fulp (to_fformat fmt (greatest_e(fmt) x)))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[flround] THEN
        ASM_CASES_TAC `&0 <= (x:real)` THENL [

          ASM_REWRITE_TAC[] THEN LET_TAC THEN
          USE_THEN "xneq0" (fun xneq0 ->
            ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `&0 <= (x:real)`]
              (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) + b) - (a + c) = b - c`] THEN
          MATCH_MP_TAC FIXED_RD_NINF_ABS_ERROR THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          EXPAND_TAC "y" THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          EXPAND_TAC "e" THEN
          ASM_ARITH_TAC;

          ASM_REWRITE_TAC[] THEN LET_TAC THEN
          USE_THEN "xneq0" (fun xneq0 ->
            ONCE_REWRITE_TAC[REWRITE_RULE[ASSUME `~(&0 <= (x:real))`]
              (MATCH_MP FLOAT_NORMALIZE_REAL xneq0)]) THEN
          ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[ARITH_RULE `((a:real) + b) - (a + c) = b - c`] THEN
          MATCH_MP_TAC FIXED_RD_NINF_ABS_ERROR THEN
          USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
          EXPAND_TAC "y" THEN
          USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
          EXPAND_TAC "e" THEN
          ASM_ARITH_TAC]);;

(* -------------------------------------------------------------------------- *)
(* Relative Error bounds                                                      *)
(* -------------------------------------------------------------------------- *)

(* unlike fixed point, we can put a bound on the abs error for all rounding   *)
(* modes ...                                                                  *)

let FLOAT_RD_NEAR_REL_ERROR =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (rerror x (flround(fmt) To_near x)) <= fl_eps(fmt)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[rerror] THEN
        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `(fulp (to_fformat fmt (greatest_e fmt x)) / &2) /
                       abs(x)` THEN
        CONJ_TAC THENL [
          REWRITE_TAC[REAL_ABS_DIV] THEN

          SUBGOAL_THEN `&0 < abs(x)`
            (fun thm -> REWRITE_TAC[MATCH_MP REAL_LE_DIV2_EQ thm]) THENL [
              ASM_ARITH_TAC; ALL_TAC] THEN

          MATCH_MP_TAC FLOAT_RD_NEAR_ABS_ERR THEN ASM_REWRITE_TAC[];
          ALL_TAC] THEN

        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `fulp (to_fformat fmt (greatest_e fmt x)) / &2 /
           (&(flr fmt) ipow (greatest_e(fmt) x))` THEN
        CONJ_TAC THENL [

          ONCE_REWRITE_TAC[GSYM REAL_INV_INV] THEN
          MATCH_MP_TAC REAL_LE_INV2 THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC REAL_LT_INV THEN
            MATCH_MP_TAC REAL_LT_DIV THEN
            CONJ_TAC THENL [
              MATCH_MP_TAC REAL_LT_DIV THEN REWRITE_TAC[fulp] THEN
              REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0] THEN ARITH_TAC;
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]];

            REWRITE_TAC[REAL_INV_DIV] THEN

            SUBGOAL_THEN `&0 <
                 (fulp (to_fformat fmt (greatest_e fmt x)) / &2)`
              (fun thm -> REWRITE_TAC[MATCH_MP REAL_LE_DIV2_EQ thm]) THENL [
                MATCH_MP_TAC REAL_LT_DIV THEN
                CONJ_TAC THENL [
                  REWRITE_TAC[fulp] THEN
                  REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0];
                  ARITH_TAC]; ALL_TAC] THEN

            USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x") THEN
            ASM_REWRITE_TAC[]]; ALL_TAC] THEN

          REWRITE_TAC[fulp] THEN dump_flformat_conv `(greatest_e(fmt) x)` THEN
          ASM_REWRITE_TAC[] THEN

          SUBGOAL_THEN `&(flr fmt) ipow greatest_e fmt x =
            inv (&(flr fmt) ipow (-- (greatest_e fmt x)))`
            (fun thm -> REWRITE_TAC[thm]) THENL [
              MATCH_MP_TAC IPOW_INV_NEG THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0]; ALL_TAC] THEN

          ONCE_REWRITE_TAC[real_div] THEN
          REWRITE_TAC[REAL_INV_INV] THEN
          REWRITE_TAC[ARITH_RULE `(a:real) / b * c = (a * c) / b`] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `((e:int) - p + &1) + (-- e) = &1 - p`] THEN
          REWRITE_TAC[fl_eps] THEN ARITH_TAC);;

let FLOAT_RD_ZERO_REL_ERROR =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (rerror x (flround(fmt) To_zero x)) <= &2 * fl_eps(fmt)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[rerror] THEN
        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `(fulp (to_fformat fmt (greatest_e fmt x))) / abs(x)` THEN
        CONJ_TAC THENL [
          REWRITE_TAC[REAL_ABS_DIV] THEN

          SUBGOAL_THEN `&0 < abs(x)`
            (fun thm -> REWRITE_TAC[MATCH_MP REAL_LE_DIV2_EQ thm]) THENL [
              ASM_ARITH_TAC; ALL_TAC] THEN

          MATCH_MP_TAC FLOAT_RD_ZERO_ABS_ERR THEN ASM_REWRITE_TAC[];
          ALL_TAC] THEN

        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `fulp (to_fformat fmt (greatest_e fmt x)) /
           (&(flr fmt) ipow (greatest_e(fmt) x))` THEN
        CONJ_TAC THENL [

          ONCE_REWRITE_TAC[GSYM REAL_INV_INV] THEN
          MATCH_MP_TAC REAL_LE_INV2 THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC REAL_LT_INV THEN
            MATCH_MP_TAC REAL_LT_DIV THEN
            CONJ_TAC THENL [
              REWRITE_TAC[fulp] THEN
              REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0] THEN ARITH_TAC;
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]];

            REWRITE_TAC[REAL_INV_DIV] THEN

            SUBGOAL_THEN `&0 <
                 (fulp (to_fformat fmt (greatest_e fmt x)))`
              (fun thm -> REWRITE_TAC[MATCH_MP REAL_LE_DIV2_EQ thm]) THENL [
                  REWRITE_TAC[fulp] THEN
                  REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0]; ALL_TAC] THEN

            USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x") THEN
            ASM_REWRITE_TAC[]]; ALL_TAC] THEN

          REWRITE_TAC[fulp] THEN dump_flformat_conv `(greatest_e(fmt) x)` THEN
          ASM_REWRITE_TAC[] THEN

          SUBGOAL_THEN `&(flr fmt) ipow greatest_e fmt x =
            inv (&(flr fmt) ipow (-- (greatest_e fmt x)))`
            (fun thm -> REWRITE_TAC[thm]) THENL [
              MATCH_MP_TAC IPOW_INV_NEG THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0]; ALL_TAC] THEN

          ONCE_REWRITE_TAC[real_div] THEN
          REWRITE_TAC[REAL_INV_INV] THEN
          REWRITE_TAC[ARITH_RULE `(a:real) / b * c = (a * c) / b`] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `((e:int) - p + &1) + (-- e) = &1 - p`] THEN
          REWRITE_TAC[fl_eps] THEN ARITH_TAC);;

let FLOAT_RD_PINF_REL_ERROR =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (rerror x (flround(fmt) To_pinf x)) <= &2 * fl_eps(fmt)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[rerror] THEN
        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `(fulp (to_fformat fmt (greatest_e fmt x))) / abs(x)` THEN
        CONJ_TAC THENL [
          REWRITE_TAC[REAL_ABS_DIV] THEN

          SUBGOAL_THEN `&0 < abs(x)`
            (fun thm -> REWRITE_TAC[MATCH_MP REAL_LE_DIV2_EQ thm]) THENL [
              ASM_ARITH_TAC; ALL_TAC] THEN

          MATCH_MP_TAC FLOAT_RD_PINF_ABS_ERR THEN ASM_REWRITE_TAC[];
          ALL_TAC] THEN

        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `fulp (to_fformat fmt (greatest_e fmt x)) /
           (&(flr fmt) ipow (greatest_e(fmt) x))` THEN
        CONJ_TAC THENL [

          ONCE_REWRITE_TAC[GSYM REAL_INV_INV] THEN
          MATCH_MP_TAC REAL_LE_INV2 THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC REAL_LT_INV THEN
            MATCH_MP_TAC REAL_LT_DIV THEN
            CONJ_TAC THENL [
              REWRITE_TAC[fulp] THEN
              REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0] THEN ARITH_TAC;
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]];

            REWRITE_TAC[REAL_INV_DIV] THEN

            SUBGOAL_THEN `&0 <
                 (fulp (to_fformat fmt (greatest_e fmt x)))`
              (fun thm -> REWRITE_TAC[MATCH_MP REAL_LE_DIV2_EQ thm]) THENL [
                  REWRITE_TAC[fulp] THEN
                  REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0]; ALL_TAC] THEN

            USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x") THEN
            ASM_REWRITE_TAC[]]; ALL_TAC] THEN

          REWRITE_TAC[fulp] THEN dump_flformat_conv `(greatest_e(fmt) x)` THEN
          ASM_REWRITE_TAC[] THEN

          SUBGOAL_THEN `&(flr fmt) ipow greatest_e fmt x =
            inv (&(flr fmt) ipow (-- (greatest_e fmt x)))`
            (fun thm -> REWRITE_TAC[thm]) THENL [
              MATCH_MP_TAC IPOW_INV_NEG THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0]; ALL_TAC] THEN

          ONCE_REWRITE_TAC[real_div] THEN
          REWRITE_TAC[REAL_INV_INV] THEN
          REWRITE_TAC[ARITH_RULE `(a:real) / b * c = (a * c) / b`] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `((e:int) - p + &1) + (-- e) = &1 - p`] THEN
          REWRITE_TAC[fl_eps] THEN ARITH_TAC);;

let FLOAT_RD_NINF_REL_ERROR =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (rerror x (flround(fmt) To_ninf x)) <= &2 * fl_eps(fmt)`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        REWRITE_TAC[rerror] THEN
        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `(fulp (to_fformat fmt (greatest_e fmt x))) / abs(x)` THEN
        CONJ_TAC THENL [
          REWRITE_TAC[REAL_ABS_DIV] THEN

          SUBGOAL_THEN `&0 < abs(x)`
            (fun thm -> REWRITE_TAC[MATCH_MP REAL_LE_DIV2_EQ thm]) THENL [
              ASM_ARITH_TAC; ALL_TAC] THEN

          MATCH_MP_TAC FLOAT_RD_NINF_ABS_ERR THEN ASM_REWRITE_TAC[];
          ALL_TAC] THEN

        MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC `fulp (to_fformat fmt (greatest_e fmt x)) /
           (&(flr fmt) ipow (greatest_e(fmt) x))` THEN
        CONJ_TAC THENL [

          ONCE_REWRITE_TAC[GSYM REAL_INV_INV] THEN
          MATCH_MP_TAC REAL_LE_INV2 THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC REAL_LT_INV THEN
            MATCH_MP_TAC REAL_LT_DIV THEN
            CONJ_TAC THENL [
              REWRITE_TAC[fulp] THEN
              REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0] THEN ARITH_TAC;
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0]];

            REWRITE_TAC[REAL_INV_DIV] THEN

            SUBGOAL_THEN `&0 <
                 (fulp (to_fformat fmt (greatest_e fmt x)))`
              (fun thm -> REWRITE_TAC[MATCH_MP REAL_LE_DIV2_EQ thm]) THENL [
                  REWRITE_TAC[fulp] THEN
                  REWRITE_TAC[FFORMAT_RADIX_IPOW_LT_0]; ALL_TAC] THEN

            USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x") THEN
            ASM_REWRITE_TAC[]]; ALL_TAC] THEN

          REWRITE_TAC[fulp] THEN dump_flformat_conv `(greatest_e(fmt) x)` THEN
          ASM_REWRITE_TAC[] THEN

          SUBGOAL_THEN `&(flr fmt) ipow greatest_e fmt x =
            inv (&(flr fmt) ipow (-- (greatest_e fmt x)))`
            (fun thm -> REWRITE_TAC[thm]) THENL [
              MATCH_MP_TAC IPOW_INV_NEG THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0]; ALL_TAC] THEN

          ONCE_REWRITE_TAC[real_div] THEN
          REWRITE_TAC[REAL_INV_INV] THEN
          REWRITE_TAC[ARITH_RULE `(a:real) / b * c = (a * c) / b`] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `((e:int) - p + &1) + (-- e) = &1 - p`] THEN
          REWRITE_TAC[fl_eps] THEN ARITH_TAC);;

(* -------------------------------------------------------------------------- *)
(* Delta bound                                                                *)
(* -------------------------------------------------------------------------- *)

let FLOAT_RD_NEAR_REL_DELTA =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (?(d:real). flround(fmt) To_near x = (&1 + d) * x /\
                      abs(d) <= fl_eps(fmt))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        EXISTS_TAC `((flround(fmt) To_near x) - x) / x` THEN
        REWRITE_TAC[REAL_ADD_RDISTRIB] THEN

        SUBGOAL_THEN `!z. z / x * x = z` (fun thm -> REWRITE_TAC[thm]) THENL [
          GEN_TAC THEN MATCH_MP_TAC REAL_DIV_RMUL THEN ASM_REWRITE_TAC[];
          ALL_TAC] THEN

        CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
        REWRITE_TAC[GSYM rerror] THEN
        MATCH_MP_TAC FLOAT_RD_NEAR_REL_ERROR THEN ASM_REWRITE_TAC[]);;

let FLOAT_RD_ZERO_REL_DELTA =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (?(d:real). flround(fmt) To_zero x = (&1 + d) * x /\
                      abs(d) <= &2 * fl_eps(fmt))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        EXISTS_TAC `((flround(fmt) To_zero x) - x) / x` THEN
        REWRITE_TAC[REAL_ADD_RDISTRIB] THEN

        SUBGOAL_THEN `!z. z / x * x = z` (fun thm -> REWRITE_TAC[thm]) THENL [
          GEN_TAC THEN MATCH_MP_TAC REAL_DIV_RMUL THEN ASM_REWRITE_TAC[];
          ALL_TAC] THEN

        CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
        REWRITE_TAC[GSYM rerror] THEN
        MATCH_MP_TAC FLOAT_RD_ZERO_REL_ERROR THEN ASM_REWRITE_TAC[]);;

let FLOAT_RD_PINF_REL_DELTA =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (?(d:real). flround(fmt) To_pinf x = (&1 + d) * x /\
                      abs(d) <= &2 * fl_eps(fmt))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        EXISTS_TAC `((flround(fmt) To_pinf x) - x) / x` THEN
        REWRITE_TAC[REAL_ADD_RDISTRIB] THEN

        SUBGOAL_THEN `!z. z / x * x = z` (fun thm -> REWRITE_TAC[thm]) THENL [
          GEN_TAC THEN MATCH_MP_TAC REAL_DIV_RMUL THEN ASM_REWRITE_TAC[];
          ALL_TAC] THEN

        CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
        REWRITE_TAC[GSYM rerror] THEN
        MATCH_MP_TAC FLOAT_RD_PINF_REL_ERROR THEN ASM_REWRITE_TAC[]);;

let FLOAT_RD_NINF_REL_DELTA =
  prove(`!(fmt:flformat) (x:real). ~(x = &0) ==>
          (?(d:real). flround(fmt) To_ninf x = (&1 + d) * x /\
                      abs(d) <= &2 * fl_eps(fmt))`,
        REPEAT GEN_TAC THEN DISCH_THEN (LABEL_TAC "xneq0") THEN
        EXISTS_TAC `((flround(fmt) To_ninf x) - x) / x` THEN
        REWRITE_TAC[REAL_ADD_RDISTRIB] THEN

        SUBGOAL_THEN `!z. z / x * x = z` (fun thm -> REWRITE_TAC[thm]) THENL [
          GEN_TAC THEN MATCH_MP_TAC REAL_DIV_RMUL THEN ASM_REWRITE_TAC[];
          ALL_TAC] THEN

        CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
        REWRITE_TAC[GSYM rerror] THEN
        MATCH_MP_TAC FLOAT_RD_NINF_REL_ERROR THEN ASM_REWRITE_TAC[]);;

(* -------------------------------------------------------------------------- *)
(* Some useful identities, properties                                         *)
(* -------------------------------------------------------------------------- *)

let FLOAT_GREATEST_E_OF =
  prove(`!(fmt:flformat) (e:int) (f:num).
          (flr fmt) EXP ((flp fmt) - 1) <= f /\
          f < (flr fmt) EXP (flp fmt) ==>
          greatest_e(fmt) (&f * &(flr fmt) ipow (e - &(flp fmt) + &1)) = e`,
        REPEAT GEN_TAC THEN
        DISCH_THEN (LABEL_CONJUNCTS_TAC ["fraclo"; "frachi"]) THEN

        SUBGOAL_THEN `~(&f * &(flr fmt) ipow (e - &(flp fmt) + &1) = &0)`
          (LABEL_TAC "neq0") THENL [
            REWRITE_TAC[REAL_ENTIRE] THEN
            REWRITE_TAC[DE_MORGAN_THM] THEN
            CONJ_TAC THENL [
              REWRITE_TAC[REAL_OF_NUM_EQ] THEN
              MATCH_MP_TAC (ARITH_RULE `0 < f ==> ~(f = 0)`) THEN
              MATCH_MP_TAC LTE_TRANS THEN
              EXISTS_TAC `flr fmt EXP (flp fmt - 1)` THEN
              ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[EXP_LT_0] THEN
              DISJ1_TAC THEN REWRITE_TAC[GSYM REAL_OF_NUM_EQ] THEN
              REWRITE_TAC[FLFORMAT_RADIX_NE_0];

              REWRITE_TAC[FLFORMAT_RADIX_IPOW_NEQ_0]]; ALL_TAC] THEN

        MATCH_MP_TAC
          (SPECL [`fmt:flformat`; `&f * &(flr fmt) ipow (e - &(flp fmt) + &1)`]
             FLOAT_GREATEST_E_UNIQUE) THEN

        CONJ_TAC THENL [
          USE_THEN "neq0" (fun neq0 -> dump_ge_info neq0 "fe") THEN
          ASM_REWRITE_TAC[]; ALL_TAC] THEN

        REWRITE_TAC[is_greatest_e] THEN
        CONJ_TAC THENL [

          (* show lower bound *)

          MATCH_MP_TAC REAL_LE_TRANS THEN
          EXISTS_TAC `&(flr fmt EXP (flp fmt - 1)) *
                         &(flr fmt) ipow (e - &(flp fmt) + &1)` THEN
          CONJ_TAC THENL [
            REWRITE_TAC[GSYM FLFORMAT_PREC_IPOW_EQ_EXP] THEN
            REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
            REWRITE_TAC[ARITH_RULE `(e:int) - &1 + e2 - e + &1 = e2`] THEN
            ARITH_TAC;

            SUBGOAL_THEN `&0 <= &f * &(flr fmt) ipow (e - &(flp fmt) + &1)`
              (LABEL_TAC "leq0") THENL [
                MATCH_MP_TAC REAL_LE_MUL THEN
                REWRITE_TAC[REAL_OF_NUM_LE] THEN
                CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
                REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]; ALL_TAC] THEN

            USE_THEN "leq0" (fun leq0 ->
                REWRITE_TAC[MATCH_MP (ARITH_RULE `&0 <= x ==> abs(x) = x`)
                              leq0]) THEN

            MATCH_MP_TAC REAL_LE_RMUL THEN
            REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0] THEN
            REWRITE_TAC[REAL_OF_NUM_LE] THEN ASM_REWRITE_TAC[]]; ALL_TAC] THEN

        (* show it is the greatest *)
        GEN_TAC THEN ONCE_REWRITE_TAC[GSYM CONTRAPOS_THM] THEN
        DISCH_THEN (LABEL_TAC "epgte") THEN
        REWRITE_TAC[REAL_NOT_LE] THEN

        SUBGOAL_THEN `&0 <= &f * &(flr fmt) ipow (e - &(flp fmt) + &1)`
              (LABEL_TAC "leq0") THENL [
                MATCH_MP_TAC REAL_LE_MUL THEN
                REWRITE_TAC[REAL_OF_NUM_LE] THEN
                CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
                REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]; ALL_TAC] THEN

        USE_THEN "leq0" (fun leq0 -> REWRITE_TAC[MATCH_MP
          (ARITH_RULE `&0 <= x ==> abs(x) = x`) leq0]) THEN

        MATCH_MP_TAC REAL_LTE_TRANS THEN
        EXISTS_TAC `&(flr fmt EXP flp fmt) *
          &(flr fmt) ipow (e - &(flp fmt) + &1)` THEN
        CONJ_TAC THENL [
          MATCH_MP_TAC REAL_LT_RMUL THEN
          REWRITE_TAC[REAL_OF_NUM_LT] THEN ASM_REWRITE_TAC[] THEN
          REWRITE_TAC[FLFORMAT_RADIX_IPOW_LT_0];

          REWRITE_TAC[FLFORMAT_PREC_EXP_EQ_IPOW] THEN
          REWRITE_TAC[GSYM FLFORMAT_PREC_IPOW_EQ_EXP] THEN
          REWRITE_TAC[MATCH_MP (SPEC `&(flr fmt)` IPOW_ADD_EXP)
             (SPEC `fmt:flformat` FLFORMAT_RADIX_NE_0)] THEN
          REWRITE_TAC[ARITH_RULE `(e:int) + e2 - e + &1 = e2 + &1`] THEN
          MATCH_MP_TAC IPOW_MONOTONE_2 THEN
          CONJ_TAC THENL [
            MATCH_MP_TAC (ARITH_RULE `&1 < x ==> &1 <= x`) THEN
            REWRITE_TAC[REAL_OF_NUM_LT] THEN
            REWRITE_TAC[FLFORMAT_RADIX_LT_1];
            ASM_ARITH_TAC]]);;






let FLOAT_RD_LE_0 =
  prove(`!(fmt:flformat) (x:real) (m:roundmode).
          ~(x = &0) /\ &0 <= x ==> &0 <= (flround(fmt) m x)`,
        REPEAT GEN_TAC THEN
        DISCH_THEN (LABEL_CONJUNCTS_TAC ["xneq0"; "xgeq0"]) THEN
        REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN

        SUBGOAL_THEN `&0 <= (fround (to_fformat fmt e) m y)`
          (LABEL_TAC "frgeq0") THENL [
          MATCH_MP_TAC FIXED_RD_LE_0 THEN
          CONJ_TAC THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_e(fmt) x = e`)] THEN
            USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
            ASM_ARITH_TAC;

            REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
            MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN
            ASM_REWRITE_TAC[]]; ALL_TAC] THEN

        MATCH_MP_TAC REAL_LE_ADD THEN
        ASM_REWRITE_TAC[] THEN
        MATCH_MP_TAC REAL_LE_MUL THEN
        REWRITE_TAC[REAL_OF_NUM_LE] THEN
        CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
        REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]);;

let FLOAT_RD_LE_0_2 =
  prove(`!(fmt:flformat) (x:real) (m:roundmode).
          ~(x = &0) /\ ~(&0 <= x) ==> (flround(fmt) m x) <= &0`,
        REPEAT GEN_TAC THEN
        DISCH_THEN (LABEL_CONJUNCTS_TAC ["xneq0"; "xlt0"]) THEN
        REWRITE_TAC[flround] THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN

        SUBGOAL_THEN `(fround (to_fformat fmt e) m y) <= &0` ASSUME_TAC
          THENL [
          MATCH_MP_TAC FIXED_RD_LE_0_2 THEN
          CONJ_TAC THENL [
            USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
            REWRITE_TAC[GSYM(ASSUME `greatest_e(fmt) x = e`)] THEN
            USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
            ASM_ARITH_TAC;

            REWRITE_TAC[GSYM(ASSUME `greatest_r(fmt) x = y`)] THEN
            MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
            ASM_REWRITE_TAC[]]; ALL_TAC] THEN

        REWRITE_TAC[ARITH_RULE `--(x:real) + y <= &0 <=> &0 <= x + (-- y)`] THEN
        MATCH_MP_TAC REAL_LE_ADD THEN
        CONJ_TAC THENL [
          REWRITE_TAC[REAL_OF_NUM_LE] THEN
          MATCH_MP_TAC REAL_LE_MUL THEN
          CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
          REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];
          ASM_ARITH_TAC]);;

let FLOAT_RD_MONO =
  prove(`!(fmt:flformat) (x:real) (e:int) (m:roundmode).
          ~(x = &0) /\ &(flr fmt) ipow e <= abs(x) ==>
          &(flr fmt) ipow e <= abs(flround(fmt) m x)`,
        REPEAT GEN_TAC THEN
        DISCH_THEN (LABEL_CONJUNCTS_TAC ["xneq0"; "absxgeq"]) THEN

        SUBGOAL_THEN `&(flr fmt) ipow e <=
             &(greatest_m(fmt) x) * &(flr fmt) ipow (greatest_e(fmt) x)`
          (LABEL_TAC "lb1") THENL [
            MATCH_MP_TAC REAL_LE_TRANS THEN
            EXISTS_TAC `&(flr fmt) ipow (greatest_e(fmt) x)` THEN
            CONJ_TAC THENL [

              USE_THEN "xneq0" (fun xneq0 -> dump_ge_info xneq0 "x") THEN
              ASM_REWRITE_TAC[] THEN MATCH_MP_TAC IPOW_MONOTONE_2 THEN
              CONJ_TAC THENL [
                MATCH_MP_TAC (ARITH_RULE `&1 < x ==> &1 <= x`) THEN
                REWRITE_TAC[REAL_OF_NUM_LT] THEN
                REWRITE_TAC[FLFORMAT_RADIX_LT_1]; ALL_TAC] THEN
              USE_THEN "xgebig2" (fun xgebig2 -> MATCH_MP_TAC xgebig2) THEN
              ASM_REWRITE_TAC[];

              USE_THEN "xneq0" (fun xneq0 -> dump_gm_info xneq0 "x") THEN
              ASM_REWRITE_TAC[] THEN
              GEN_REWRITE_TAC (RATOR_CONV o ONCE_DEPTH_CONV)
               [ARITH_RULE `x = &1 * (x:real)`] THEN
              MATCH_MP_TAC REAL_LE_RMUL THEN
              REWRITE_TAC[REAL_OF_NUM_LE] THEN ASM_REWRITE_TAC[] THEN
              REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0]]; ALL_TAC] THEN

     REWRITE_TAC[flround] THEN LET_TAC THEN
     COND_CASES_TAC THENL [

       SUBGOAL_THEN `&0 <= fround (to_fformat fmt e') m y`
         (LABEL_TAC "geq0_1") THENL [
           MATCH_MP_TAC FIXED_RD_LE_0 THEN
           CONJ_TAC THENL [

               MATCH_MP_TAC (ARITH_RULE `x < y ==> x <= (y:real)`) THEN
               USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
               REWRITE_TAC[GSYM (ASSUME `greatest_r(fmt) x = y`)] THEN
               REWRITE_TAC[GSYM (ASSUME `greatest_e(fmt) x = e'`)] THEN
               USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
               ASM_REWRITE_TAC[];

               REWRITE_TAC[GSYM (ASSUME `greatest_r(fmt) x = y`)] THEN
               MATCH_MP_TAC FLOAT_GREATEST_R_LE_0 THEN
               ASM_REWRITE_TAC[]]; ALL_TAC] THEN


       SUBGOAL_THEN `&0 <= &m' * &(flr fmt) ipow e' +
                       fround (to_fformat fmt e') m y`
         (LABEL_TAC "geq0") THENL [
           MATCH_MP_TAC REAL_LE_ADD THEN
           CONJ_TAC THENL [

             MATCH_MP_TAC REAL_LE_MUL THEN
             REWRITE_TAC[REAL_OF_NUM_LE] THEN
             CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
             REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];

             ASM_REWRITE_TAC[]]; ALL_TAC] THEN

        USE_THEN "geq0" (fun geq0 -> REWRITE_TAC[MATCH_MP
          (ARITH_RULE `&0 <= x ==> abs(x) = x`) geq0]) THEN

        GEN_REWRITE_TAC (RATOR_CONV o ONCE_DEPTH_CONV)
          [ARITH_RULE `x = x + &0`] THEN

        MATCH_MP_TAC REAL_LE_ADD2 THEN
        ASM_REWRITE_TAC[];


       (* x < 0 ... *)
       SUBGOAL_THEN `fround (to_fformat fmt e') m y <= &0`
         (LABEL_TAC "geq0_1") THENL [
           MATCH_MP_TAC FIXED_RD_LE_0_2 THEN
           CONJ_TAC THENL [

               MATCH_MP_TAC (ARITH_RULE `x < y ==> x <= (y:real)`) THEN
               USE_THEN "xneq0" (fun xneq0 -> dump_gr_info xneq0 "x") THEN
               REWRITE_TAC[GSYM (ASSUME `greatest_r(fmt) x = y`)] THEN
               REWRITE_TAC[GSYM (ASSUME `greatest_e(fmt) x = e'`)] THEN
               USE_THEN "xgreq" (fun xgreq -> REWRITE_TAC[xgreq]) THEN
               ASM_REWRITE_TAC[];

               REWRITE_TAC[GSYM (ASSUME `greatest_r(fmt) x = y`)] THEN
               MATCH_MP_TAC FLOAT_GREATEST_R_LE_0_2 THEN
               ASM_REWRITE_TAC[]]; ALL_TAC] THEN


       SUBGOAL_THEN `--(&m' * &(flr fmt) ipow e') +
                       fround (to_fformat fmt e') m y <= &0`
         (LABEL_TAC "geq0") THENL [
           REWRITE_TAC[
             ARITH_RULE `--(x:real) + y <= &0 <=> &0 <= x + (--y)`] THEN
           MATCH_MP_TAC REAL_LE_ADD THEN
           CONJ_TAC THENL [

             MATCH_MP_TAC REAL_LE_MUL THEN
             REWRITE_TAC[REAL_OF_NUM_LE] THEN
             CONJ_TAC THENL [ ARITH_TAC; ALL_TAC ] THEN
             REWRITE_TAC[FLFORMAT_RADIX_IPOW_LE_0];

             ASM_ARITH_TAC]; ALL_TAC] THEN

        USE_THEN "geq0" (fun geq0 -> REWRITE_TAC[MATCH_MP
          (ARITH_RULE `x <= &0 ==> abs(x) = -- x`) geq0]) THEN

        REWRITE_TAC[ARITH_RULE `-- ((-- (x:real)) + y) = x + (-- y)`] THEN

        GEN_REWRITE_TAC (RATOR_CONV o ONCE_DEPTH_CONV)
          [ARITH_RULE `x = x + &0`] THEN

        MATCH_MP_TAC REAL_LE_ADD2 THEN
        ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC]);;
