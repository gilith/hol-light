needs "lib/ssrbool.hl";;
needs "lib/ssrnat.hl";;
needs "arith/interval_arith.hl";;
needs "trig/matan.hl";;
needs "Multivariate/realanalysis.ml";;

(* Module Taylor_interval*)
module Taylor_interval = struct

open Ssreflect;;
open Ssrfun;;
open Ssrbool;;
open Ssrnat;;
open Interval_arith;;
open Matan;;
prioritize_real();;
let derivative = new_definition `derivative f = \y. @d. (f has_real_derivative d) (atreal y)`;;
let nth_derivative = new_definition `nth_derivative n f = iter n derivative f`;;
let nth_differentiable = define `(nth_differentiable 0 f x <=> f real_continuous atreal x) /\
	(nth_differentiable (SUC n) f x <=> nth_differentiable n f x /\ 
			nth_derivative n f real_differentiable atreal x)`;;
let nth_differentiable_on = new_definition `nth_differentiable_on n s f <=>
	!x. x IN s ==> nth_differentiable n f x`;;
let nth_differentiable_on_int = new_definition `nth_differentiable_on_int n int f <=>
	!x. interval_arith x int ==> nth_differentiable n f x`;;
let nth_diff_weak = new_definition `nth_diff_weak n f x <=> f real_continuous atreal x /\ 
	?F. F 0 = f /\ !i. i < n ==> (F i has_real_derivative F (SUC i) x) (atreal x)`;;
let nth_diff_strong = new_definition `nth_diff_strong n f x <=> 
	?s. real_open s /\ x IN s /\ nth_differentiable_on n s f`;;
let nth_diff_strong_int = new_definition `nth_diff_strong_int n int f <=>
	!x. interval_arith x int ==> nth_diff_strong n f x`;;

(* Section NthDerivatives *)
Sections.begin_section "NthDerivatives";;

(* Lemma derivative_eq_real_derivative *)
let derivative_eq_real_derivative = Sections.section_proof []
`derivative = real_derivative`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative", [derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_derivative", [real_derivative]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_derivative_cond *)
let has_derivative_cond = Sections.section_proof ["f";"x"]
`(?d. (f has_real_derivative d) (atreal x)) ==>
	(f has_real_derivative (derivative f x)) (atreal x)`
[
   (BETA_TAC THEN (case THEN (move ["d"])) THEN (move ["df"]));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`derivative f x = d`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) (exact_tac));
   (((((use_arg_then2 ("derivative", [derivative]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (((use_arg_then2 ("SELECT_UNIQUE", [SELECT_UNIQUE])) (thm_tac apply_tac)) THEN (simp_tac) THEN (move ["y"])) THEN ((THENL) (split_tac) [(move ["df2"]); ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)))]));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DERIVATIVE_UNIQUE_ATREAL", [REAL_DERIVATIVE_UNIQUE_ATREAL])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Lemma has_derivative_alt *)
let has_derivative_alt = Sections.section_proof ["f";"x"]
`f real_differentiable atreal x ==>
	(f has_real_derivative (derivative f x)) (atreal x)`
[
   (((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_derivative_cond", [has_derivative_cond])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma derivative_unique *)
let derivative_unique = Sections.section_proof ["f";"f'";"x"]
`(f has_real_derivative f') (atreal x) ==> derivative f x = f'`
[
   ((BETA_TAC THEN (move ["df"])) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DERIVATIVE_UNIQUE_ATREAL", [REAL_DERIVATIVE_UNIQUE_ATREAL])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_cond", [has_derivative_cond]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN ((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma derivative_unique_on *)
let derivative_unique_on = Sections.section_proof ["s";"f";"f'"]
`(!x. x IN s ==> (f has_real_derivative f' x) (atreal x)) ==>
	(!x. x IN s ==> f' x = derivative f x)`
[
   (BETA_TAC THEN (move ["df"]) THEN (move ["x"]) THEN (move ["xs"]));
   (((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_unique", [derivative_unique])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f' x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_derivative_lemma *)
let has_derivative_lemma = Sections.section_proof ["f";"f'";"x"]
`f real_differentiable atreal x /\
	derivative f x = f' ==>
	(f has_real_derivative f') (atreal x)`
[
   ((BETA_TAC THEN (case THEN ((move ["diff"]) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative0 *)
let nth_derivative0 = Sections.section_proof ["f"]
`nth_derivative 0 f = f`
[
   (((((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL iter)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_derivativeS *)
let nth_derivativeS = Sections.section_proof ["n";"f"]
`nth_derivative (SUC n) f = derivative (nth_derivative n f)`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("iterS", [iterS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_Sderivative *)
let nth_Sderivative = Sections.section_proof ["n";"f"]
`nth_derivative (SUC n) f = nth_derivative n (derivative f)`
[
   (((((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iterSr", [iterSr]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative", [nth_derivative]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma nth_derivative1 *)
let nth_derivative1 = Sections.section_proof ["f"]
`nth_derivative 1 f = derivative f`
[
   (((((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_derivative2 *)
let nth_derivative2 = Sections.section_proof ["f"]
`nth_derivative 2 f = derivative (derivative f)`
[
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 = SUC(SUC 0)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("iterS", [iterS]))(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL iter)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_derivative_add *)
let nth_derivative_add = Sections.section_proof ["n";"m";"f"]
`nth_derivative n (nth_derivative m f) = nth_derivative (n + m) f`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("iter_add", [iter_add]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_diff_continuous *)
let nth_diff_continuous = Sections.section_proof ["n";"f";"x"]
`nth_differentiable n f x ==>
	f real_continuous atreal x`
[
   (((THENL) (((use_arg_then2 ("n", [])) (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((((use_arg_then2 ("nth_differentiable", [nth_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((BETA_TAC THEN (case THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("IHn", [])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma nth_differentiable_cond *)
let nth_differentiable_cond = Sections.section_proof ["n";"f";"x"]
`nth_differentiable n f x ==>
   !i. i < n ==> (nth_derivative i f has_real_derivative (nth_derivative (SUC i) f x)) (atreal x)`
[
   ((THENL_FIRST) ((THENL) (((use_arg_then2 ("n", [])) (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) ((((use_arg_then2 ("ltn0", [ltn0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((((use_arg_then2 ("nth_differentiable", [nth_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("IHn", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["df_n"]) THEN (move ["dfn"]))) THEN (move ["i"]));
   (((((use_arg_then2 ("ltE", [ltE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leqSS", [leqSS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leq_eqVlt", [leq_eqVlt]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) case [(((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))); ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("df_n", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN ((TRY done_tac)))]));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_differentiable_on_cond *)
let nth_differentiable_on_cond = Sections.section_proof ["n";"s";"f"]
`nth_differentiable_on n s f ==>
 !x. x IN s ==> 
  !i. i < n ==> (nth_derivative i f has_real_derivative (nth_derivative (SUC i) f x)) (atreal x)`
[
   ((((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (move ["cond"]) THEN (move ["x"]));
   (((DISCH_THEN (fun snd_th -> (use_arg_then2 ("cond", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_differentiable_cond", [nth_differentiable_cond])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma nth_differentiable_eq *)
let nth_differentiable_eq = Sections.section_proof ["n";"f";"x"]
`nth_differentiable n f x <=>
  f real_continuous atreal x /\
  !i. i < n ==> (nth_derivative i f has_real_derivative (nth_derivative (SUC i) f x)) (atreal x)`
[
   ((THENL) (split_tac) [(move ["dn_f"]); (case THEN (move ["f_cont"]))]);
   (((((fun arg_tac -> (use_arg_then2 ("nth_diff_continuous", [nth_diff_continuous])) (fun fst_arg -> (use_arg_then2 ("dn_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_differentiable_cond", [nth_differentiable_cond])) (disch_tac [])) THEN (clear_assumption "nth_differentiable_cond") THEN (exact_tac)) THEN (done_tac));
   (((THENL) (((use_arg_then2 ("n", [])) (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN (((((use_arg_then2 ("nth_differentiable", [nth_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("ltE", [ltE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leqSS", [leqSS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leq_eqVlt", [leq_eqVlt]))(thm_tac (new_rewrite [] []))))) THEN (move ["cond"])));
   ((THENL_FIRST) ((((use_arg_then2 ("IHn", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((BETA_TAC THEN (move ["i"]) THEN (move ["i_lt_n"])) THEN (((use_arg_then2 ("cond", [])) (disch_tac [])) THEN (clear_assumption "cond") THEN (DISCH_THEN apply_tac)) THEN (done_tac)));
   ((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC n) f x`))) (term_tac exists_tac)));
   (((use_arg_then2 ("cond", [])) (disch_tac [])) THEN (clear_assumption "cond") THEN (exact_tac));
];;

(* Lemma nth_differentiable_on_int2 *)
let nth_differentiable_on_int2 = Sections.section_proof ["f";"int"]
`nth_differentiable_on_int 2 int f ==>
	?f' f''. f' = derivative f /\ f'' = nth_derivative 2 f /\
		!x. interval_arith x int ==> (f has_real_derivative f' x) (atreal x) /\
					(f' has_real_derivative f'' x) (atreal x)`
[
   ((((use_arg_then2 ("nth_differentiable_on_int", [nth_differentiable_on_int]))(thm_tac (new_rewrite [] [])))) THEN (move ["h"]));
   ((((fun arg_tac -> arg_tac (Arg_term (`derivative f`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`nth_derivative 2 f`))) (term_tac exists_tac))) THEN (simp_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then2 ("nth_derivative0", [nth_derivative0])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [1] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 = SUC 1`)))(thm_tac (new_rewrite [] [])))));
   (((repeat_tactic 1 9 (((fun arg_tac -> (use_arg_then2 ("nth_differentiable_cond", [nth_differentiable_cond])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("h", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma nth_mth_diff *)
let nth_mth_diff = Sections.section_proof ["n";"m";"f";"x"]
`n <= m ==> nth_differentiable m f x ==> nth_differentiable n f x`
[
   ((BETA_TAC THEN (move ["n_le_m"])) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (move ["cond"])))) THEN ((((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (move ["i"]) THEN (move ["i_lt"])));
   ((((use_arg_then2 ("cond", [])) (disch_tac [])) THEN (clear_assumption "cond") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("n_le_m", [])) (disch_tac [])) THEN (clear_assumption "n_le_m") THEN ((use_arg_then2 ("ltn_leq_trans", [ltn_leq_trans])) (disch_tac [])) THEN (clear_assumption "ltn_leq_trans") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Lemma nth_differentiable1 *)
let nth_differentiable1 = Sections.section_proof ["f";"x"]
`nth_differentiable 1 f x <=> f real_differentiable atreal x`
[
   (((((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL nth_differentiable)))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [(((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))); (move ["df"])]));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_diff_imp_diff *)
let nth_diff_imp_diff = Sections.section_proof ["n";"f";"x"]
`0 < n ==> nth_differentiable n f x ==>
	f real_differentiable atreal x`
[
   ((((((use_arg_then2 ("ltE", [ltE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["ineq"]) THEN (move ["df"])) THEN (((use_arg_then2 ("nth_differentiable1", [nth_differentiable1]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_mth_diff", [nth_mth_diff])) (disch_tac [])) THEN (clear_assumption "nth_mth_diff") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("n", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma nth_derivative_continuous *)
let nth_derivative_continuous = Sections.section_proof ["n";"f";"x";"i"]
`nth_differentiable n f x ==> i < n ==>
	nth_derivative i f real_continuous atreal x`
[
   ((((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (move ["df"]));
   (((DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (move ["cond"])) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC i) f x`))) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma ith_derivative_differentiable *)
let ith_derivative_differentiable = Sections.section_proof ["i";"n";"f";"x"]
`nth_differentiable n f x ==> i < n ==>
	nth_differentiable (n - i) (nth_derivative i f) x`
[
   (BETA_TAC THEN (move ["dnf"]));
   ((((use_arg_then2 ("dnf", [])) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (move ["cond"]) THEN (move ["i_lt_n"])));
   (((((fun arg_tac -> (use_arg_then2 ("nth_derivative_continuous", [nth_derivative_continuous])) (fun fst_arg -> (use_arg_then2 ("dnf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["j"]) THEN (move ["j_lt_ni"]));
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative_add", [nth_derivative_add]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("addSn", [addSn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("cond", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("j_lt_ni", [])) (disch_tac [])) THEN (clear_assumption "j_lt_ni") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma nth_diff_strong_imp_diff *)
let nth_diff_strong_imp_diff = Sections.section_proof ["n";"f";"x"]
`nth_diff_strong n f x ==>	nth_differentiable n f x`
[
   (((((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"]))) THEN ((((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (move ["h"])));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Section DerivativeArith *)
Sections.begin_section "DerivativeArith";;

(* Section ElementaryDerivatives *)
Sections.begin_section "ElementaryDerivatives";;

(* Lemma HAS_REAL_DERIVATIVE_ABS_POS *)
let HAS_REAL_DERIVATIVE_ABS_POS = Sections.section_proof ["x"]
`&0 < x ==> (abs has_real_derivative &1) (atreal x)`
[
   (BETA_TAC THEN (move ["x_pos"]));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL", [HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL") THEN (DISCH_THEN apply_tac));
   ((((fun arg_tac -> arg_tac (Arg_term (`\x. x`))) (term_tac exists_tac)) THEN ((use_arg_then2 ("x", [])) (term_tac exists_tac))) THEN (((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("x_pos", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["t"])));
   ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma HAS_REAL_DERIVATIVE_ABS_NEG *)
let HAS_REAL_DERIVATIVE_ABS_NEG = Sections.section_proof ["x"]
`x < &0 ==> (abs has_real_derivative (-- &1)) (atreal x)`
[
   (BETA_TAC THEN (move ["x_neg"]));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL", [HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL") THEN (DISCH_THEN apply_tac));
   ((((fun arg_tac -> arg_tac (Arg_term (`\x. --x`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`--x`))) (term_tac exists_tac))) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_NEG", [HAS_REAL_DERIVATIVE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   ((THENL_FIRST) (split_tac) ((((use_arg_then2 ("x_neg", [])) (disch_tac [])) THEN (clear_assumption "x_neg") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((BETA_TAC THEN (move ["t"])) THEN (((use_arg_then2 ("x_neg", [])) (disch_tac [])) THEN (clear_assumption "x_neg") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma derivative_x *)
let derivative_x = Sections.section_proof []
`derivative (\x. x) = (\x. &1)`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_const *)
let derivative_const = Sections.section_proof ["c"]
`derivative (\x. c) = (\x. &0)`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_abs_pos *)
let derivative_abs_pos = Sections.section_proof ["x"]
`&0 < x ==> derivative abs x = &1`
[
   (BETA_TAC THEN (move ["x_pos"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ABS_POS", [HAS_REAL_DERIVATIVE_ABS_POS]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_abs_neg *)
let derivative_abs_neg = Sections.section_proof ["x"]
`x < &0 ==> derivative abs x = -- &1`
[
   (BETA_TAC THEN (move ["x_neg"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ABS_NEG", [HAS_REAL_DERIVATIVE_ABS_NEG]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_pow_x *)
let derivative_pow_x = Sections.section_proof ["n"]
`derivative (\x. x pow n) = (\x. &n * x pow (n - 1))`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac)) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(gsym_then (thm_tac (new_rewrite [] [(`x pow (n - 1)`)]))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_POW_ATREAL", [HAS_REAL_DERIVATIVE_POW_ATREAL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_pow2_x *)
let derivative_pow2_x = Sections.section_proof []
`derivative (\x. x pow 2) = (\x. &2 * x)`
[
   (((((use_arg_then2 ("derivative_pow_x", [derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 - 1 = 1`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_pow3_x *)
let derivative_pow3_x = Sections.section_proof []
`derivative (\x. x pow 3) = (\x. &3 * x pow 2)`
[
   (((((use_arg_then2 ("derivative_pow_x", [derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 - 1 = 2`)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_inv *)
let derivative_inv = Sections.section_proof ["x"]
`~(x = &0) ==> derivative inv x = -- inv (x * x)`
[
   (BETA_TAC THEN (move ["xn0"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_INV_BASIC", [HAS_REAL_DERIVATIVE_INV_BASIC]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_atn *)
let derivative_atn = Sections.section_proof []
`derivative atn = (\x. inv (&1 + x * x))`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATN", [HAS_REAL_DERIVATIVE_ATN]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_exp *)
let derivative_exp = Sections.section_proof []
`derivative exp = exp`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_EXP", [HAS_REAL_DERIVATIVE_EXP]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_log *)
let derivative_log = Sections.section_proof ["x"]
`&0 < x ==> derivative log x = inv x`
[
   ((BETA_TAC THEN (move ["x_ineq"])) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOG", [HAS_REAL_DERIVATIVE_LOG]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_sin *)
let derivative_sin = Sections.section_proof []
`derivative sin = cos`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_SIN", [HAS_REAL_DERIVATIVE_SIN]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_cos *)
let derivative_cos = Sections.section_proof []
`derivative cos = (\x. --sin x)`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_COS", [HAS_REAL_DERIVATIVE_COS]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_asn *)
let derivative_asn = Sections.section_proof ["x"]
`abs x < &1 ==> derivative asn x = inv(sqrt(&1 - x * x))`
[
   (BETA_TAC THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ASN", [HAS_REAL_DERIVATIVE_ASN]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_acs *)
let derivative_acs = Sections.section_proof ["x"]
`abs x < &1 ==> derivative acs x = --inv(sqrt(&1 - x * x))`
[
   (BETA_TAC THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ACS", [HAS_REAL_DERIVATIVE_ACS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_sqrt *)
let derivative_sqrt = Sections.section_proof ["x"]
`&0 < x ==> derivative sqrt x = inv (&2 * sqrt x)`
[
   (BETA_TAC THEN (move ["xg0"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_SQRT", [HAS_REAL_DERIVATIVE_SQRT]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_matan *)
let derivative_matan = Sections.section_proof ["x"]
`derivative matan x = dmatan x`
[
   (((((use_arg_then2 ("derivative_eq_real_derivative", [derivative_eq_real_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dmatan", [dmatan]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma matan_differentiable *)
let matan_differentiable = Sections.section_proof ["x"]
`-- &1 < x ==> matan real_differentiable atreal x`
[
   (BETA_TAC THEN (move ["x_ineq"]));
   (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x < &1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (move ["x_ineq2"]));
   ((((use_arg_then2 ("matan_real_derivative_abs1", [matan_real_derivative_abs1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("x_ineq2", [])) (disch_tac [])) THEN (clear_assumption "x_ineq2") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))));
   ((fun arg_tac -> (use_arg_then2 ("matan_has_derivative_gt0", [matan_has_derivative_gt0])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   ((fun arg_tac -> arg_tac (Arg_term (`inv _1 - _2`))) (term_tac (set_tac "t")));
   ((BETA_TAC THEN (move ["h"])) THEN ((use_arg_then2 ("t", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("x_ineq2", [])) (disch_tac [])) THEN (clear_assumption "x_ineq2") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma derivative_composition *)
let derivative_composition = Sections.section_proof ["f";"g";"x"]
`f real_differentiable atreal x ==>
	g real_differentiable atreal (f x) ==>
	derivative (\x. g (f x)) x = derivative f x * derivative g (f x)`
[
   ((BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_derivative_alt", [has_derivative_alt])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["df"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_derivative_alt", [has_derivative_alt])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["dg"])) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)));
   ((THENL_FIRST) (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL HAS_REAL_DERIVATIVE_CHAIN))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`derivative f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`derivative g`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`\y. y = f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN (ANTS_TAC)) ((BETA_TAC THEN (move ["y"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((BETA_TAC THEN (case THEN (move ["_"]))) THEN (DISCH_THEN apply_tac) THEN (done_tac));
];;

(* Section ElementaryCompose *)
Sections.begin_section "ElementaryCompose";;

(* Lemma REAL_DIFFERENTIABLE_AT_INV *)
let REAL_DIFFERENTIABLE_AT_INV = Sections.section_proof ["x"]
`~(x = &0) ==> inv real_differentiable atreal x`
[
   (BETA_TAC THEN (move ["xn0"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(\x. x:real)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (((simp_tac) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xn0", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma REAL_DIFFERENTIABLE_AT_ABS_POS *)
let REAL_DIFFERENTIABLE_AT_ABS_POS = Sections.section_proof ["x"]
`&0 < x ==> abs real_differentiable atreal x`
[
   (BETA_TAC THEN (move ["x_pos"]));
   ((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`&1`))) (term_tac exists_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ABS_POS", [HAS_REAL_DERIVATIVE_ABS_POS]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma REAL_DIFFERENTIABLE_AT_ABS_NEG *)
let REAL_DIFFERENTIABLE_AT_ABS_NEG = Sections.section_proof ["x"]
`x < &0 ==> abs real_differentiable atreal x`
[
   (BETA_TAC THEN (move ["x_pos"]));
   ((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`-- &1`))) (term_tac exists_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ABS_NEG", [HAS_REAL_DERIVATIVE_ABS_NEG]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real->real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;
(Sections.add_section_hyp "df" (`f real_differentiable atreal x`));;

(* Lemma derivative_compose_abs_pos *)
let derivative_compose_abs_pos = Sections.section_proof []
`&0 < f x ==> (\x. abs (f x)) real_differentiable atreal x /\
	derivative (\x. abs (f x)) x = derivative f x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`abs`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ABS_POS", [REAL_DIFFERENTIABLE_AT_ABS_POS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ABS_POS", [REAL_DIFFERENTIABLE_AT_ABS_POS]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_abs_pos", [derivative_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_abs_neg *)
let derivative_compose_abs_neg = Sections.section_proof []
`f x < &0 ==> (\x. abs (f x)) real_differentiable atreal x /\
	derivative (\x. abs (f x)) x = --derivative f x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`abs`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ABS_NEG", [REAL_DIFFERENTIABLE_AT_ABS_NEG]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ABS_NEG", [REAL_DIFFERENTIABLE_AT_ABS_NEG]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_abs_neg", [derivative_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RNEG", [REAL_MUL_RNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_pow *)
let derivative_compose_pow = Sections.section_proof ["n"]
`(\x. (f x) pow n) real_differentiable atreal x /\
	derivative (\x. (f x) pow n) x = &n * (f x) pow (n - 1) * derivative f x`
[
   ((THENL_FIRST) (split_tac) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_POW_ATREAL", [REAL_DIFFERENTIABLE_POW_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_POW_ATREAL", [HAS_REAL_DERIVATIVE_POW_ATREAL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_compose_pow2 *)
let derivative_compose_pow2 = Sections.section_proof []
`(\x. (f x) pow 2) real_differentiable atreal x /\
	derivative (\x. (f x) pow 2) x = &2 * f x * derivative f x`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("derivative_compose_pow", [derivative_compose_pow]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 - 1 = 1`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_pow3 *)
let derivative_compose_pow3 = Sections.section_proof []
`(\x. (f x) pow 3) real_differentiable atreal x /\
	derivative (\x. (f x) pow 3) x = &3 * (f x pow 2) * derivative f x`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("derivative_compose_pow", [derivative_compose_pow]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 - 1 = 2`)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_atn *)
let derivative_compose_atn = Sections.section_proof []
`(\x. atn (f x)) real_differentiable atreal x /\
	derivative (\x. atn (f x)) x = derivative f x / (&1 + f x * f x)`
[
   (split_tac);
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`atn`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ATN", [REAL_DIFFERENTIABLE_AT_ATN]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ATN", [REAL_DIFFERENTIABLE_AT_ATN]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_atn", [derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_exp *)
let derivative_compose_exp = Sections.section_proof []
`(\x. exp (f x)) real_differentiable atreal x /\
	derivative (\x. exp (f x)) x = exp (f x) * derivative f x`
[
   (split_tac);
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`exp`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_EXP", [REAL_DIFFERENTIABLE_AT_EXP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_EXP", [REAL_DIFFERENTIABLE_AT_EXP]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_exp", [derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_log *)
let derivative_compose_log = Sections.section_proof []
`&0 < f x ==> (\x. log (f x)) real_differentiable atreal x /\
	derivative (\x. log (f x)) x = derivative f x / f x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`log`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_LOG", [REAL_DIFFERENTIABLE_AT_LOG]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_LOG", [REAL_DIFFERENTIABLE_AT_LOG]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_log", [derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_cos *)
let derivative_compose_cos = Sections.section_proof []
`(\x. cos (f x)) real_differentiable atreal x /\
	derivative (\x. cos (f x)) x = --(sin (f x) * derivative f x)`
[
   (split_tac);
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`cos`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_COS", [REAL_DIFFERENTIABLE_AT_COS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_COS", [REAL_DIFFERENTIABLE_AT_COS]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_NEG_LMUL", [REAL_NEG_LMUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_sin *)
let derivative_compose_sin = Sections.section_proof []
`(\x. sin (f x)) real_differentiable atreal x /\
	derivative (\x. sin (f x)) x = cos (f x) * derivative f x`
[
   (split_tac);
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sin`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SIN", [REAL_DIFFERENTIABLE_AT_SIN]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SIN", [REAL_DIFFERENTIABLE_AT_SIN]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_inv *)
let derivative_compose_inv = Sections.section_proof []
`~(f x = &0) ==>
	(\x. inv (f x)) real_differentiable atreal x /\
	derivative (\x. inv (f x)) x = -- inv (f x * f x) * derivative f x`
[
   ((THENL_FIRST) ((BETA_TAC THEN (move ["fn0"])) THEN (split_tac)) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_INV_ATREAL") THEN (DISCH_THEN apply_tac)) THEN (done_tac)));
   (((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("derivative_inv", [derivative_inv]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_INV", [REAL_DIFFERENTIABLE_AT_INV]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_sqrt *)
let derivative_compose_sqrt = Sections.section_proof []
`&0 < f x ==>
	(\x. sqrt (f x)) real_differentiable atreal x /\
	derivative (\x. sqrt (f x)) x = derivative f x / (&2 * sqrt (f x))`
[
   ((BETA_TAC THEN (move ["f_pos"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sqrt`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_AT_SQRT") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_sqrt", [derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_acs *)
let derivative_compose_acs = Sections.section_proof []
`abs (f x) < &1 ==>
	(\x. acs (f x)) real_differentiable atreal x /\
	derivative (\x. acs (f x)) x = -- (derivative f x / sqrt (&1 - f x * f x))`
[
   ((BETA_TAC THEN (move ["f_abs"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`acs`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ACS", [REAL_DIFFERENTIABLE_AT_ACS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ACS", [REAL_DIFFERENTIABLE_AT_ACS]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_acs", [derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RNEG", [REAL_MUL_RNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_asn *)
let derivative_compose_asn = Sections.section_proof []
`abs (f x) < &1 ==>
	(\x. asn (f x)) real_differentiable atreal x /\
	derivative (\x. asn (f x)) x = derivative f x / sqrt (&1 - f x * f x)`
[
   ((BETA_TAC THEN (move ["f_abs"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`asn`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ASN", [REAL_DIFFERENTIABLE_AT_ASN]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ASN", [REAL_DIFFERENTIABLE_AT_ASN]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_asn", [derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_matan *)
let derivative_compose_matan = Sections.section_proof []
`-- &1 < f x ==>
	(\x. matan (f x)) real_differentiable atreal x /\
	derivative (\x. matan (f x)) x = dmatan (f x) * derivative f x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`matan`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("matan_differentiable", [matan_differentiable]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("matan_differentiable", [matan_differentiable]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_matan", [derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section ElementaryCompose *)
let REAL_DIFFERENTIABLE_AT_INV = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_INV;;
let REAL_DIFFERENTIABLE_AT_ABS_POS = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_ABS_POS;;
let REAL_DIFFERENTIABLE_AT_ABS_NEG = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_ABS_NEG;;
let derivative_compose_abs_pos = Sections.finalize_theorem derivative_compose_abs_pos;;
let derivative_compose_abs_neg = Sections.finalize_theorem derivative_compose_abs_neg;;
let derivative_compose_pow = Sections.finalize_theorem derivative_compose_pow;;
let derivative_compose_pow2 = Sections.finalize_theorem derivative_compose_pow2;;
let derivative_compose_pow3 = Sections.finalize_theorem derivative_compose_pow3;;
let derivative_compose_atn = Sections.finalize_theorem derivative_compose_atn;;
let derivative_compose_exp = Sections.finalize_theorem derivative_compose_exp;;
let derivative_compose_log = Sections.finalize_theorem derivative_compose_log;;
let derivative_compose_cos = Sections.finalize_theorem derivative_compose_cos;;
let derivative_compose_sin = Sections.finalize_theorem derivative_compose_sin;;
let derivative_compose_inv = Sections.finalize_theorem derivative_compose_inv;;
let derivative_compose_sqrt = Sections.finalize_theorem derivative_compose_sqrt;;
let derivative_compose_acs = Sections.finalize_theorem derivative_compose_acs;;
let derivative_compose_asn = Sections.finalize_theorem derivative_compose_asn;;
let derivative_compose_matan = Sections.finalize_theorem derivative_compose_matan;;
Sections.end_section "ElementaryCompose";;

(* Finalization of the section ElementaryDerivatives *)
let HAS_REAL_DERIVATIVE_ABS_POS = Sections.finalize_theorem HAS_REAL_DERIVATIVE_ABS_POS;;
let HAS_REAL_DERIVATIVE_ABS_NEG = Sections.finalize_theorem HAS_REAL_DERIVATIVE_ABS_NEG;;
let derivative_x = Sections.finalize_theorem derivative_x;;
let derivative_const = Sections.finalize_theorem derivative_const;;
let derivative_abs_pos = Sections.finalize_theorem derivative_abs_pos;;
let derivative_abs_neg = Sections.finalize_theorem derivative_abs_neg;;
let derivative_pow_x = Sections.finalize_theorem derivative_pow_x;;
let derivative_pow2_x = Sections.finalize_theorem derivative_pow2_x;;
let derivative_pow3_x = Sections.finalize_theorem derivative_pow3_x;;
let derivative_inv = Sections.finalize_theorem derivative_inv;;
let derivative_atn = Sections.finalize_theorem derivative_atn;;
let derivative_exp = Sections.finalize_theorem derivative_exp;;
let derivative_log = Sections.finalize_theorem derivative_log;;
let derivative_sin = Sections.finalize_theorem derivative_sin;;
let derivative_cos = Sections.finalize_theorem derivative_cos;;
let derivative_asn = Sections.finalize_theorem derivative_asn;;
let derivative_acs = Sections.finalize_theorem derivative_acs;;
let derivative_sqrt = Sections.finalize_theorem derivative_sqrt;;
let derivative_matan = Sections.finalize_theorem derivative_matan;;
let matan_differentiable = Sections.finalize_theorem matan_differentiable;;
let derivative_composition = Sections.finalize_theorem derivative_composition;;
let REAL_DIFFERENTIABLE_AT_INV = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_INV;;
let REAL_DIFFERENTIABLE_AT_ABS_POS = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_ABS_POS;;
let REAL_DIFFERENTIABLE_AT_ABS_NEG = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_ABS_NEG;;
let derivative_compose_abs_pos = Sections.finalize_theorem derivative_compose_abs_pos;;
let derivative_compose_abs_neg = Sections.finalize_theorem derivative_compose_abs_neg;;
let derivative_compose_pow = Sections.finalize_theorem derivative_compose_pow;;
let derivative_compose_pow2 = Sections.finalize_theorem derivative_compose_pow2;;
let derivative_compose_pow3 = Sections.finalize_theorem derivative_compose_pow3;;
let derivative_compose_atn = Sections.finalize_theorem derivative_compose_atn;;
let derivative_compose_exp = Sections.finalize_theorem derivative_compose_exp;;
let derivative_compose_log = Sections.finalize_theorem derivative_compose_log;;
let derivative_compose_cos = Sections.finalize_theorem derivative_compose_cos;;
let derivative_compose_sin = Sections.finalize_theorem derivative_compose_sin;;
let derivative_compose_inv = Sections.finalize_theorem derivative_compose_inv;;
let derivative_compose_sqrt = Sections.finalize_theorem derivative_compose_sqrt;;
let derivative_compose_acs = Sections.finalize_theorem derivative_compose_acs;;
let derivative_compose_asn = Sections.finalize_theorem derivative_compose_asn;;
let derivative_compose_matan = Sections.finalize_theorem derivative_compose_matan;;
Sections.end_section "ElementaryDerivatives";;
(Sections.add_section_var (mk_var ("f", (`:real -> real`))); Sections.add_section_var (mk_var ("g", (`:real -> real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))); Sections.add_section_var (mk_var ("c", (`:real`))));;
(Sections.add_section_hyp "df" (`f real_differentiable atreal x`));;

(* Lemma derivative_scale *)
let derivative_scale = Sections.section_proof []
`derivative (\x. c * f x) x = c * derivative f x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_neg *)
let derivative_neg = Sections.section_proof []
`derivative (\x. -- f x) x = -- derivative f x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_NEG", [HAS_REAL_DERIVATIVE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_pow *)
let derivative_pow = Sections.section_proof ["n"]
`derivative (\x. f x pow n) x = &n * f x pow (n - 1) * derivative f x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_POW_ATREAL", [HAS_REAL_DERIVATIVE_POW_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_hyp "dg" (`g real_differentiable atreal x`));;

(* Lemma derivative_add *)
let derivative_add = Sections.section_proof []
`derivative (\x. f x + g x) x = derivative f x + derivative g x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma derivative_mul *)
let derivative_mul = Sections.section_proof []
`derivative (\x. f x * g x) x = f x * derivative g x + derivative f x * g x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_MUL_ATREAL", [HAS_REAL_DERIVATIVE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma derivative_sub *)
let derivative_sub = Sections.section_proof []
`derivative (\x. f x - g x) x = derivative f x - derivative g x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_SUB", [HAS_REAL_DERIVATIVE_SUB]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma derivative_div *)
let derivative_div = Sections.section_proof []
`~(g x = &0) ==> 
  derivative (\x. f x / g x) x = (derivative f x * g x - f x * derivative g x) / (g x * g x)`
[
   ((BETA_TAC THEN (move ["gn0"])) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_DIV_ATREAL", [HAS_REAL_DERIVATIVE_DIV_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section DerivativeArith *)
let HAS_REAL_DERIVATIVE_ABS_POS = Sections.finalize_theorem HAS_REAL_DERIVATIVE_ABS_POS;;
let HAS_REAL_DERIVATIVE_ABS_NEG = Sections.finalize_theorem HAS_REAL_DERIVATIVE_ABS_NEG;;
let derivative_x = Sections.finalize_theorem derivative_x;;
let derivative_const = Sections.finalize_theorem derivative_const;;
let derivative_abs_pos = Sections.finalize_theorem derivative_abs_pos;;
let derivative_abs_neg = Sections.finalize_theorem derivative_abs_neg;;
let derivative_pow_x = Sections.finalize_theorem derivative_pow_x;;
let derivative_pow2_x = Sections.finalize_theorem derivative_pow2_x;;
let derivative_pow3_x = Sections.finalize_theorem derivative_pow3_x;;
let derivative_inv = Sections.finalize_theorem derivative_inv;;
let derivative_atn = Sections.finalize_theorem derivative_atn;;
let derivative_exp = Sections.finalize_theorem derivative_exp;;
let derivative_log = Sections.finalize_theorem derivative_log;;
let derivative_sin = Sections.finalize_theorem derivative_sin;;
let derivative_cos = Sections.finalize_theorem derivative_cos;;
let derivative_asn = Sections.finalize_theorem derivative_asn;;
let derivative_acs = Sections.finalize_theorem derivative_acs;;
let derivative_sqrt = Sections.finalize_theorem derivative_sqrt;;
let derivative_matan = Sections.finalize_theorem derivative_matan;;
let matan_differentiable = Sections.finalize_theorem matan_differentiable;;
let derivative_composition = Sections.finalize_theorem derivative_composition;;
let REAL_DIFFERENTIABLE_AT_INV = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_INV;;
let REAL_DIFFERENTIABLE_AT_ABS_POS = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_ABS_POS;;
let REAL_DIFFERENTIABLE_AT_ABS_NEG = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_ABS_NEG;;
let derivative_compose_abs_pos = Sections.finalize_theorem derivative_compose_abs_pos;;
let derivative_compose_abs_neg = Sections.finalize_theorem derivative_compose_abs_neg;;
let derivative_compose_pow = Sections.finalize_theorem derivative_compose_pow;;
let derivative_compose_pow2 = Sections.finalize_theorem derivative_compose_pow2;;
let derivative_compose_pow3 = Sections.finalize_theorem derivative_compose_pow3;;
let derivative_compose_atn = Sections.finalize_theorem derivative_compose_atn;;
let derivative_compose_exp = Sections.finalize_theorem derivative_compose_exp;;
let derivative_compose_log = Sections.finalize_theorem derivative_compose_log;;
let derivative_compose_cos = Sections.finalize_theorem derivative_compose_cos;;
let derivative_compose_sin = Sections.finalize_theorem derivative_compose_sin;;
let derivative_compose_inv = Sections.finalize_theorem derivative_compose_inv;;
let derivative_compose_sqrt = Sections.finalize_theorem derivative_compose_sqrt;;
let derivative_compose_acs = Sections.finalize_theorem derivative_compose_acs;;
let derivative_compose_asn = Sections.finalize_theorem derivative_compose_asn;;
let derivative_compose_matan = Sections.finalize_theorem derivative_compose_matan;;
let derivative_scale = Sections.finalize_theorem derivative_scale;;
let derivative_neg = Sections.finalize_theorem derivative_neg;;
let derivative_pow = Sections.finalize_theorem derivative_pow;;
let derivative_add = Sections.finalize_theorem derivative_add;;
let derivative_mul = Sections.finalize_theorem derivative_mul;;
let derivative_sub = Sections.finalize_theorem derivative_sub;;
let derivative_div = Sections.finalize_theorem derivative_div;;
Sections.end_section "DerivativeArith";;

(* Section MoreDerivativeArith *)
Sections.begin_section "MoreDerivativeArith";;

(* Lemma differentiable_sum_numseg *)
let differentiable_sum_numseg = Sections.section_proof ["G";"n";"m";"x"]
`(!i. i IN n..m ==> G i real_differentiable atreal x) ==>
	(\x. sum (n..m) (\i. G i x)) real_differentiable atreal x`
[
   ((((THENL) (((use_arg_then2 ("m", [])) (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((move ["m"]) THEN (move ["IHm"]))]) THEN (move ["dG"])) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n = 0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["n_eq_0"])) THEN ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("dG", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("n_eq_0", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((THENL_ROT (-1)) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n <= SUC m`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["n_le_Sm"])));
   ((((use_arg_then2 ("IHm", [])) (disch_tac [])) THEN (clear_assumption "IHm") THEN (DISCH_THEN apply_tac) THEN (move ["i"]) THEN (move ["i_in"])) THEN (((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_ADD", [REAL_DIFFERENTIABLE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then2 ("dG", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IHm", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("n_le_Sm", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["ineq"])) THEN (((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma derivative_sum_numseg *)
let derivative_sum_numseg = Sections.section_proof ["G";"n";"m";"x"]
`(!i. i IN n..m ==> G i real_differentiable atreal x) ==>
	derivative (\x. sum (n..m) (\i. G i x)) x = sum (n..m) (\i. derivative (G i) x)`
[
   ((((THENL) (((use_arg_then2 ("m", [])) (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((move ["m"]) THEN (move ["IHm"]))]) THEN (move ["dG"])) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_term (`n = 0`))) (disch_tac [])) THEN case THEN (simp_tac)) THEN ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((THENL_ROT (-1)) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n <= SUC m`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["n_le_Sm"])));
   ((((use_arg_then2 ("IHm", [])) (disch_tac [])) THEN (clear_assumption "IHm") THEN (DISCH_THEN apply_tac) THEN (move ["i"]) THEN (move ["i_in"])) THEN (((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((use_arg_then2 ("IHm", []))(gsym_then (thm_tac (new_rewrite [] [])))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_in"])) THEN (((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac));
   ((((use_arg_then2 ("derivative_add", [derivative_add]))(thm_tac (new_rewrite [] [])))) THEN ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("dG", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("differentiable_sum_numseg", [differentiable_sum_numseg]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_in"]));
   ((((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section MoreDerivativeArith *)
let differentiable_sum_numseg = Sections.finalize_theorem differentiable_sum_numseg;;
let derivative_sum_numseg = Sections.finalize_theorem derivative_sum_numseg;;
Sections.end_section "MoreDerivativeArith";;

(* Lemma HAS_REAL_DERIVATIVE_LOCAL *)
let HAS_REAL_DERIVATIVE_LOCAL = Sections.section_proof ["f";"g";"x";"g'"]
`(g has_real_derivative g') (atreal x) /\
	(?s. real_open s /\ x IN s /\ (!y. y IN s ==> f y = g y))
	==> (f has_real_derivative g') (atreal x)`
[
   (BETA_TAC THEN (case THEN (move ["dg"])) THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["f_eq_g"]));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((fun arg_tac -> (use_arg_then2 ("HAS_REAL_DERIVATIVE_WITHIN_REAL_OPEN", [HAS_REAL_DERIVATIVE_WITHIN_REAL_OPEN])) (fun fst_arg -> (use_arg_then2 ("open_s", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((TRY done_tac))) THEN (move ["dg"])));
   (((fun arg_tac -> (use_arg_then2 ("HAS_REAL_DERIVATIVE_TRANSFORM_WITHIN", [HAS_REAL_DERIVATIVE_TRANSFORM_WITHIN])) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`&1`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_LT_01", [REAL_LT_01]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN ALL_TAC) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("f_eq_g", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma differentiable_local *)
let differentiable_local = Sections.section_proof ["f";"g";"x";"s"]
`g real_differentiable atreal x /\ real_open s /\ x IN s /\
	(!y. y IN s ==> f y = g y) ==> f real_differentiable atreal x`
[
   ((repeat_tactic 1 9 (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["f'"])) THEN (move ["dg"]) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["eq"]));
   (((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((use_arg_then2 ("g", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Section NthDerivativeArith *)
Sections.begin_section "NthDerivativeArith";;
(Sections.add_section_var (mk_var ("f", (`:real->real`))); Sections.add_section_var (mk_var ("g", (`:real->real`))));;
(Sections.add_section_var (mk_var ("int", (`:real#real`))));;
(Sections.add_section_var (mk_var ("n", (`:num`))));;
(Sections.add_section_hyp "df" (`nth_diff_strong_int n int f`));;

(* Lemma nth_derivative_scale_strong *)
let nth_derivative_scale_strong = Sections.section_proof ["c";"i";"x"]
`interval_arith x int ==> i <= n ==>
	?s. real_open s /\ x IN s /\ 
	!y. y IN s ==> nth_derivative i (\y. c * f y) y = c * nth_derivative i f y`
[
   ((((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (move ["df"])));
   (((DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"]))) THEN (((((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN (move ["diff"])));
   ((THENL_FIRST) ((THENL) (((use_arg_then2 ("i", [])) (disch_tac [])) THEN (clear_assumption "i") THEN elim) [(move ["_"]); ((move ["i"]) THEN (move ["IHi"]))]) ((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["i_lt_n"]));
   ((((fun arg_tac -> (use_arg_then2 ("IHi", [])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("ltnW", [ltnW])) (fun fst_arg -> (use_arg_then2 ("i_lt_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["eq"])) THEN (((use_arg_then2 ("IHi", [])) (disch_tac [])) THEN (clear_assumption "IHi") THEN BETA_TAC THEN (move ["_"])));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER t`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (move ["yt"])))));
   (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`\y. c * nth_derivative i f y`))) (term_tac exists_tac));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((fun arg_tac -> (use_arg_then2 ("diff", [])) (fun fst_arg -> (use_arg_then2 ("ys", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER t`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("yt", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["z_in"]) THEN (simp_tac)));
   ((((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_scale_strong_all *)
let nth_derivative_scale_strong_all = Sections.section_proof ["c";"x"]
`interval_arith x int ==>
	?s. real_open s /\ x IN s /\ 
	!i y. i <= n /\ y IN s ==> nth_derivative i (\y. c * f y) y = c * nth_derivative i f y`
[
   (BETA_TAC THEN (DISCH_THEN (fun snd_th -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_scale_strong", [nth_derivative_scale_strong])) (fun fst_arg -> (use_arg_then2 ("c", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   ((fun arg_tac -> arg_tac (Arg_term (`\i s. real_open s /\ x IN s /\ 
	(!y. y IN s ==> nth_derivative i (\y. c * f y) y = c * nth_derivative i f y)`))) (term_tac (set_tac "P")));
   ((fun arg_tac -> arg_tac (Arg_term (`!i. i <= n:num ==> P i ((@) (P i))`))) (term_tac (have_gen_tac [](move ["sel_P"]))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_le_n"])) THEN ((use_arg_then2 ("SELECT_AX", [SELECT_AX])) (thm_tac apply_tac)));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (move ["cond"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`INTERS (IMAGE (\i. (@) (P i)) (0..n))`))) (term_tac (set_tac "S")));
   ((use_arg_then2 ("S", [])) (term_tac exists_tac));
   ((((use_arg_then2 ("S_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_OPEN_INTERS", [REAL_OPEN_INTERS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_IMAGE", [FINITE_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("IN_INTERS", [IN_INTERS]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["i"]) THEN (move ["y"]) THEN (case THEN (move ["i_le_n"])));
   ((((fun arg_tac -> (use_arg_then2 ("sel_P", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (move ["y_in"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(@) (P i)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) (((use_arg_then2 ("i", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN (exact_tac));
];;

(* Lemma nth_derivative_scale *)
let nth_derivative_scale = Sections.section_proof ["c";"i";"x"]
`interval_arith x int ==> i <= n ==>
	nth_derivative i (\x. c * f x) x = c * nth_derivative i f x`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["i_le_n"]));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_scale_strong", [nth_derivative_scale_strong])) (fun fst_arg -> (use_arg_then2 ("c", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"])) THEN (move ["h"]));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma nth_diff_scale *)
let nth_diff_scale = Sections.section_proof ["c"]
`nth_diff_strong_int n int (\x. c * f x)`
[
   ((((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))))));
   (BETA_TAC THEN (move ["df"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_scale_strong_all", [nth_derivative_scale_strong_all])) (fun fst_arg -> (use_arg_then2 ("c", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["diff"]));
   (((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["diff2"]));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER t`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (move ["yt"])))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_LMUL", [REAL_CONTINUOUS_LMUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_lt_n"]));
   ((((use_arg_then2 ("diff", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((TRY done_tac)));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. c * nth_derivative i f y)`))) (term_tac exists_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((fun arg_tac -> (use_arg_then2 ("diff2", [])) (fun fst_arg -> (use_arg_then2 ("yt", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["zs"]) THEN (simp_tac)));
   ((((use_arg_then2 ("diff", [])) (disch_tac [])) THEN (clear_assumption "diff") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("ltnW", [ltnW]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;
(Sections.add_section_hyp "dg" (`nth_diff_strong_int n int g`));;

(* Lemma nth_derivative_add_strong *)
let nth_derivative_add_strong = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
   ?s. real_open s /\ x IN s /\ 
      !y. y IN s ==> nth_derivative i (\y. f y + g y) y = nth_derivative i f y + nth_derivative i g y`
[
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))))) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["ineq"])));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sf"])) THEN (case THEN (move ["open_sf"])) THEN (case THEN (move ["xsf"]))) THEN (((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC THEN (move ["_"])));
   ((((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sg"])) THEN (case THEN (move ["open_sg"])) THEN (case THEN (move ["xsg"]))) THEN (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN BETA_TAC THEN (move ["_"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))))) THEN (move ["diff_g"]) THEN (move ["diff_f"]));
   ((THENL_FIRST) ((THENL) (((use_arg_then2 ("i", [])) (disch_tac [])) THEN (clear_assumption "i") THEN elim) [(move ["_"]); ((move ["i"]) THEN (move ["IHi"]))]) ((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("sf", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["i_lt_n"]));
   ((((fun arg_tac -> (use_arg_then2 ("IHi", [])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("ltnW", [ltnW])) (fun fst_arg -> (use_arg_then2 ("i_lt_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["eq"])) THEN (((use_arg_then2 ("IHi", [])) (disch_tac [])) THEN (clear_assumption "IHi") THEN BETA_TAC THEN (move ["_"])));
   ((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsf", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsg", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN (move ["ysf"])) THEN (case THEN ((move ["ysg"]) THEN (move ["yt"]))));
   (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. nth_derivative i f y + nth_derivative i g y)`))) (term_tac exists_tac));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ysf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ysg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("yt", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   ((BETA_TAC THEN (move ["z"]) THEN (move ["z_in"]) THEN (simp_tac)) THEN (((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_add_strong_all *)
let nth_derivative_add_strong_all = Sections.section_proof ["x"]
`interval_arith x int ==>
	?s. real_open s /\ x IN s /\ 
	!i y. i <= n /\ y IN s ==> 
		nth_derivative i (\y. f y + g y) y = nth_derivative i f y + nth_derivative i g y`
[
   (BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_derivative_add_strong", [nth_derivative_add_strong])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   ((fun arg_tac -> arg_tac (Arg_term (`\i s. real_open s /\ x IN s /\ 
   (!y. y IN s ==> nth_derivative i (\y. f y + g y) y = nth_derivative i f y + nth_derivative i g y)`))) (term_tac (set_tac "P")));
   ((fun arg_tac -> arg_tac (Arg_term (`!i. i <= n:num ==> P i ((@) (P i))`))) (term_tac (have_gen_tac [](move ["sel_P"]))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_le_n"])) THEN ((use_arg_then2 ("SELECT_AX", [SELECT_AX])) (thm_tac apply_tac)));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (move ["cond"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`INTERS (IMAGE (\i. (@) (P i)) (0..n))`))) (term_tac (set_tac "S")));
   ((use_arg_then2 ("S", [])) (term_tac exists_tac));
   ((((use_arg_then2 ("S_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_OPEN_INTERS", [REAL_OPEN_INTERS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_IMAGE", [FINITE_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("IN_INTERS", [IN_INTERS]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["i"]) THEN (move ["y"]) THEN (case THEN (move ["i_le_n"])));
   ((((fun arg_tac -> (use_arg_then2 ("sel_P", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (move ["y_in"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(@) (P i)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) (((use_arg_then2 ("i", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN (exact_tac));
];;

(* Lemma nth_derivative_add *)
let nth_derivative_add = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
	nth_derivative i (\x. f x + g x) x = nth_derivative i f x + nth_derivative i g x`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["i_le_n"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_add_strong", [nth_derivative_add_strong])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"])) THEN (move ["h"]));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma nth_diff_add *)
let nth_diff_add = Sections.section_proof []
`nth_diff_strong_int n int (\x. f x + g x)`
[
   (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC);
   ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))));
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((fun arg_tac -> (use_arg_then2 ("nth_derivative_add_strong_all", [nth_derivative_add_strong_all])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["diff"]));
   (((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tf"])) THEN (case THEN (move ["open_tf"])) THEN (case THEN (move ["xtf"])) THEN (move ["diff_f"]));
   (((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tg"])) THEN (case THEN (move ["open_tg"])) THEN (case THEN (move ["xtg"])) THEN (move ["diff_g"]));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER tf INTER tg`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   (BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (case THEN ((move ["ytf"]) THEN (move ["ytg"]))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_ADD", [REAL_CONTINUOUS_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_g", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_lt_n"]));
   ((((use_arg_then2 ("diff", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((TRY done_tac)));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. nth_derivative i f y + nth_derivative i g y)`))) (term_tac exists_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ytf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ytg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["zs"]) THEN (simp_tac)));
   ((((use_arg_then2 ("diff", [])) (disch_tac [])) THEN (clear_assumption "diff") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("ltnW", [ltnW]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_sub_strong *)
let nth_derivative_sub_strong = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
   ?s. real_open s /\ x IN s /\ 
      !y. y IN s ==> nth_derivative i (\y. f y - g y) y = nth_derivative i f y - nth_derivative i g y`
[
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))))) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["ineq"])));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sf"])) THEN (case THEN (move ["open_sf"])) THEN (case THEN (move ["xsf"]))) THEN (((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC THEN (move ["_"])));
   ((((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sg"])) THEN (case THEN (move ["open_sg"])) THEN (case THEN (move ["xsg"]))) THEN (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN BETA_TAC THEN (move ["_"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))))) THEN (move ["diff_g"]) THEN (move ["diff_f"]));
   ((THENL_FIRST) ((THENL) (((use_arg_then2 ("i", [])) (disch_tac [])) THEN (clear_assumption "i") THEN elim) [(move ["_"]); ((move ["i"]) THEN (move ["IHi"]))]) ((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("sf", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["i_lt_n"]));
   ((((fun arg_tac -> (use_arg_then2 ("IHi", [])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("ltnW", [ltnW])) (fun fst_arg -> (use_arg_then2 ("i_lt_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["eq"])) THEN (((use_arg_then2 ("IHi", [])) (disch_tac [])) THEN (clear_assumption "IHi") THEN BETA_TAC THEN (move ["_"])));
   ((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsf", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsg", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN (move ["ysf"])) THEN (case THEN ((move ["ysg"]) THEN (move ["yt"]))));
   (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. nth_derivative i f y - nth_derivative i g y)`))) (term_tac exists_tac));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_SUB", [HAS_REAL_DERIVATIVE_SUB]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ysf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ysg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("yt", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   ((BETA_TAC THEN (move ["z"]) THEN (move ["z_in"]) THEN (simp_tac)) THEN (((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_sub_strong_all *)
let nth_derivative_sub_strong_all = Sections.section_proof ["x"]
`interval_arith x int ==>
	?s. real_open s /\ x IN s /\ 
	!i y. i <= n /\ y IN s ==> 
		nth_derivative i (\y. f y - g y) y = nth_derivative i f y - nth_derivative i g y`
[
   (BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_derivative_sub_strong", [nth_derivative_sub_strong])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   ((fun arg_tac -> arg_tac (Arg_term (`\i s. real_open s /\ x IN s /\ 
   (!y. y IN s ==> nth_derivative i (\y. f y - g y) y = nth_derivative i f y - nth_derivative i g y)`))) (term_tac (set_tac "P")));
   ((fun arg_tac -> arg_tac (Arg_term (`!i. i <= n:num ==> P i ((@) (P i))`))) (term_tac (have_gen_tac [](move ["sel_P"]))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_le_n"])) THEN ((use_arg_then2 ("SELECT_AX", [SELECT_AX])) (thm_tac apply_tac)));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (move ["cond"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`INTERS (IMAGE (\i. (@) (P i)) (0..n))`))) (term_tac (set_tac "S")));
   ((use_arg_then2 ("S", [])) (term_tac exists_tac));
   ((((use_arg_then2 ("S_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_OPEN_INTERS", [REAL_OPEN_INTERS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_IMAGE", [FINITE_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("IN_INTERS", [IN_INTERS]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["i"]) THEN (move ["y"]) THEN (case THEN (move ["i_le_n"])));
   ((((fun arg_tac -> (use_arg_then2 ("sel_P", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (move ["y_in"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(@) (P i)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) (((use_arg_then2 ("i", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN (exact_tac));
];;

(* Lemma nth_derivative_sub *)
let nth_derivative_sub = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
	nth_derivative i (\x. f x - g x) x = nth_derivative i f x - nth_derivative i g x`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["i_le_n"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_sub_strong", [nth_derivative_sub_strong])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"])) THEN (move ["h"]));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma nth_diff_sub *)
let nth_diff_sub = Sections.section_proof []
`nth_diff_strong_int n int (\x. f x - g x)`
[
   (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC);
   ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))));
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((fun arg_tac -> (use_arg_then2 ("nth_derivative_sub_strong_all", [nth_derivative_sub_strong_all])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["diff"]));
   (((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tf"])) THEN (case THEN (move ["open_tf"])) THEN (case THEN (move ["xtf"])) THEN (move ["diff_f"]));
   (((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tg"])) THEN (case THEN (move ["open_tg"])) THEN (case THEN (move ["xtg"])) THEN (move ["diff_g"]));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER tf INTER tg`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   (BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (case THEN ((move ["ytf"]) THEN (move ["ytg"]))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_SUB", [REAL_CONTINUOUS_SUB]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_g", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_lt_n"]));
   ((((use_arg_then2 ("diff", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((TRY done_tac)));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. nth_derivative i f y - nth_derivative i g y)`))) (term_tac exists_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_SUB", [HAS_REAL_DERIVATIVE_SUB]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ytf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ytg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["zs"]) THEN (simp_tac)));
   ((((use_arg_then2 ("diff", [])) (disch_tac [])) THEN (clear_assumption "diff") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("ltnW", [ltnW]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_mul_strong *)
let nth_derivative_mul_strong = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
   ?s. real_open s /\ x IN s /\ 
      !y. y IN s ==> nth_derivative i (\y. f y * g y) y = 
	sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)`
[
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))))) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["ineq"])));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sf"])) THEN (case THEN (move ["open_sf"])) THEN (case THEN (move ["xsf"]))) THEN (((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC THEN (move ["_"])));
   ((((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sg"])) THEN (case THEN (move ["open_sg"])) THEN (case THEN (move ["xsg"]))) THEN (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN BETA_TAC THEN (move ["_"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))))) THEN (move ["diff_g"]) THEN (move ["diff_f"]));
   ((THENL) (((use_arg_then2 ("i", [])) (disch_tac [])) THEN (clear_assumption "i") THEN elim) [(move ["_"]); ((move ["i"]) THEN (move ["IHi"]))]);
   (((use_arg_then2 ("sf", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_sf", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsf", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SUM_SING_NUMSEG", [SUM_SING_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (move ["_"]) THEN (simp_tac)));
   (((((use_arg_then2 ("subn0", [subn0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("binom", [binom]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["i_lt_n"]));
   ((((fun arg_tac -> (use_arg_then2 ("IHi", [])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("ltnW", [ltnW])) (fun fst_arg -> (use_arg_then2 ("i_lt_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["eq"])) THEN (((use_arg_then2 ("IHi", [])) (disch_tac [])) THEN (clear_assumption "IHi") THEN BETA_TAC THEN (move ["_"])));
   ((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsf", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsg", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN (move ["ysf"])) THEN (case THEN ((move ["ysg"]) THEN (move ["yt"]))));
   (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`\y. sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)`))) (term_tac exists_tac));
   ((THENL_ROT (-1)) (split_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("yt", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   ((BETA_TAC THEN (move ["z"]) THEN (move ["z_in"]) THEN (simp_tac)) THEN (((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   (((use_arg_then2 ("has_derivative_lemma", [has_derivative_lemma])) (disch_tac [])) THEN (clear_assumption "has_derivative_lemma") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!k. k IN 0..i ==>
	nth_derivative k f real_differentiable atreal y /\
	nth_derivative (i - k) g real_differentiable atreal y`))) (term_tac (have_gen_tac [](move ["diff_cond"]))));
   (((((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (move ["k"]) THEN (move ["ineq"]) THEN (simp_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC k) f y`))) (term_tac exists_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ysf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("i_lt_n", [])) (disch_tac [])) THEN (clear_assumption "i_lt_n") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC (i - k)) g y`))) (term_tac exists_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ysg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("i_lt_n", [])) (disch_tac [])) THEN (clear_assumption "i_lt_n") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!k. k IN 0..i ==> 
	(\y. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)
		real_differentiable atreal y`))) (term_tac (have_gen_tac [](move ["diff_cond2"]))));
   (BETA_TAC THEN (move ["k"]) THEN (move ["k_in"]) THEN (simp_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("diff_cond", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (done_tac));
   (((((use_arg_then2 ("differentiable_sum_numseg", [differentiable_sum_numseg]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("derivative_sum_numseg", [derivative_sum_numseg]))(thm_tac (new_rewrite [] [])))))) THEN ((simp_tac) THEN (((use_arg_then2 ("diff_cond2", []))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((fun arg_tac -> arg_tac (Arg_term (`sum (0..i) _`))) (term_tac (set_tac "lhs")));
   ((fun arg_tac -> arg_tac (Arg_term (`sum (0 + 1..i + 1) (\k. &(binom (i, k - 1)) * nth_derivative k f y * nth_derivative (SUC i - k) g y)`))) (term_tac (set_tac "sum1")));
   ((fun arg_tac -> arg_tac (Arg_term (`sum (0..i + 1) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (SUC i - k) g y)`))) (term_tac (set_tac "sum2")));
   ((fun arg_tac -> arg_tac (Arg_term (`lhs = sum1 + sum2`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then2 ("sum1_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SUM_OFFSET", [SUM_OFFSET]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("addn1", [addn1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("succnK", [succnK]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subSS", [subSS]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("sum2_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("addn1", [addn1]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `0 <= SUC i`)))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`binom(i, SUC i) = 0`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) ((((use_arg_then2 ("BINOM_EQ_0", [BINOM_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LZERO", [REAL_MUL_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_RID", [REAL_ADD_RID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_ADD_NUMSEG", [SUM_ADD_NUMSEG]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("lhs_def", []))(gsym_then (thm_tac (new_rewrite [] []))))));
   (((use_arg_then2 ("SUM_EQ", [SUM_EQ])) (thm_tac apply_tac)) THEN (move ["k"]) THEN (move ["k_in"]) THEN (simp_tac));
   (((((use_arg_then2 ("derivative_scale", [derivative_scale]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((repeat_tactic 0 10 (((use_arg_then2 ("diff_cond", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("REAL_ADD_LDISTRIB", [REAL_ADD_LDISTRIB]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_EQ_MUL_LCANCEL", [REAL_EQ_MUL_LCANCEL]))(thm_tac (new_rewrite [] []))))) THEN (DISJ2_TAC));
   ((((use_arg_then2 ("derivative_mul", [derivative_mul]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((repeat_tactic 0 10 (((use_arg_then2 ("diff_cond", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(gsym_then (thm_tac (new_rewrite [] [])))))));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`SUC (i - k) = SUC i - k`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) ((done_tac) THEN (done_tac)));
   ((((use_arg_then2 ("k_in", [])) (disch_tac [])) THEN (clear_assumption "k_in") THEN BETA_TAC) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_CLAUSES_LEFT", [SUM_CLAUSES_LEFT]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("sum2_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 0 1 (((use_arg_then2 ("SUM_CLAUSES_LEFT", [SUM_CLAUSES_LEFT]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (TRY ((arith_tac))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("binom", [binom]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ADD_ASSOC", [REAL_ADD_ASSOC]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_EQ_ADD_LCANCEL", [REAL_EQ_ADD_LCANCEL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("sum1_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SUM_ADD_NUMSEG", [SUM_ADD_NUMSEG]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then2 ("addn1", [addn1])) (fun fst_arg -> (use_arg_then2 ("i", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   (((use_arg_then2 ("SUM_EQ", [SUM_EQ])) (thm_tac apply_tac)) THEN (move ["k"]) THEN (move ["k_in"]) THEN (simp_tac));
   (((((use_arg_then2 ("REAL_ADD_RDISTRIB", [REAL_ADD_RDISTRIB]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_EQ_MUL_RCANCEL", [REAL_EQ_MUL_RCANCEL]))(thm_tac (new_rewrite [] []))))) THEN (DISJ1_TAC));
   ((THENL_FIRST) (((THENL) (((use_arg_then2 ("k_in", [])) (disch_tac [])) THEN (clear_assumption "k_in") THEN ((use_arg_then2 ("k", [])) (disch_tac [])) THEN (clear_assumption "k") THEN case) [ALL_TAC; (move ["k"])]) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) ((arith_tac) THEN (done_tac)));
   (((((use_arg_then2 ("binom", [binom]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subSS", [subSS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subn0", [subn0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OF_NUM_ADD", [REAL_OF_NUM_ADD]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_derivative_mul_strong_all *)
let nth_derivative_mul_strong_all = Sections.section_proof ["x"]
`interval_arith x int ==>
	?s. real_open s /\ x IN s /\ 
	!i y. i <= n /\ y IN s ==> 
	  nth_derivative i (\y. f y * g y) y = 
		sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)`
[
   (BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_derivative_mul_strong", [nth_derivative_mul_strong])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   ((fun arg_tac -> arg_tac (Arg_term (`\i s. real_open s /\ x IN s /\ 
   (!y. y IN s ==> nth_derivative i (\y. f y * g y) y = 
	sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y))`))) (term_tac (set_tac "P")));
   ((fun arg_tac -> arg_tac (Arg_term (`!i. i <= n:num ==> P i ((@) (P i))`))) (term_tac (have_gen_tac [](move ["sel_P"]))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_le_n"])) THEN ((use_arg_then2 ("SELECT_AX", [SELECT_AX])) (thm_tac apply_tac)));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (move ["cond"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`INTERS (IMAGE (\i. (@) (P i)) (0..n))`))) (term_tac (set_tac "S")));
   ((use_arg_then2 ("S", [])) (term_tac exists_tac));
   ((((use_arg_then2 ("S_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_OPEN_INTERS", [REAL_OPEN_INTERS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_IMAGE", [FINITE_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("IN_INTERS", [IN_INTERS]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["i"]) THEN (move ["y"]) THEN (case THEN (move ["i_le_n"])));
   ((((fun arg_tac -> (use_arg_then2 ("sel_P", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (move ["y_in"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(@) (P i)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) (((use_arg_then2 ("i", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN (exact_tac));
];;

(* Lemma nth_derivative_mul *)
let nth_derivative_mul = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
	nth_derivative i (\x. f x * g x) x = 
  	  sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f x * nth_derivative (i - k) g x)`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["i_le_n"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_mul_strong", [nth_derivative_mul_strong])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"])) THEN (move ["h"]));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma nth_diff_mul *)
let nth_diff_mul = Sections.section_proof []
`nth_diff_strong_int n int (\x. f x * g x)`
[
   (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC);
   ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))));
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((fun arg_tac -> (use_arg_then2 ("nth_derivative_mul_strong_all", [nth_derivative_mul_strong_all])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["diff"]));
   (((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tf"])) THEN (case THEN (move ["open_tf"])) THEN (case THEN (move ["xtf"])) THEN (move ["diff_f"]));
   (((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tg"])) THEN (case THEN (move ["open_tg"])) THEN (case THEN (move ["xtg"])) THEN (move ["diff_g"]));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER tf INTER tg`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   (BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (case THEN ((move ["ytf"]) THEN (move ["ytg"]))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_MUL", [REAL_CONTINUOUS_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_g", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_lt_n"]));
   ((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))));
   (((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`\y. sum (0..i) (\k. &(binom(i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)`))) (term_tac exists_tac)) THEN ((use_arg_then2 ("s", [])) (term_tac exists_tac)));
   ((THENL_LAST) (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac)) ((BETA_TAC THEN (move ["z"]) THEN (move ["zs"])) THEN ((((use_arg_then2 ("diff", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("ltnW", [ltnW]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("differentiable_sum_numseg", [differentiable_sum_numseg]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (move ["k"]) THEN (move ["k_in"]) THEN (simp_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC k) f y`))) (term_tac exists_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ytf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("i_lt_n", [])) (disch_tac [])) THEN (clear_assumption "i_lt_n") THEN ((use_arg_then2 ("k_in", [])) (disch_tac [])) THEN (clear_assumption "k_in") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC (i - k)) g y`))) (term_tac exists_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ytg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("i_lt_n", [])) (disch_tac [])) THEN (clear_assumption "i_lt_n") THEN ((use_arg_then2 ("k_in", [])) (disch_tac [])) THEN (clear_assumption "k_in") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section NthDerivativeArith *)
let nth_derivative_scale_strong = Sections.finalize_theorem nth_derivative_scale_strong;;
let nth_derivative_scale_strong_all = Sections.finalize_theorem nth_derivative_scale_strong_all;;
let nth_derivative_scale = Sections.finalize_theorem nth_derivative_scale;;
let nth_diff_scale = Sections.finalize_theorem nth_diff_scale;;
let nth_derivative_add_strong = Sections.finalize_theorem nth_derivative_add_strong;;
let nth_derivative_add_strong_all = Sections.finalize_theorem nth_derivative_add_strong_all;;
let nth_derivative_add = Sections.finalize_theorem nth_derivative_add;;
let nth_diff_add = Sections.finalize_theorem nth_diff_add;;
let nth_derivative_sub_strong = Sections.finalize_theorem nth_derivative_sub_strong;;
let nth_derivative_sub_strong_all = Sections.finalize_theorem nth_derivative_sub_strong_all;;
let nth_derivative_sub = Sections.finalize_theorem nth_derivative_sub;;
let nth_diff_sub = Sections.finalize_theorem nth_diff_sub;;
let nth_derivative_mul_strong = Sections.finalize_theorem nth_derivative_mul_strong;;
let nth_derivative_mul_strong_all = Sections.finalize_theorem nth_derivative_mul_strong_all;;
let nth_derivative_mul = Sections.finalize_theorem nth_derivative_mul;;
let nth_diff_mul = Sections.finalize_theorem nth_diff_mul;;
Sections.end_section "NthDerivativeArith";;

(* Finalization of the section NthDerivatives *)
let derivative_eq_real_derivative = Sections.finalize_theorem derivative_eq_real_derivative;;
let has_derivative_cond = Sections.finalize_theorem has_derivative_cond;;
let has_derivative_alt = Sections.finalize_theorem has_derivative_alt;;
let derivative_unique = Sections.finalize_theorem derivative_unique;;
let derivative_unique_on = Sections.finalize_theorem derivative_unique_on;;
let has_derivative_lemma = Sections.finalize_theorem has_derivative_lemma;;
let nth_derivative0 = Sections.finalize_theorem nth_derivative0;;
let nth_derivativeS = Sections.finalize_theorem nth_derivativeS;;
let nth_Sderivative = Sections.finalize_theorem nth_Sderivative;;
let nth_derivative1 = Sections.finalize_theorem nth_derivative1;;
let nth_derivative2 = Sections.finalize_theorem nth_derivative2;;
let nth_derivative_add = Sections.finalize_theorem nth_derivative_add;;
let nth_diff_continuous = Sections.finalize_theorem nth_diff_continuous;;
let nth_differentiable_cond = Sections.finalize_theorem nth_differentiable_cond;;
let nth_differentiable_on_cond = Sections.finalize_theorem nth_differentiable_on_cond;;
let nth_differentiable_eq = Sections.finalize_theorem nth_differentiable_eq;;
let nth_differentiable_on_int2 = Sections.finalize_theorem nth_differentiable_on_int2;;
let nth_mth_diff = Sections.finalize_theorem nth_mth_diff;;
let nth_differentiable1 = Sections.finalize_theorem nth_differentiable1;;
let nth_diff_imp_diff = Sections.finalize_theorem nth_diff_imp_diff;;
let nth_derivative_continuous = Sections.finalize_theorem nth_derivative_continuous;;
let ith_derivative_differentiable = Sections.finalize_theorem ith_derivative_differentiable;;
let nth_diff_strong_imp_diff = Sections.finalize_theorem nth_diff_strong_imp_diff;;
let HAS_REAL_DERIVATIVE_ABS_POS = Sections.finalize_theorem HAS_REAL_DERIVATIVE_ABS_POS;;
let HAS_REAL_DERIVATIVE_ABS_NEG = Sections.finalize_theorem HAS_REAL_DERIVATIVE_ABS_NEG;;
let derivative_x = Sections.finalize_theorem derivative_x;;
let derivative_const = Sections.finalize_theorem derivative_const;;
let derivative_abs_pos = Sections.finalize_theorem derivative_abs_pos;;
let derivative_abs_neg = Sections.finalize_theorem derivative_abs_neg;;
let derivative_pow_x = Sections.finalize_theorem derivative_pow_x;;
let derivative_pow2_x = Sections.finalize_theorem derivative_pow2_x;;
let derivative_pow3_x = Sections.finalize_theorem derivative_pow3_x;;
let derivative_inv = Sections.finalize_theorem derivative_inv;;
let derivative_atn = Sections.finalize_theorem derivative_atn;;
let derivative_exp = Sections.finalize_theorem derivative_exp;;
let derivative_log = Sections.finalize_theorem derivative_log;;
let derivative_sin = Sections.finalize_theorem derivative_sin;;
let derivative_cos = Sections.finalize_theorem derivative_cos;;
let derivative_asn = Sections.finalize_theorem derivative_asn;;
let derivative_acs = Sections.finalize_theorem derivative_acs;;
let derivative_sqrt = Sections.finalize_theorem derivative_sqrt;;
let derivative_matan = Sections.finalize_theorem derivative_matan;;
let matan_differentiable = Sections.finalize_theorem matan_differentiable;;
let derivative_composition = Sections.finalize_theorem derivative_composition;;
let REAL_DIFFERENTIABLE_AT_INV = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_INV;;
let REAL_DIFFERENTIABLE_AT_ABS_POS = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_ABS_POS;;
let REAL_DIFFERENTIABLE_AT_ABS_NEG = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_ABS_NEG;;
let derivative_compose_abs_pos = Sections.finalize_theorem derivative_compose_abs_pos;;
let derivative_compose_abs_neg = Sections.finalize_theorem derivative_compose_abs_neg;;
let derivative_compose_pow = Sections.finalize_theorem derivative_compose_pow;;
let derivative_compose_pow2 = Sections.finalize_theorem derivative_compose_pow2;;
let derivative_compose_pow3 = Sections.finalize_theorem derivative_compose_pow3;;
let derivative_compose_atn = Sections.finalize_theorem derivative_compose_atn;;
let derivative_compose_exp = Sections.finalize_theorem derivative_compose_exp;;
let derivative_compose_log = Sections.finalize_theorem derivative_compose_log;;
let derivative_compose_cos = Sections.finalize_theorem derivative_compose_cos;;
let derivative_compose_sin = Sections.finalize_theorem derivative_compose_sin;;
let derivative_compose_inv = Sections.finalize_theorem derivative_compose_inv;;
let derivative_compose_sqrt = Sections.finalize_theorem derivative_compose_sqrt;;
let derivative_compose_acs = Sections.finalize_theorem derivative_compose_acs;;
let derivative_compose_asn = Sections.finalize_theorem derivative_compose_asn;;
let derivative_compose_matan = Sections.finalize_theorem derivative_compose_matan;;
let derivative_scale = Sections.finalize_theorem derivative_scale;;
let derivative_neg = Sections.finalize_theorem derivative_neg;;
let derivative_pow = Sections.finalize_theorem derivative_pow;;
let derivative_add = Sections.finalize_theorem derivative_add;;
let derivative_mul = Sections.finalize_theorem derivative_mul;;
let derivative_sub = Sections.finalize_theorem derivative_sub;;
let derivative_div = Sections.finalize_theorem derivative_div;;
let differentiable_sum_numseg = Sections.finalize_theorem differentiable_sum_numseg;;
let derivative_sum_numseg = Sections.finalize_theorem derivative_sum_numseg;;
let HAS_REAL_DERIVATIVE_LOCAL = Sections.finalize_theorem HAS_REAL_DERIVATIVE_LOCAL;;
let differentiable_local = Sections.finalize_theorem differentiable_local;;
let nth_derivative_scale_strong = Sections.finalize_theorem nth_derivative_scale_strong;;
let nth_derivative_scale_strong_all = Sections.finalize_theorem nth_derivative_scale_strong_all;;
let nth_derivative_scale = Sections.finalize_theorem nth_derivative_scale;;
let nth_diff_scale = Sections.finalize_theorem nth_diff_scale;;
let nth_derivative_add_strong = Sections.finalize_theorem nth_derivative_add_strong;;
let nth_derivative_add_strong_all = Sections.finalize_theorem nth_derivative_add_strong_all;;
let nth_derivative_add = Sections.finalize_theorem nth_derivative_add;;
let nth_diff_add = Sections.finalize_theorem nth_diff_add;;
let nth_derivative_sub_strong = Sections.finalize_theorem nth_derivative_sub_strong;;
let nth_derivative_sub_strong_all = Sections.finalize_theorem nth_derivative_sub_strong_all;;
let nth_derivative_sub = Sections.finalize_theorem nth_derivative_sub;;
let nth_diff_sub = Sections.finalize_theorem nth_diff_sub;;
let nth_derivative_mul_strong = Sections.finalize_theorem nth_derivative_mul_strong;;
let nth_derivative_mul_strong_all = Sections.finalize_theorem nth_derivative_mul_strong_all;;
let nth_derivative_mul = Sections.finalize_theorem nth_derivative_mul;;
let nth_diff_mul = Sections.finalize_theorem nth_diff_mul;;
Sections.end_section "NthDerivatives";;
let lin_approx = new_definition `lin_approx f x f_bounds df_bounds <=> 
	interval_arith (f x) f_bounds /\
	(?f'. (f has_real_derivative f') (atreal x) /\ interval_arith f' df_bounds)`;;
let has_bounded_second_derivative = new_definition `has_bounded_second_derivative f int dd_bounds <=>
	nth_diff_strong_int 2 int f /\ 
	bounded_on_int (nth_derivative 2 f) int dd_bounds`;;
let taylor_interval = new_definition 
  `taylor_interval f x y z w f_bounds df_bounds ddf_bounds <=>
	x <= y /\ y <= z /\ y - x <= w /\ z - y <= w /\
	lin_approx f y f_bounds df_bounds /\
	has_bounded_second_derivative f (x, z) ddf_bounds`;;

(* Lemma nth_diff_strong_imp_diff_int *)
let nth_diff_strong_imp_diff_int = Sections.section_proof ["n";"int";"f"]
`nth_diff_strong_int n int f ==>
	nth_differentiable_on_int n int f`
[
   ((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on_int", [nth_differentiable_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))));
   (BETA_TAC THEN (move ["h"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"]))) THEN (exact_tac) THEN (done_tac));
];;

(* Lemma has_bounded_second_derivative_old *)
let has_bounded_second_derivative_old = Sections.section_proof ["f";"int";"dd_bounds"]
`has_bounded_second_derivative f int dd_bounds ==>
	?f' f''. (!x. interval_arith x int ==> (f has_real_derivative f' x) (atreal x) /\
       		(f' has_real_derivative f'' x) (atreal x) /\	interval_arith (f'' x) dd_bounds)`
[
   ((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_diff_strong_imp_diff_int", [nth_diff_strong_imp_diff_int])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_differentiable_on_int2", [nth_differentiable_on_int2])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (case THEN (move ["f'"])) THEN (case THEN (move ["f''"])));
   ((BETA_TAC THEN (case THEN (move ["eq1"])) THEN (case THEN (move ["eq2"])) THEN (move ["h"]) THEN (move ["b"])) THEN ((((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN ((use_arg_then2 ("f''", [])) (term_tac exists_tac))) THEN (move ["x"]) THEN (move ["ineq"])));
   ((((use_arg_then2 ("b", [])) (disch_tac [])) THEN (clear_assumption "b") THEN BETA_TAC) THEN (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq2", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["b"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("h", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma exists_and_left *)
let exists_and_left = Sections.section_proof ["P";"Q"]
`(?x. P x /\ Q x) ==> (?x. P x)`
[
   (BETA_TAC THEN (case THEN (move ["x"])) THEN (case THEN ((move ["Px"]) THEN (move ["_"]))));
   (((use_arg_then2 ("x", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma lim_ineq *)
let lim_ineq = Sections.section_proof ["a";"b"]
`(!e. &0 < e ==> a <= b + e) <=> (a <= b)`
[
   ((THENL_ROT (-1)) ((THENL) (split_tac) [ALL_TAC; ((move ["ineq"]) THEN (move ["e"]) THEN (move ["e0"]))]));
   (((((fun arg_tac -> (use_arg_then2 ("REAL_ADD_RID", [REAL_ADD_RID])) (fun fst_arg -> (use_arg_then2 ("a", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_ADD2", [REAL_LE_ADD2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("contraLR", [contraLR])) (disch_tac [])) THEN (clear_assumption "contraLR") THEN (DISCH_THEN apply_tac)) THEN (((((use_arg_then2 ("NOT_FORALL_THM", [NOT_FORALL_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("NOT_IMP", [NOT_IMP]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_NOT_LE", [REAL_NOT_LE]))(thm_tac (new_rewrite [] [])))))) THEN (move ["ba"])));
   (((fun arg_tac -> arg_tac (Arg_term (`(a - b) / &2`))) (term_tac exists_tac)) THEN (((use_arg_then2 ("ba", [])) (disch_tac [])) THEN (clear_assumption "ba") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_leq *)
let continuous_leq = Sections.section_proof ["f";"c";"a"]
`(?b. a < b /\ !x. x IN real_interval (a, b) ==> f x <= c) /\
	f real_continuous atreal a ==> f a <= c`
[
   (BETA_TAC THEN (case THEN ((case THEN (move ["b"])) THEN (case THEN (move ["ab"])) THEN (move ["ineq"]))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_ATREAL", [REAL_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REALLIM_ATREAL", [REALLIM_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (move ["f_cont"]));
   ((((use_arg_then2 ("lim_ineq", [lim_ineq]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["e"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("f_cont", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["cond"]));
   ((fun arg_tac -> arg_tac (Arg_term (`a + min (b - a) d / &2`))) (term_tac (set_tac "r")));
   ((THENL_FIRST) ((((fun arg_tac -> (use_arg_then2 ("cond", [])) (fun fst_arg -> (use_arg_then2 ("r", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (ANTS_TAC)) ((((use_arg_then2 ("ab", [])) (disch_tac [])) THEN (clear_assumption "ab") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((use_arg_then2 ("r_def", [])) (disch_tac [])) THEN (clear_assumption "r_def") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((THENL_LAST) ((((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("r", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (ANTS_TAC)) ((arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ab", [])) (disch_tac [])) THEN (clear_assumption "ab") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((use_arg_then2 ("r_def", [])) (disch_tac [])) THEN (clear_assumption "r_def") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_reflection *)
let continuous_reflection = Sections.section_proof ["f";"x"]
`f real_continuous atreal x <=>
	(\x. f (--x)) real_continuous atreal (--x)`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_CONTINUOUS_ATREAL", [REAL_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REALLIM_ATREAL", [REALLIM_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN ((split_tac) THEN (move ["h"]) THEN (move ["e"]) THEN (move ["e0"])));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("e0", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["cond"]));
   (((use_arg_then2 ("d", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("d0", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (move ["ineqs"])) THEN (((use_arg_then2 ("cond", [])) (disch_tac [])) THEN (clear_assumption "cond") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("e0", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["cond"]));
   (((use_arg_then2 ("d", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("d0", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (move ["ineqs"])));
   ((((fun arg_tac -> (use_arg_then2 ("cond", [])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`--y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN apply_tac) THEN (((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_leq_segment *)
let continuous_leq_segment = Sections.section_proof ["f";"c";"a";"b"]
`a < b ==> f real_continuous atreal a ==> f real_continuous atreal b ==>
	(!x. x IN real_interval (a, b) ==> f x <= c) ==>
	(!x. x IN real_interval [a, b] ==> f x <= c)`
[
   (BETA_TAC THEN (move ["ab"]) THEN (move ["f_cont_a"]) THEN (move ["f_cont_b"]) THEN (move ["ineq"]) THEN (move ["x"]));
   ((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 2 0 (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b. a <= b <=> (a = b \/ a < b)`)))(thm_tac (new_rewrite [] []))))));
   (case THEN ((THENL) case [((((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["_"])); (move ["ax"])]));
   ((((use_arg_then2 ("continuous_leq", [continuous_leq])) (disch_tac [])) THEN (clear_assumption "continuous_leq") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("f_cont_a", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("b", [])) (term_tac exists_tac)) THEN (done_tac));
   ((THENL_LAST) ((THENL) case [(((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))); (move ["xb"])]) ((((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`\x. f (--x)`))) (term_tac (set_tac "g")));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`!x. f x = g (--x)`))) (term_tac (have_gen_tac [](move ["fg"])))) (((((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((use_arg_then2 ("fg", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("continuous_leq", [continuous_leq])) (disch_tac [])) THEN (clear_assumption "continuous_leq") THEN (DISCH_THEN apply_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`--a`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_LT_NEG2", [REAL_LT_NEG2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ab", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"])));
   ((((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`--y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("fg", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("continuous_reflection", [continuous_reflection]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma pair_eq *)
let pair_eq = Sections.section_proof ["p"]
`p = (FST p, SND p)`
[
   (done_tac);
];;

(* Section Taylor *)
Sections.begin_section "Taylor";;

(* Lemma iabs_alt *)
let iabs_alt = Sections.section_proof ["lo";"hi";"a"]
`interval_arith a (lo, hi) ==> iabs (lo, hi) = max (abs lo) (abs hi)`
[
   (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma iabs_pos *)
let iabs_pos = Sections.section_proof ["lo";"hi";"a"]
`interval_arith a (lo, hi) ==> &0 <= iabs (lo, hi)`
[
   (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real -> real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))); Sections.add_section_var (mk_var ("y", (`:real`))); Sections.add_section_var (mk_var ("z", (`:real`))); Sections.add_section_var (mk_var ("w", (`:real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("df_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("ddf_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("dd_bound", (`:real`))));;
(Sections.add_section_hyp "dd_bound_eq" (`dd_bound = iabs ddf_bounds`));;
(Sections.add_section_hyp "tif" (`taylor_interval f x y z w f_bounds df_bounds ddf_bounds`));;

(* Lemma f_continuous *)
let f_continuous = Sections.section_proof []
`!t. t IN real_interval [x, z] ==> f real_continuous atreal t`
[
   (((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["t"]) THEN (move ["t_in"]));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_IMP_CONTINUOUS_ATREAL", [HAS_REAL_DERIVATIVE_IMP_CONTINUOUS_ATREAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_IMP_CONTINUOUS_ATREAL") THEN (DISCH_THEN apply_tac));
   ((((use_arg_then2 ("tif", [])) (disch_tac [])) THEN (clear_assumption "tif") THEN BETA_TAC) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_bounded_second_derivative_old", [has_bounded_second_derivative_old])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (BETA_TAC THEN (case THEN (move ["f'"])) THEN (case THEN (move ["f''"])) THEN (move ["df"]));
   (((fun arg_tac -> arg_tac (Arg_term (`f' t`))) (term_tac exists_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma taylor_error *)
let taylor_error = Sections.section_proof ["t"]
`x <= t /\ t <= z ==> 
	abs (f t - f y) <= w * iabs df_bounds + w * w * dd_bound / &2`
[
   (BETA_TAC THEN (move ["t_ineqs"]));
   (((use_arg_then2 ("tif", [])) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["domain_ineqs"])) THEN (move ["lin_app"])));
   ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_bounded_second_derivative_old", [has_bounded_second_derivative_old])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (case THEN (move ["f'"])) THEN (case THEN (move ["f''"])) THEN (move ["df"]));
   ((fun arg_tac -> arg_tac (Arg_term (`abs (t - y) <= w`))) (term_tac (have_gen_tac [](move ["abs_ty"]))));
   ((((use_arg_then2 ("t_ineqs", [])) (disch_tac [])) THEN (clear_assumption "t_ineqs") THEN ((use_arg_then2 ("domain_ineqs", [])) (disch_tac [])) THEN (clear_assumption "domain_ineqs") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`interval_arith y (x, z)`))) (term_tac (have_gen_tac [](move ["y_in"])))) ((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 <= dd_bound /\ !p. p IN real_interval [x, z] ==> abs (f'' p) <= dd_bound`))) (term_tac (have_gen_tac [](move ["dd_prop"]))));
   ((((use_arg_then2 ("dd_bound_eq", []))(thm_tac (new_rewrite [] [])))) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("y_in", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (BETA_TAC THEN (move ["p"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`abs (f t - (f y + f' y * (t - y) pow 1)) <= dd_bound * abs (t - y) pow (1 + 1) / &2`))) (term_tac (have_gen_tac []ALL_TAC))));
   (((fun arg_tac -> arg_tac (Arg_term (`f' y * _`))) (term_tac (set_tac "b1"))) THEN (((fun arg_tac -> arg_tac (Arg_term (`dd_bound * _`))) (term_tac (set_tac "b2"))) THEN (move ["ineq1"])));
   ((((use_arg_then2 ("REAL_LE_TRANS", [REAL_LE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LE_TRANS") THEN (DISCH_THEN apply_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`abs (f t - (f y + b1)) + abs b1`))) (term_tac exists_tac)) THEN (split_tac));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b. a - b = (a - (b + b1)) + b1`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ABS_TRIANGLE", [REAL_ABS_TRIANGLE]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ADD2", [REAL_LE_ADD2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("b1_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ABS_MUL", [REAL_ABS_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_MUL2", [REAL_LE_MUL2]))(thm_tac (new_rewrite [] [])))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_ABS_POS", [REAL_ABS_POS]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("abs_ty", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("lin_app", [])) (disch_tac [])) THEN (clear_assumption "lin_app") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["ff"])) THEN (case THEN (move ["df'"]))));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`ff = f' y`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) (((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac)));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DERIVATIVE_UNIQUE_ATREAL", [REAL_DERIVATIVE_UNIQUE_ATREAL])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("df'", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_TRANS", [REAL_LE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LE_TRANS") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("b2", [])) (term_tac exists_tac)));
   ((((use_arg_then2 ("ineq1", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("b2_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_MUL2", [REAL_LE_MUL2]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `1 + 1 = 2`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_INV", [REAL_LE_INV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LE_MUL", [REAL_LE_MUL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LE_POW_2", [REAL_LE_POW_2]))(thm_tac (new_rewrite [] [])))))) THEN (TRY ((arith_tac))));
   ((((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_MUL2", [REAL_LE_MUL2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_LE_POW_2", [REAL_LE_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_SQUARE_ABS", [REAL_LE_SQUARE_ABS]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ABS_ABS", [REAL_ABS_ABS]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("abs_ty", [])) (disch_tac [])) THEN (clear_assumption "abs_ty") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`\i. if i = 0 then f else if i = 1 then f' else if i = 2 then f'' else I`))) (term_tac (set_tac "Df")));
   ((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `0 + 1 = 1 /\ ~(1 = 0) /\ 1 + 1 = 2 /\ 
	~(2 = 1) /\ ~(2 = 1) /\ ~(2 = 0)`))) (fun arg -> thm_tac MP_TAC arg THEN (move ["arith"])));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_TAYLOR", [REAL_TAYLOR])) (fun fst_arg -> (use_arg_then2 ("Df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`real_interval [x, z]`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dd_bound", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (ANTS_TAC);
   (((((use_arg_then2 ("IS_REALINTERVAL_INTERVAL", [IS_REALINTERVAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["p"]) THEN (case THEN (move ["p_in"]))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i <= 1 <=> i = 0 \/ i = 1`)))(thm_tac (new_rewrite [] [])))));
   ((case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN ((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATREAL_WITHIN", [HAS_REAL_DERIVATIVE_ATREAL_WITHIN])) (thm_tac apply_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (move ["p_in"])) THEN ((((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   (((repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((BETA_TAC THEN ((fun arg_tac -> (fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("t", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("domain_ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("t_ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   ((((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [1] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_SING_NUMSEG", [SUM_SING_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `0 <= 1 /\ ~(1 = 0)`)))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("FACT", [FACT]))(thm_tac (new_rewrite [] [])))));
   (((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `FACT 1 = 1 /\ FACT (1 + 1) = 2`)))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_DIV_1", [REAL_DIV_1]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma taylor_upper_bound *)
let taylor_upper_bound = Sections.section_proof []
`!t. x <= t /\ t <= z ==>
	f t <= SND f_bounds + (w * iabs df_bounds + w * w * dd_bound / &2)`
[
   (((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (move ["eq"]));
   (BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("taylor_error", [taylor_error])) (thm_tac (match_mp_then snd_th MP_TAC)))));
   ((((use_arg_then2 ("tif", [])) (disch_tac [])) THEN (clear_assumption "tif") THEN BETA_TAC) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["_"])) THEN (case THEN (move ["f_int"])) THEN (move ["_"]) THEN (move ["_"])));
   ((((use_arg_then2 ("f_int", [])) (disch_tac [])) THEN (clear_assumption "f_int") THEN BETA_TAC) THEN ((((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma taylor_lower_bound *)
let taylor_lower_bound = Sections.section_proof []
`!t. x <= t /\ t <= z ==>
	FST f_bounds - (w * iabs df_bounds + w * w * dd_bound / &2) <= f t`
[
   ((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN (move ["eq"])));
   (BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("taylor_error", [taylor_error])) (thm_tac (match_mp_then snd_th MP_TAC)))));
   ((((use_arg_then2 ("tif", [])) (disch_tac [])) THEN (clear_assumption "tif") THEN BETA_TAC) THEN (((((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["_"])) THEN (case THEN (move ["f_int"])) THEN (move ["_"]) THEN (move ["_"])));
   ((((use_arg_then2 ("f_int", [])) (disch_tac [])) THEN (clear_assumption "f_int") THEN BETA_TAC) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (arith_tac));
];;

(* Lemma taylor_derivative_error *)
let taylor_derivative_error = Sections.section_proof []
`!t. x <= t /\ t <= z ==> 
	abs (derivative f t - derivative f y) <= w * dd_bound`
[
   (BETA_TAC THEN (move ["t"]) THEN (move ["t_ineqs"]));
   (((use_arg_then2 ("tif", [])) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["domain_ineqs"])) THEN (move ["_"])));
   ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_bounded_second_derivative_old", [has_bounded_second_derivative_old])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (case THEN (move ["f'"])) THEN (case THEN (move ["f''"])) THEN (move ["df"]));
   ((fun arg_tac -> arg_tac (Arg_term (`abs (t - y) <= w`))) (term_tac (have_gen_tac [](move ["abs_ty"]))));
   ((((use_arg_then2 ("t_ineqs", [])) (disch_tac [])) THEN (clear_assumption "t_ineqs") THEN ((use_arg_then2 ("domain_ineqs", [])) (disch_tac [])) THEN (clear_assumption "domain_ineqs") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!p. x <= p /\ p <= z ==> derivative f p = f' p`))) (term_tac (have_gen_tac [](move ["der_eq"]))));
   (((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative_unique_on", [derivative_unique_on])) (disch_tac [])) THEN (clear_assumption "derivative_unique_on") THEN (DISCH_THEN apply_tac)));
   ((((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["p"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (simp_tac)) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then2 ("der_eq", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 <= dd_bound /\ !p. p IN real_interval [x, z] ==> abs (f'' p) <= dd_bound`))) (term_tac (have_gen_tac [](move ["dd_prop"]))));
   (((((use_arg_then2 ("dd_bound_eq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("ddf_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("domain_ineqs", []))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`\i. if i = 0 then f' else if i = 1 then f'' else I`))) (term_tac (set_tac "Df")));
   ((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `0 + 1 = 1 /\ ~(1 = 0) /\ 1 + 1 = 2 /\ 
	~(2 = 1) /\ ~(2 = 1) /\ ~(2 = 0)`))) (fun arg -> thm_tac MP_TAC arg THEN (move ["arith"])));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_TAYLOR", [REAL_TAYLOR])) (fun fst_arg -> (use_arg_then2 ("Df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`real_interval [x, z]`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dd_bound", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (ANTS_TAC);
   (((((use_arg_then2 ("IS_REALINTERVAL_INTERVAL", [IS_REALINTERVAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["p"]) THEN (case THEN (move ["p_in"]))) THEN ((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i <= 0 <=> i = 0`)))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATREAL_WITHIN", [HAS_REAL_DERIVATIVE_ATREAL_WITHIN])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_ATREAL_WITHIN") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (move ["p_in"])) THEN ((((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   (((repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((BETA_TAC THEN ((fun arg_tac -> (fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("t", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("domain_ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("t_ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   ((((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("SUM_SING_NUMSEG", [SUM_SING_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("FACT", [FACT]))(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `FACT 1 = 1`)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_DIV_1", [REAL_DIV_1]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] [])))) THEN (move ["ineq"]));
   ((((use_arg_then2 ("REAL_LE_TRANS", [REAL_LE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LE_TRANS") THEN (DISCH_THEN apply_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`dd_bound * abs (t - y)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("ineq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_RMUL", [REAL_LE_RMUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("abs_ty", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_interval *)
let derivative_interval = Sections.section_proof []
`FST df_bounds <= derivative f y /\ derivative f y <= SND df_bounds`
[
   ((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("df_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN (move ["eq"])));
   ((((use_arg_then2 ("tif", [])) (disch_tac [])) THEN (clear_assumption "tif") THEN BETA_TAC) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["ineqs"])) THEN (case THEN (move ["g"])) THEN (case THEN ((move ["fg"]) THEN (move ["g_int"]))) THEN (move ["_"])));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`derivative f y = g`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) ((((use_arg_then2 ("g_int", [])) (disch_tac [])) THEN (clear_assumption "g_int") THEN BETA_TAC) THEN ((((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DERIVATIVE_UNIQUE_ATREAL", [REAL_DERIVATIVE_UNIQUE_ATREAL])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac));
   (((((use_arg_then2 ("fg", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_cond", [has_derivative_cond]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN ((use_arg_then2 ("g", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma taylor_derivative_upper_bound *)
let taylor_derivative_upper_bound = Sections.section_proof []
`!t. x <= t /\ t <= z ==>
	derivative f t <= SND df_bounds + w * dd_bound`
[
   ((BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("taylor_derivative_error", [taylor_derivative_error])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (((use_arg_then2 ("derivative_interval", [derivative_interval])) (disch_tac [])) THEN (clear_assumption "derivative_interval") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma taylor_derivative_lower_bound *)
let taylor_derivative_lower_bound = Sections.section_proof []
`!t. x <= t /\ t <= z ==>
	FST df_bounds - w * dd_bound <= derivative f t`
[
   ((BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("taylor_derivative_error", [taylor_derivative_error])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (((use_arg_then2 ("derivative_interval", [derivative_interval])) (disch_tac [])) THEN (clear_assumption "derivative_interval") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section Taylor *)
let iabs_alt = Sections.finalize_theorem iabs_alt;;
let iabs_pos = Sections.finalize_theorem iabs_pos;;
let f_continuous = Sections.finalize_theorem f_continuous;;
let taylor_error = Sections.finalize_theorem taylor_error;;
let taylor_upper_bound = Sections.finalize_theorem taylor_upper_bound;;
let taylor_lower_bound = Sections.finalize_theorem taylor_lower_bound;;
let taylor_derivative_error = Sections.finalize_theorem taylor_derivative_error;;
let derivative_interval = Sections.finalize_theorem derivative_interval;;
let taylor_derivative_upper_bound = Sections.finalize_theorem taylor_derivative_upper_bound;;
let taylor_derivative_lower_bound = Sections.finalize_theorem taylor_derivative_lower_bound;;
Sections.end_section "Taylor";;

(* Section LinearApproximation *)
Sections.begin_section "LinearApproximation";;
(Sections.add_section_var (mk_var ("f", (`:real->real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("df_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;

(* Lemma lin_approx_eq *)
let lin_approx_eq = Sections.section_proof []
`lin_approx f x f_bounds df_bounds <=>
	(f real_differentiable atreal x /\ interval_arith (f x) f_bounds /\
	interval_arith (derivative f x) df_bounds)`
[
   (((((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [(case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (case THEN (move ["f'"])) THEN (case THEN ((move ["df'"]) THEN (move ["int_f'"]))))); ((case THEN ((case THEN (move ["f'"])) THEN (move ["df"]))) THEN (case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (move ["df_int"]))))]));
   ((THENL_FIRST) (split_tac) (((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN (done_tac)));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_unique", [derivative_unique])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f'", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_unique", [derivative_unique])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f'", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;
(Sections.add_section_hyp "approx_f" (`lin_approx f x f_bounds df_bounds`));;

(* Lemma lin_approx_imp_f_interval *)
let lin_approx_imp_f_interval = Sections.section_proof []
`interval_arith (f x) f_bounds`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma lin_approx_imp_df_interval *)
let lin_approx_imp_df_interval = Sections.section_proof []
`interval_arith (derivative f x) df_bounds`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma lin_approx_imp_f_diff *)
let lin_approx_imp_f_diff = Sections.section_proof []
`f real_differentiable atreal x`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Finalization of the section LinearApproximation *)
let lin_approx_eq = Sections.finalize_theorem lin_approx_eq;;
let lin_approx_imp_f_interval = Sections.finalize_theorem lin_approx_imp_f_interval;;
let lin_approx_imp_df_interval = Sections.finalize_theorem lin_approx_imp_df_interval;;
let lin_approx_imp_f_diff = Sections.finalize_theorem lin_approx_imp_f_diff;;
Sections.end_section "LinearApproximation";;

(* Section MoreLinearApproximation *)
Sections.begin_section "MoreLinearApproximation";;
(Sections.add_section_var (mk_var ("f", (`:real->real`))); Sections.add_section_var (mk_var ("g", (`:real->real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("df_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("g_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("dg_bounds", (`:real#real`))));;

(* Lemma interval_arith_not_zero *)
let interval_arith_not_zero = Sections.section_proof ["x";"int"]
`interval_arith x int ==> interval_not_zero int ==>
	~(x = &0)`
[
   (((((fun arg_tac -> (use_arg_then2 ("PAIR", [PAIR])) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_not_zero", [interval_not_zero]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma interval_arith_pos *)
let interval_arith_pos = Sections.section_proof ["x";"int"]
`interval_arith x int ==> interval_pos int ==> &0 < x`
[
   ((((use_arg_then2 ("int", [])) (disch_tac [])) THEN (clear_assumption "int") THEN case) THEN ((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_pos", [interval_pos]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma interval_arith_neg *)
let interval_arith_neg = Sections.section_proof ["x";"int"]
`interval_arith x int ==> interval_neg int ==> x < &0`
[
   ((((use_arg_then2 ("int", [])) (disch_tac [])) THEN (clear_assumption "int") THEN case) THEN ((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_neg", [interval_neg]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma interval_arith_abs *)
let interval_arith_abs = Sections.section_proof ["x";"int";"y"]
`interval_arith x int ==> iabs int < y ==> abs x < y`
[
   (((((fun arg_tac -> (use_arg_then2 ("PAIR", [PAIR])) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma lin_approx_x *)
let lin_approx_x = Sections.section_proof []
`lin_approx (\x. x) x (x, x) (&1, &1)`
[
   (((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma lin_approx_const *)
let lin_approx_const = Sections.section_proof ["c"]
`lin_approx (\x. c) x (c, c) (&0, &0)`
[
   ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Section LinearApproxUnivariateComposition *)
Sections.begin_section "LinearApproxUnivariateComposition";;
(Sections.add_section_hyp "approx_f" (`lin_approx f x f_bounds df_bounds`));;

(* Lemma lin_approx_compose_atn *)
let lin_approx_compose_atn = Sections.section_proof []
`(\x. atn (f x)) real_differentiable atreal x /\
	derivative (\x. atn (f x)) x = derivative f x / (&1 + f x * f x)`
[
   ((((use_arg_then2 ("derivative_compose_atn", [derivative_compose_atn])) (disch_tac [])) THEN (clear_assumption "derivative_compose_atn") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose_exp *)
let lin_approx_compose_exp = Sections.section_proof []
`(\x. exp (f x)) real_differentiable atreal x /\
	derivative (\x. exp (f x)) x = exp (f x) * derivative f x`
[
   ((((use_arg_then2 ("derivative_compose_exp", [derivative_compose_exp])) (disch_tac [])) THEN (clear_assumption "derivative_compose_exp") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose_log *)
let lin_approx_compose_log = Sections.section_proof []
`interval_pos f_bounds ==>
	(\x. log (f x)) real_differentiable atreal x /\
	derivative (\x. log (f x)) x = derivative f x / f x`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`&0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"])))) ((((use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (disch_tac [])) THEN (clear_assumption "interval_arith_pos") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_log", [derivative_compose_log])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_pos", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_cos *)
let lin_approx_compose_cos = Sections.section_proof []
`(\x. cos (f x)) real_differentiable atreal x /\
	derivative (\x. cos (f x)) x = --(sin (f x) * derivative f x)`
[
   ((((use_arg_then2 ("derivative_compose_cos", [derivative_compose_cos])) (disch_tac [])) THEN (clear_assumption "derivative_compose_cos") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose_sin *)
let lin_approx_compose_sin = Sections.section_proof []
`(\x. sin (f x)) real_differentiable atreal x /\
	derivative (\x. sin (f x)) x = cos (f x) * derivative f x`
[
   ((((use_arg_then2 ("derivative_compose_sin", [derivative_compose_sin])) (disch_tac [])) THEN (clear_assumption "derivative_compose_sin") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose_inv *)
let lin_approx_compose_inv = Sections.section_proof []
`interval_not_zero f_bounds ==>
	(\x. inv (f x)) real_differentiable atreal x /\
	derivative (\x. inv (f x)) x = -- inv (f x * f x) * derivative f x`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f0"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`~(f x = &0)`))) (term_tac (have_gen_tac [](move ["fn0"])))) ((((use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (disch_tac [])) THEN (clear_assumption "interval_arith_not_zero") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_inv", [derivative_compose_inv])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("fn0", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_sqrt *)
let lin_approx_compose_sqrt = Sections.section_proof []
`interval_pos f_bounds ==>
	(\x. sqrt (f x)) real_differentiable atreal x /\
	derivative (\x. sqrt (f x)) x = derivative f x / (&2 * sqrt (f x))`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`&0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"])))) ((((use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (disch_tac [])) THEN (clear_assumption "interval_arith_pos") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_sqrt", [derivative_compose_sqrt])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_pos", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_acs *)
let lin_approx_compose_acs = Sections.section_proof []
`iabs f_bounds < &1 ==>
	(\x. acs (f x)) real_differentiable atreal x /\
	derivative (\x. acs (f x)) x = -- (derivative f x / sqrt (&1 - f x * f x))`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`abs (f x) < &1`))) (term_tac (have_gen_tac [](move ["f_abs"])))) ((((use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (disch_tac [])) THEN (clear_assumption "interval_arith_abs") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_acs", [derivative_compose_acs])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_abs", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_asn *)
let lin_approx_compose_asn = Sections.section_proof []
`iabs f_bounds < &1 ==>
	(\x. asn (f x)) real_differentiable atreal x /\
	derivative (\x. asn (f x)) x = derivative f x / sqrt (&1 - f x * f x)`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`abs (f x) < &1`))) (term_tac (have_gen_tac [](move ["f_abs"])))) ((((use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (disch_tac [])) THEN (clear_assumption "interval_arith_abs") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_asn", [derivative_compose_asn])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_abs", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_matan *)
let lin_approx_compose_matan = Sections.section_proof []
`interval_gt (-- &1) f_bounds ==>
	(\x. matan (f x)) real_differentiable atreal x /\
	derivative (\x. matan (f x)) x = dmatan (f x) * derivative f x`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((fun arg_tac -> arg_tac (Arg_term (`-- &1 < f x`))) (term_tac (have_gen_tac [](move ["f_ineq2"]))));
   ((((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN ((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN ((((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_gt", [interval_gt]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_matan", [derivative_compose_matan])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_ineq2", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Finalization of the section LinearApproxUnivariateComposition *)
let lin_approx_compose_atn = Sections.finalize_theorem lin_approx_compose_atn;;
let lin_approx_compose_exp = Sections.finalize_theorem lin_approx_compose_exp;;
let lin_approx_compose_log = Sections.finalize_theorem lin_approx_compose_log;;
let lin_approx_compose_cos = Sections.finalize_theorem lin_approx_compose_cos;;
let lin_approx_compose_sin = Sections.finalize_theorem lin_approx_compose_sin;;
let lin_approx_compose_inv = Sections.finalize_theorem lin_approx_compose_inv;;
let lin_approx_compose_sqrt = Sections.finalize_theorem lin_approx_compose_sqrt;;
let lin_approx_compose_acs = Sections.finalize_theorem lin_approx_compose_acs;;
let lin_approx_compose_asn = Sections.finalize_theorem lin_approx_compose_asn;;
let lin_approx_compose_matan = Sections.finalize_theorem lin_approx_compose_matan;;
Sections.end_section "LinearApproxUnivariateComposition";;
(Sections.add_section_hyp "approx_f" (`lin_approx f x f_bounds df_bounds`));;
(Sections.add_section_hyp "approx_g" (`lin_approx g x g_bounds dg_bounds`));;

(* Lemma lin_approx_imp_add_diff *)
let lin_approx_imp_add_diff = Sections.section_proof []
`(\x. f x + g x) real_differentiable atreal x`
[
   (((use_arg_then2 ("REAL_DIFFERENTIABLE_ADD", [REAL_DIFFERENTIABLE_ADD])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_ADD") THEN (DISCH_THEN apply_tac));
   (((((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_imp_sub_diff *)
let lin_approx_imp_sub_diff = Sections.section_proof []
`(\x. f x - g x) real_differentiable atreal x`
[
   (((use_arg_then2 ("REAL_DIFFERENTIABLE_SUB", [REAL_DIFFERENTIABLE_SUB])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_SUB") THEN (DISCH_THEN apply_tac));
   (((((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_imp_mul_diff *)
let lin_approx_imp_mul_diff = Sections.section_proof []
`(\x. f x * g x) real_differentiable atreal x`
[
   (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_MUL_ATREAL") THEN (DISCH_THEN apply_tac));
   (((((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_imp_div_diff *)
let lin_approx_imp_div_diff = Sections.section_proof []
`interval_not_zero g_bounds ==> (\x. f x / g x) real_differentiable atreal x`
[
   ((BETA_TAC THEN (move ["gn0"])) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_DIV_ATREAL", [REAL_DIFFERENTIABLE_DIV_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_DIV_ATREAL") THEN (DISCH_THEN apply_tac)));
   ((((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (disch_tac [])) THEN (clear_assumption "interval_arith_not_zero") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("g_bounds", [])) (term_tac exists_tac)));
   ((((use_arg_then2 ("approx_g", [])) (disch_tac [])) THEN (clear_assumption "approx_g") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section MoreLinearApproximation *)
let interval_arith_not_zero = Sections.finalize_theorem interval_arith_not_zero;;
let interval_arith_pos = Sections.finalize_theorem interval_arith_pos;;
let interval_arith_neg = Sections.finalize_theorem interval_arith_neg;;
let interval_arith_abs = Sections.finalize_theorem interval_arith_abs;;
let lin_approx_x = Sections.finalize_theorem lin_approx_x;;
let lin_approx_const = Sections.finalize_theorem lin_approx_const;;
let lin_approx_compose_atn = Sections.finalize_theorem lin_approx_compose_atn;;
let lin_approx_compose_exp = Sections.finalize_theorem lin_approx_compose_exp;;
let lin_approx_compose_log = Sections.finalize_theorem lin_approx_compose_log;;
let lin_approx_compose_cos = Sections.finalize_theorem lin_approx_compose_cos;;
let lin_approx_compose_sin = Sections.finalize_theorem lin_approx_compose_sin;;
let lin_approx_compose_inv = Sections.finalize_theorem lin_approx_compose_inv;;
let lin_approx_compose_sqrt = Sections.finalize_theorem lin_approx_compose_sqrt;;
let lin_approx_compose_acs = Sections.finalize_theorem lin_approx_compose_acs;;
let lin_approx_compose_asn = Sections.finalize_theorem lin_approx_compose_asn;;
let lin_approx_compose_matan = Sections.finalize_theorem lin_approx_compose_matan;;
let lin_approx_imp_add_diff = Sections.finalize_theorem lin_approx_imp_add_diff;;
let lin_approx_imp_sub_diff = Sections.finalize_theorem lin_approx_imp_sub_diff;;
let lin_approx_imp_mul_diff = Sections.finalize_theorem lin_approx_imp_mul_diff;;
let lin_approx_imp_div_diff = Sections.finalize_theorem lin_approx_imp_div_diff;;
Sections.end_section "MoreLinearApproximation";;

(* Section LinearApproxArith *)
Sections.begin_section "LinearApproxArith";;
(Sections.add_section_var (mk_var ("f1", (`:real->real`))); Sections.add_section_var (mk_var ("f2", (`:real->real`))));;
(Sections.add_section_var (mk_var ("f1_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("f2_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("df1_lo", (`:real`))); Sections.add_section_var (mk_var ("df1_hi", (`:real`))); Sections.add_section_var (mk_var ("df2_lo", (`:real`))); Sections.add_section_var (mk_var ("df2_hi", (`:real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("df_lo", (`:real`))); Sections.add_section_var (mk_var ("df_hi", (`:real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;
(Sections.add_section_hyp "approx1" (`lin_approx f1 x f1_bounds (df1_lo, df1_hi)`));;

(* Lemma lin_approx_scale *)
let lin_approx_scale = Sections.section_proof ["c"]
`&0 <= c ==> interval_arith (c * f1 x) f_bounds /\
	df_lo <= c * df1_lo /\ c * df1_hi <= df_hi ==>
	lin_approx (\x. c * f1 x) x f_bounds (df_lo, df_hi)`
[
   (((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (move ["c0"]) THEN (move ["ineqs"]));
   (((((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (split_tac));
   ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN ((use_arg_then2 ("approx1", [])) (disch_tac [])) THEN (clear_assumption "approx1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("approx1", [])) (disch_tac [])) THEN (clear_assumption "approx1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["int_f1"])) THEN (case THEN (move ["f1'"])) THEN (case THEN ((move ["df1"]) THEN (move ["int_f1'"])))));
   (((fun arg_tac -> arg_tac (Arg_term (`c * f1'`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("int_f1'", [])) (disch_tac [])) THEN (clear_assumption "int_f1'") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineqs2"])) THEN (split_tac) THEN (((use_arg_then2 ("REAL_LE_TRANS", [REAL_LE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LE_TRANS") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`c * df1_lo`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_LMUL", [REAL_LE_LMUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`c * df1_hi`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_LMUL", [REAL_LE_LMUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_hyp "approx2" (`lin_approx f2 x f2_bounds (df2_lo, df2_hi)`));;

(* Lemma lin_approx_add *)
let lin_approx_add = Sections.section_proof []
`interval_arith (f1 x + f2 x) f_bounds /\
	df_lo <= df1_lo + df2_lo /\ df1_hi + df2_hi <= df_hi ==>
	lin_approx (\x. f1 x + f2 x) x f_bounds (df_lo, df_hi)`
[
   (((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineqs"]));
   (((((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (split_tac));
   ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN ((use_arg_then2 ("approx2", [])) (disch_tac [])) THEN (clear_assumption "approx2") THEN ((use_arg_then2 ("approx1", [])) (disch_tac [])) THEN (clear_assumption "approx1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("approx2", [])) (disch_tac [])) THEN (clear_assumption "approx2") THEN ((use_arg_then2 ("approx1", [])) (disch_tac [])) THEN (clear_assumption "approx1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["int_f1"])) THEN (case THEN (move ["f1'"])) THEN (case THEN ((move ["df1"]) THEN (move ["int_f1'"])))));
   (BETA_TAC THEN (case THEN (move ["int_f2"])) THEN (case THEN (move ["f2'"])) THEN (case THEN ((move ["df2"]) THEN (move ["int_f2'"]))));
   (((fun arg_tac -> arg_tac (Arg_term (`f1' + f2':real`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("int_f2'", [])) (disch_tac [])) THEN (clear_assumption "int_f2'") THEN ((use_arg_then2 ("int_f1'", [])) (disch_tac [])) THEN (clear_assumption "int_f1'") THEN ((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section LinearApproxArith *)
let lin_approx_scale = Sections.finalize_theorem lin_approx_scale;;
let lin_approx_add = Sections.finalize_theorem lin_approx_add;;
Sections.end_section "LinearApproxArith";;

(* Section SecondDerivativeBound *)
Sections.begin_section "SecondDerivativeBound";;
(Sections.add_section_var (mk_var ("f1", (`:real->real`))); Sections.add_section_var (mk_var ("f2", (`:real->real`))));;
(Sections.add_section_var (mk_var ("int", (`:real#real`))));;
(Sections.add_section_var (mk_var ("dd1", (`:real#real`))); Sections.add_section_var (mk_var ("dd2", (`:real#real`))));;

(* Lemma nth_diff_strong2_eq_alt *)
let nth_diff_strong2_eq_alt = Sections.section_proof ["f";"x"]
`nth_diff_strong 2 f x <=> ?s. real_open s /\ x IN s /\
	!y. y IN s ==> (f has_real_derivative derivative f y) (atreal y) /\
	(derivative f has_real_derivative nth_derivative 2 f y) (atreal y)`
[
   ((((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i < 2 <=> i = 0 \/ i = 1`)))(thm_tac (new_rewrite [] [])))));
   ((split_tac) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["df"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (case THEN (move ["_"])) THEN (move ["h"])));
   ((((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN ((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (simp_tac)) THEN (((((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"])));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`derivative f y`))) (term_tac exists_tac)) THEN (done_tac));
   ((BETA_TAC THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN ((repeat_tactic 0 10 (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((fun arg_tac ->(use_arg_then2 ("nth_derivative0", [nth_derivative0]))(fun tmp_arg1 -> (use_arg_then2 ("nth_derivative1", [nth_derivative1]))(fun tmp_arg2 -> arg_tac (Arg_theorem (CONJ (get_arg_thm tmp_arg1) (get_arg_thm tmp_arg2))))))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma nth_diff_strong2_eq *)
let nth_diff_strong2_eq = Sections.section_proof ["f";"x"]
`nth_diff_strong 2 f x <=> ?s. real_open s /\ x IN s /\
	!y. y IN s ==> f real_differentiable atreal y /\ derivative f real_differentiable atreal y`
[
   ((((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("TWO", [TWO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL nth_differentiable)))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))));
   ((split_tac) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["df"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"])) THEN (done_tac));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("h", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose *)
let lin_approx_compose = Sections.section_proof ["f";"g";"y";"g_bounds";"f_bounds";"d_bounds"]
`nth_diff_strong_int 2 g_bounds f ==>
	  g real_differentiable atreal y ==>
	  interval_arith (g y) g_bounds ==>
	  bounded_on_int f g_bounds f_bounds ==>
	  interval_arith (derivative g y * derivative f (g y)) d_bounds ==>
	  lin_approx (\x. f (g x)) y f_bounds d_bounds`
[
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["g_int"]) THEN (move ["f_int"]) THEN (move ["dfg_int"]));
   ((fun arg_tac -> arg_tac (Arg_term (`f real_differentiable atreal (g y)`))) (term_tac (have_gen_tac [](move ["dfgy"]))));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("g_int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["ys"])) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("dfg_int", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("f_int", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (exact_tac)) THEN (done_tac));
];;

(* Lemma second_derivative_abs_pos *)
let second_derivative_abs_pos = Sections.section_proof ["x"]
`&0 < x ==> nth_derivative 2 abs x = &0`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_pos"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL", [HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL") THEN (DISCH_THEN apply_tac)));
   ((((fun arg_tac -> arg_tac (Arg_term (`\x. &1`))) (term_tac exists_tac)) THEN ((use_arg_then2 ("x", [])) (term_tac exists_tac))) THEN (((((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("x_pos", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["t"]) THEN (move ["t_ineq"])));
   ((((use_arg_then2 ("derivative_abs_pos", [derivative_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN ((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_abs_neg *)
let second_derivative_abs_neg = Sections.section_proof ["x"]
`x < &0 ==> nth_derivative 2 abs x = &0`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_neg"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL", [HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_TRANSFORM_ATREAL") THEN (DISCH_THEN apply_tac)));
   ((((fun arg_tac -> arg_tac (Arg_term (`\x. -- &1`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`--x`))) (term_tac exists_tac))) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)));
   ((THENL_FIRST) ((THENL) (split_tac) [ALL_TAC; ((move ["t"]) THEN (move ["t_ineq"]))]) ((((use_arg_then2 ("x_neg", [])) (disch_tac [])) THEN (clear_assumption "x_neg") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("derivative_abs_neg", [derivative_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN ((use_arg_then2 ("x_neg", [])) (disch_tac [])) THEN (clear_assumption "x_neg") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_abs_pos *)
let diff2_abs_pos = Sections.section_proof ["x"]
`&0 < x ==> nth_diff_strong 2 abs x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ABS_POS", [REAL_DIFFERENTIABLE_AT_ABS_POS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. &1`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - abs y, y + abs y)`))) (term_tac exists_tac))));
   ((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((THENL_FIRST) ((THENL) (split_tac) [ALL_TAC; ((move ["t"]) THEN (move ["t_ineq"]))]) ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("derivative_abs_pos", [derivative_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN ((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_abs_neg *)
let diff2_abs_neg = Sections.section_proof ["x"]
`x < &0 ==> nth_diff_strong 2 abs x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ABS_NEG", [REAL_DIFFERENTIABLE_AT_ABS_NEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. -- &1`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - abs y, y + abs y)`))) (term_tac exists_tac))));
   ((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((THENL_FIRST) ((THENL) (split_tac) [ALL_TAC; ((move ["t"]) THEN (move ["t_ineq"]))]) ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("derivative_abs_neg", [derivative_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN ((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma pow_x_has_real_derivative *)
let pow_x_has_real_derivative = Sections.section_proof ["n";"x"]
`((\x. x pow n) has_real_derivative &n * x pow (n - 1)) (atreal x)`
[
   ((((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(gsym_then (thm_tac (new_rewrite [] [(`x pow (n - 1)`)]))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_POW_ATREAL", [HAS_REAL_DERIVATIVE_POW_ATREAL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma second_derivative_pow_x *)
let second_derivative_pow_x = Sections.section_proof ["n"]
`derivative (derivative (\x. x pow n)) = (\x. &(n * (n - 1)) * x pow (n - 2))`
[
   ((((((use_arg_then2 ("derivative_pow_x", [derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["x"]) THEN (simp_tac)) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("REAL_OF_NUM_MUL", [REAL_OF_NUM_MUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `n - 2 = (n - 1) - 1`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("pow_x_has_real_derivative", [pow_x_has_real_derivative]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_pow_x *)
let diff2_pow_x = Sections.section_proof ["n";"x"]
`nth_diff_strong 2 (\x. x pow n) x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_pow_x", [derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("pow_x_has_real_derivative", [pow_x_has_real_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_pow_x", [second_derivative_pow_x]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_OF_NUM_MUL", [REAL_OF_NUM_MUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `n - 2 = (n - 1) - 1`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("pow_x_has_real_derivative", [pow_x_has_real_derivative]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_pow2_x *)
let second_derivative_pow2_x = Sections.section_proof []
`derivative (derivative (\x. x pow 2)) = (\x. &2)`
[
   ((((use_arg_then2 ("second_derivative_pow_x", [second_derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subnn", [subnn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_pow", [real_pow]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 * (2 - 1) = 2`)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma second_derivative_pow3_x *)
let second_derivative_pow3_x = Sections.section_proof []
`derivative (derivative (\x. x pow 3)) = (\x. &6 * x)`
[
   ((((use_arg_then2 ("second_derivative_pow_x", [second_derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 * (3 - 1) = 6 /\ 3 - 2 = 1`)))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma second_derivative_atn_eq *)
let second_derivative_atn_eq = Sections.section_proof ["x"]
`((\x. inv (&1 + x pow 2)) has_real_derivative 
	(-- &2 * x) * inv (&1 + x pow 2) pow 2) (atreal x)`
[
   (((((use_arg_then2 ("REAL_POW_INV", [REAL_POW_INV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_div", [real_div]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_LMUL", [REAL_NEG_LMUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_INV_ATREAL", [HAS_REAL_DERIVATIVE_INV_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("REAL_ADD_LID", [REAL_ADD_LID])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`&2 * x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&2 * x = x * &1 + &1 * x`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("HAS_REAL_DERIVATIVE_MUL_ATREAL", [HAS_REAL_DERIVATIVE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("REAL_LT_IMP_NZ", [REAL_LT_IMP_NZ]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_ADD1", [REAL_LT_ADD1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_POW_2", [REAL_LE_POW_2]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_atn *)
let second_derivative_atn = Sections.section_proof []
`derivative (derivative atn) = (\x. (-- &2 * x) * inv (&1 + x pow 2) pow 2)`
[
   ((((((use_arg_then2 ("derivative_atn", [derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["x"]) THEN (simp_tac)) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("second_derivative_atn_eq", [second_derivative_atn_eq]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_atn *)
let diff2_atn = Sections.section_proof ["x"]
`nth_diff_strong 2 atn x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_atn", [derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATN", [HAS_REAL_DERIVATIVE_ATN]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_atn", [second_derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("second_derivative_atn_eq", [second_derivative_atn_eq]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_cos *)
let second_derivative_cos = Sections.section_proof []
`nth_derivative 2 cos = (\x. --cos x)`
[
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["x"]));
   (((((use_arg_then2 ("derivative_neg", [derivative_neg]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SIN", [REAL_DIFFERENTIABLE_AT_SIN]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_cos *)
let diff2_cos = Sections.section_proof ["x"]
`nth_diff_strong 2 cos x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_COS", [HAS_REAL_DERIVATIVE_COS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("second_derivative_cos", [second_derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_NEG", [HAS_REAL_DERIVATIVE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_SIN", [HAS_REAL_DERIVATIVE_SIN]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sin *)
let second_derivative_sin = Sections.section_proof []
`nth_derivative 2 sin = (\x. --sin x)`
[
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_sin *)
let diff2_sin = Sections.section_proof ["x"]
`nth_diff_strong 2 sin x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_SIN", [HAS_REAL_DERIVATIVE_SIN]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("second_derivative_sin", [second_derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_COS", [HAS_REAL_DERIVATIVE_COS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_exp *)
let second_derivative_exp = Sections.section_proof []
`nth_derivative 2 exp = exp`
[
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("derivative_exp", [derivative_exp]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma diff2_exp *)
let diff2_exp = Sections.section_proof ["x"]
`nth_diff_strong 2 exp x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_exp", [derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_EXP", [HAS_REAL_DERIVATIVE_EXP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("second_derivative_exp", [second_derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_EXP", [HAS_REAL_DERIVATIVE_EXP]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_log *)
let second_derivative_log = Sections.section_proof ["x"]
`&0 < x ==> nth_derivative 2 log x = --inv (x pow 2)`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`(\x. inv x)`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. inv x) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&0 < x ==> ~(x = &0)`)))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. -- &1 * a = --a`)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_log", [derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_log *)
let diff2_log = Sections.section_proof ["x"]
`&0 < x ==> nth_diff_strong 2 log x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_LOG", [REAL_DIFFERENTIABLE_AT_LOG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. inv x`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - abs y, y + abs y)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]);
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("derivative_log", [derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_inv *)
let second_derivative_inv = Sections.section_proof ["x"]
`~(x = &0) ==> nth_derivative 2 inv x = &2 * inv (x pow 3)`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["xn0"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`(\x. -- inv (x * x))`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. -- inv(x * x)) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   ((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xn0", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_2", [REAL_MUL_2]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `(x * x) pow 2 = x * x pow 3`)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] []))))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. (&2 * x) * inv x * a = &2 * (x * inv x) * a`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_inv", [derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_inv *)
let diff2_inv = Sections.section_proof ["x"]
`~(x = &0) ==> nth_diff_strong 2 inv x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["xn0"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_INV", [REAL_DIFFERENTIABLE_AT_INV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. --inv (x * x)`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - abs y, y + abs y)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_NEG", [REAL_DIFFERENTIABLE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]);
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("derivative_inv", [derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma SQRT_POW *)
let SQRT_POW = Sections.section_proof ["x";"n"]
`sqrt x pow n = sqrt (x pow n)`
[
   (((THENL) (((use_arg_then2 ("n", [])) (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("SQRT_1", [SQRT_1]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("IHn", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_MUL", [SQRT_MUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sqrt *)
let second_derivative_sqrt = Sections.section_proof ["x"]
`&0 < x ==> nth_derivative 2 sqrt x = -- inv(&4 * sqrt (x pow 3))`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_pos"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`(\x. inv (&2 * sqrt x))`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. inv(&2 * sqrt x)) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   ((fun arg_tac -> arg_tac (Arg_term (`~(&2 * sqrt x = &0)`))) (term_tac (have_gen_tac [](move ["ineq"]))));
   (((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("negb_or", [negb_or]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("x_pos", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineq", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_POW", [REAL_INV_POW]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_INV_POW", [REAL_INV_POW]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_MUL", [REAL_POW_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))))) ((arith_tac) THEN (done_tac)));
   (((((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&2 pow 2 = &4`)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `SUC 2 = 3`)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (&0, x + &1)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_sqrt", [derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma diff2_sqrt *)
let diff2_sqrt = Sections.section_proof ["x"]
`&0 < x ==> nth_diff_strong 2 sqrt x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_pos"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (&0, x + &1)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. inv (&2 * sqrt x)`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (&0, y + &1)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]) ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("derivative_sqrt", [derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma real_powS *)
let real_powS = Sections.section_proof ["x";"n"]
`x pow (SUC n) = x * x pow n`
[
   ((((use_arg_then2 ("real_pow", [real_pow]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma second_derivative_acs *)
let second_derivative_acs = Sections.section_proof ["x"]
`abs x < &1 ==> 
	nth_derivative 2 acs x = --(x / sqrt ((&1 - x * x) pow 3))`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`\x. --inv (sqrt (&1 - x * x))`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. --inv (sqrt (&1 - x * x))) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - x * x /\ ~(sqrt(&1 - x * x) = &0)`))) (term_tac (have_gen_tac [](move ["ineqs"]))));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - x * x`))) (term_tac (have_gen_tac [](move ["h"])))));
   (((((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&1 - x * x = (&1 - x) * (&1 + x)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_LZERO", [REAL_SUB_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_2", [REAL_MUL_2]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. (&2 * x) * inv (&2) * a = (&2 * inv (&2)) * x * a`)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `SUC 2 = 3`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs x`))) (term_tac (set_tac "e")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - e, x + e)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_acs", [derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_acs *)
let diff2_acs = Sections.section_proof ["x"]
`abs x < &1 ==> nth_diff_strong 2 acs x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs x`))) (term_tac (set_tac "e")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - e, x + e)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ACS", [REAL_DIFFERENTIABLE_AT_ACS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs y`))) (term_tac (set_tac "e2")));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. --inv (sqrt (&1 - x * x))`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - e2, y + e2)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_NEG", [REAL_DIFFERENTIABLE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] [])))));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - y * y`))) (term_tac (have_gen_tac [](move ["gt0"]))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&1 - y * y = (&1 - y) * (&1 + y)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_LT_IMP_NZ", [REAL_LT_IMP_NZ]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`(\x. sqrt (&1 - x * x)) = sqrt o (\x. &1 - x * x)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_SUB", [REAL_DIFFERENTIABLE_SUB]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]);
   ((((use_arg_then2 ("e2_def", [])) (disch_tac [])) THEN (clear_assumption "e2_def") THEN ((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_acs", [derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("e2_def", [])) (disch_tac [])) THEN (clear_assumption "e2_def") THEN ((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_asn *)
let second_derivative_asn = Sections.section_proof ["x"]
`abs x < &1 ==> 
	nth_derivative 2 asn x = x / sqrt ((&1 - x * x) pow 3)`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`\x. inv (sqrt (&1 - x * x))`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. inv (sqrt (&1 - x * x))) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - x * x /\ ~(sqrt(&1 - x * x) = &0)`))) (term_tac (have_gen_tac [](move ["ineqs"]))));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - x * x`))) (term_tac (have_gen_tac [](move ["h"])))));
   (((((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&1 - x * x = (&1 - x) * (&1 + x)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_LZERO", [REAL_SUB_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_2", [REAL_MUL_2]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. (&2 * x) * inv (&2) * a = (&2 * inv (&2)) * x * a`)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `SUC 2 = 3`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs x`))) (term_tac (set_tac "e")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - e, x + e)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_asn", [derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_asn *)
let diff2_asn = Sections.section_proof ["x"]
`abs x < &1 ==> nth_diff_strong 2 asn x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs x`))) (term_tac (set_tac "e")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - e, x + e)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ASN", [REAL_DIFFERENTIABLE_AT_ASN]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs y`))) (term_tac (set_tac "e2")));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. inv (sqrt (&1 - x * x))`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - e2, y + e2)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] []))));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - y * y`))) (term_tac (have_gen_tac [](move ["gt0"]))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&1 - y * y = (&1 - y) * (&1 + y)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_LT_IMP_NZ", [REAL_LT_IMP_NZ]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`(\x. sqrt (&1 - x * x)) = sqrt o (\x. &1 - x * x)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_SUB", [REAL_DIFFERENTIABLE_SUB]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]);
   ((((use_arg_then2 ("e2_def", [])) (disch_tac [])) THEN (clear_assumption "e2_def") THEN ((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_asn", [derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("e2_def", [])) (disch_tac [])) THEN (clear_assumption "e2_def") THEN ((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_matan *)
let second_derivative_matan = Sections.section_proof ["x"]
`nth_derivative 2 matan x = ddmatan x`
[
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_eq_real_derivative", [derivative_eq_real_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ddmatan", [ddmatan]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_matan *)
let diff2_matan = Sections.section_proof ["x"]
`-- &1 < x ==> nth_diff_strong 2 matan x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (-- &1, x + &1)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("matan_differentiable", [matan_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`dmatan`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (-- &1, y + &1)`))) (term_tac exists_tac))));
   ((THENL_ROT (-1)) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac)));
   ((THENL_FIRST) ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]) ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("derivative_matan", [derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`y < &1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (move ["y_ineq"]));
   ((((use_arg_then2 ("dmatan", [dmatan]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("matan_second_derivative_abs1", [matan_second_derivative_abs1]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN ((use_arg_then2 ("y_ineq", [])) (disch_tac [])) THEN (clear_assumption "y_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("dmatan", [dmatan]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`\x. inv (&2 * x * (x + &1)) - atn (sqrt x) / (&2 * x * sqrt x)`))) (term_tac (set_tac "f'")));
   (((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - &1, y + &1)`))) (term_tac exists_tac)));
   ((THENL_ROT (-1)) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac)));
   ((THENL_FIRST) (split_tac) ((arith_tac) THEN (done_tac)));
   ((BETA_TAC THEN (move ["t"]) THEN (move ["t_ineq"])) THEN ((((use_arg_then2 ("f'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("matan_real_derivative_gt0", [matan_real_derivative_gt0]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("y_ineq", [])) (disch_tac [])) THEN (clear_assumption "y_ineq") THEN ((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))));
   (((fun arg_tac -> (use_arg_then2 ("matan_has_derivative2_gt0", [matan_has_derivative2_gt0])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN (((use_arg_then2 ("f'_def", []))(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> arg_tac (Arg_term (`_1 - _2`))) (term_tac (set_tac "f''"))) THEN (BETA_TAC THEN (move ["h"])));
   (((use_arg_then2 ("f''", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("h", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("y_ineq", [])) (disch_tac [])) THEN (clear_assumption "y_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Section SecondDerivativeCompose *)
Sections.begin_section "SecondDerivativeCompose";;

(* Lemma REAL_CONTINUOUS_OPEN_PREIMAGE *)
let REAL_CONTINUOUS_OPEN_PREIMAGE = Sections.section_proof ["f";"s";"t"]
`f real_continuous_on s ==> real_open s ==> real_open t ==>
	real_open {x | x IN s /\ f x IN t}`
[
   (BETA_TAC THEN (move ["f_cont"]) THEN (move ["open_s"]) THEN (move ["open_t"]));
   (((use_arg_then2 ("REAL_OPEN", [REAL_OPEN]))(thm_tac (new_rewrite [] []))));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`IMAGE lift {x | x IN s /\ f x IN t} = 
	{x | x IN (IMAGE lift s) /\ (lift o f o drop) x IN (IMAGE lift t)}`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))));
   (((((use_arg_then2 ("CONTINUOUS_OPEN_PREIMAGE", [CONTINUOUS_OPEN_PREIMAGE]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN", [REAL_OPEN]))(gsym_then (thm_tac (new_rewrite [] []))))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_CONTINUOUS_ON", [REAL_CONTINUOUS_ON]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((((use_arg_then2 ("EXTENSION", [EXTENSION]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_IMAGE_LIFT_DROP", [IN_IMAGE_LIFT_DROP]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE_LIFT_DROP", [IN_IMAGE_LIFT_DROP]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (simp_tac)) THEN (split_tac));
   ((BETA_TAC THEN (case THEN (move ["x"])) THEN (case THEN (move ["x_in"])) THEN (move ["x_eq"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`lift x`))) (term_tac exists_tac)));
   (((repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("x_in", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("x_eq", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["x"])) THEN (case THEN (move ["x_in"])) THEN (move ["x_eq"]));
   (((fun arg_tac -> arg_tac (Arg_term (`drop x`))) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma second_derivative_compose *)
let second_derivative_compose = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 g x ==> nth_diff_strong 2 f (g x) ==>
	nth_derivative 2 (\x. f (g x)) x = 
	nth_derivative 2 f (g x) * (derivative g x) pow 2 + derivative f (g x) * nth_derivative 2 g x`
[
   (BETA_TAC THEN (move ["dg"]) THEN (move ["df"]));
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   ((THENL_ROT (-1)) (((fun arg_tac -> arg_tac (Arg_term (`\x. derivative f (g x) * derivative g x`))) (term_tac exists_tac)) THEN (split_tac)));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["gxs"])) THEN (move ["d_f"]) THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["d_g"])));
   ((fun arg_tac -> arg_tac (Arg_term (`{z | z IN t /\ g z IN s}`))) (term_tac (set_tac "s'")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_open s'`))) (term_tac (have_gen_tac [](move ["open_s'"]))));
   ((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_CONTINUOUS_OPEN_PREIMAGE", [REAL_CONTINUOUS_OPEN_PREIMAGE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("open_t", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_ON_EQ_REAL_CONTINUOUS_AT", [REAL_CONTINUOUS_ON_EQ_REAL_CONTINUOUS_AT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (move ["y"]) THEN (move ["yt"]));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("d_g", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`t INTER s'`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN ((use_arg_then2 ("x", [])) (term_tac exists_tac)) THEN (done_tac));
   ((BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["yt"]) THEN (move ["ys'"])))) THEN ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("d_g", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("d_f", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("ys'", [])) (disch_tac [])) THEN (clear_assumption "ys'") THEN BETA_TAC) THEN (((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["z"])) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (move ["d_f"]) THEN (case THEN (move ["_"])) THEN (move ["d_g"])));
   ((THENL_ROT (-1)) (((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_MUL_ATREAL", [HAS_REAL_DERIVATIVE_MUL_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (split_tac)));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("d_g", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`derivative f`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFF_CHAIN_ATREAL", [REAL_DIFF_CHAIN_ATREAL]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("d_g", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("d_f", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose *)
let diff2_compose = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 g x ==> nth_diff_strong 2 f (g x) ==>
	nth_diff_strong 2 (\x. f (g x)) x`
[
   ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["dg"]) THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["gxt"])) THEN (move ["df"]));
   ((fun arg_tac -> arg_tac (Arg_term (`{z | z IN s /\ g z IN t}`))) (term_tac (set_tac "s'")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_open s'`))) (term_tac (have_gen_tac [](move ["open_s'"]))));
   ((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_CONTINUOUS_OPEN_PREIMAGE", [REAL_CONTINUOUS_OPEN_PREIMAGE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("open_t", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_ON_EQ_REAL_CONTINUOUS_AT", [REAL_CONTINUOUS_ON_EQ_REAL_CONTINUOUS_AT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (move ["y"]) THEN (move ["yt"]));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER s'`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("x", [])) (term_tac exists_tac)) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (move ["ys'"]))));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("ys'", [])) (disch_tac [])) THEN (clear_assumption "ys'") THEN BETA_TAC) THEN (((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["z"])) THEN (simp_tac)) THEN (done_tac));
   (((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac));
   ((THENL_ROT (-1)) ((((fun arg_tac -> arg_tac (Arg_term (`\x. derivative g x * derivative f (g x)`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`s INTER s'`))) (term_tac exists_tac))) THEN (split_tac)));
   (((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ys'", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["z_in"]));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("z_in", [])) (disch_tac [])) THEN (clear_assumption "z_in") THEN BETA_TAC) THEN (((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`derivative f`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("ys'", [])) (disch_tac [])) THEN (clear_assumption "ys'") THEN BETA_TAC) THEN (((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["z"])) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma continuous_not0_exists_open *)
let continuous_not0_exists_open = Sections.section_proof ["f";"x"]
`~(f x = &0) ==> f real_continuous atreal x ==>
	?s. real_open s /\ x IN s /\ !y. y IN s ==> ~(f y = &0)`
[
   ((((use_arg_then2 ("real_continuous_atreal", [real_continuous_atreal]))(thm_tac (new_rewrite [] [])))) THEN (move ["fn0"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`abs (f x)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)));
   ((THENL_FIRST) (ANTS_TAC) ((((use_arg_then2 ("fn0", [])) (disch_tac [])) THEN (clear_assumption "fn0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   (BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - d, x + d)`))) (term_tac exists_tac));
   ((THENL_FIRST) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [ALL_TAC; (move ["y"])])) ((((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("fn0", [])) (disch_tac [])) THEN (clear_assumption "fn0") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_gt_exists_open *)
let continuous_gt_exists_open = Sections.section_proof ["a";"f";"x"]
`a < f x ==> f real_continuous atreal x ==>
	?s. real_open s /\ x IN s /\ !y. y IN s ==> a < f y`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("real_continuous_atreal", [real_continuous_atreal]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x - a`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) ((((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   (BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - d, x + d)`))) (term_tac exists_tac));
   ((THENL_FIRST) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [ALL_TAC; (move ["y"])])) ((((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_lt_exists_open *)
let continuous_lt_exists_open = Sections.section_proof ["a";"f";"x"]
`f x < a ==> f real_continuous atreal x ==>
	?s. real_open s /\ x IN s /\ !y. y IN s ==> f y < a`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("real_continuous_atreal", [real_continuous_atreal]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`a - f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) ((((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   (BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - d, x + d)`))) (term_tac exists_tac));
   ((THENL_FIRST) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [ALL_TAC; (move ["y"])])) ((((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real->real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;
(Sections.add_section_hyp "df" (`nth_diff_strong 2 f x`));;

(* Lemma second_derivative_compose_abs_pos *)
let second_derivative_compose_abs_pos = Sections.section_proof []
`&0 < f x ==>
	nth_derivative 2 (\x. abs (f x)) x = nth_derivative 2 f x`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_abs_pos", [diff2_abs_pos]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_abs_pos", [second_derivative_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_abs_pos", [derivative_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_abs_neg *)
let second_derivative_compose_abs_neg = Sections.section_proof []
`f x < &0 ==>
	nth_derivative 2 (\x. abs (f x)) x = --nth_derivative 2 f x`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_abs_neg", [diff2_abs_neg]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_abs_neg", [second_derivative_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_abs_neg", [derivative_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_pow *)
let second_derivative_compose_pow = Sections.section_proof ["n"]
`nth_derivative 2 (\x. f x pow n) x =
		 &n * (nth_derivative 2 f x * f x pow (n - 1) 
	   	 + &(n - 1) * f x pow (n - 2) * derivative f x pow 2)`
[
   ((fun arg_tac -> arg_tac (Arg_term (`\x. x pow n`))) (term_tac (set_tac "g")));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`(\x. f x pow n) = (\x. g (f x))`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) ((((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_pow_x", [diff2_pow_x]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_pow_x", [second_derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_pow_x", [derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((((use_arg_then2 ("REAL_OF_NUM_MUL", [REAL_OF_NUM_MUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_pow2 *)
let second_derivative_compose_pow2 = Sections.section_proof []
`nth_derivative 2 (\x. f x pow 2) x =
		 &2 * (nth_derivative 2 f x * f x + derivative f x pow 2)`
[
   ((((use_arg_then2 ("second_derivative_compose_pow", [second_derivative_compose_pow]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 - 1 = 1`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subnn", [subnn]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_pow3 *)
let second_derivative_compose_pow3 = Sections.section_proof []
`nth_derivative 2 (\x. f x pow 3) x =
		 &3 * (nth_derivative 2 f x * f x pow 2 + &2 * f x * derivative f x pow 2)`
[
   ((((use_arg_then2 ("second_derivative_compose_pow", [second_derivative_compose_pow]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 - 1 = 2 /\ 3 - 2 = 1`)))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] [])))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_atn *)
let second_derivative_compose_atn = Sections.section_proof []
`nth_derivative 2 (\x. atn (f x)) x = 
	(nth_derivative 2 f x * (&1 + f x * f x) - &2 * f x * derivative f x pow 2) / (&1 + f x * f x) pow 2`
[
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_atn", [diff2_atn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_atn", [second_derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_atn", [derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_sub", [real_sub]))(gsym_then (thm_tac (new_rewrite [] []))))));
   (((fun arg_tac -> arg_tac (Arg_term (`_1 * _2`))) (term_tac (set_tac "lhs1"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`_1 * _2`))) (term_tac (set_tac "lhs2"))));
   ((((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_POW", [REAL_INV_POW]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_RDISTRIB", [REAL_SUB_RDISTRIB]))(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> arg_tac (Arg_term (`_1 * _2`))) (term_tac (set_tac "rhs1"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`_1 * _2`))) (term_tac (set_tac "rhs2"))));
   (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `lhs1 = rhs1 /\ lhs2 = rhs2 ==> lhs1 - lhs2 = rhs1 - rhs2`))) (disch_tac [])) THEN (DISCH_THEN apply_tac));
   (((((use_arg_then2 ("lhs2_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("rhs2_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [(`_1 * _2 pow 2`)])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((split_tac) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("rhs1_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a * b * c * d = a * (b * c) * d`)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("lhs1_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((fun arg_tac -> (use_arg_then2 ("REAL_LE_SQUARE", [REAL_LE_SQUARE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_cos *)
let second_derivative_compose_cos = Sections.section_proof []
`nth_derivative 2 (\x. cos (f x)) x = 
	--(nth_derivative 2 f x * sin (f x) + cos (f x) * derivative f x pow 2)`
[
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_cos", [diff2_cos]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_cos", [second_derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_sin *)
let second_derivative_compose_sin = Sections.section_proof []
`nth_derivative 2 (\x. sin (f x)) x = 
	nth_derivative 2 f x * cos (f x) - sin (f x) * derivative f x pow 2`
[
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_sin", [diff2_sin]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_sin", [second_derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_exp *)
let second_derivative_compose_exp = Sections.section_proof []
`nth_derivative 2 (\x. exp (f x)) x = 
	nth_derivative 2 f x * exp (f x) + exp (f x) * derivative f x pow 2`
[
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_exp", [diff2_exp]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_exp", [second_derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_exp", [derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_log *)
let second_derivative_compose_log = Sections.section_proof []
`&0 < f x ==>
	nth_derivative 2 (\x. log (f x)) x =
	nth_derivative 2 f x / f x - (derivative f x / f x) pow 2`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_log", [diff2_log]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_log", [second_derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_log", [derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("REAL_POW_DIV", [REAL_POW_DIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_inv *)
let second_derivative_compose_inv = Sections.section_proof []
`~(f x = &0) ==>
	nth_derivative 2 (\x. inv (f x)) x =
	(&2 * derivative f x pow 2 - nth_derivative 2 f x * f x) / (f x pow 3)`
[
   (BETA_TAC THEN (move ["fn0"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_inv", [diff2_inv]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_inv", [second_derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_inv", [derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_sub", [real_sub]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_RDISTRIB", [REAL_SUB_RDISTRIB]))(thm_tac (new_rewrite [] [])))));
   ((THENL_FIRST) ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a = c /\ b = d ==> a - b = c - d`))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) ((arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("REAL_INV_POW", [REAL_INV_POW]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. (a * b) * c * d = a * (b * c) * d`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_sqrt *)
let second_derivative_compose_sqrt = Sections.section_proof []
`&0 < f x ==>
	nth_derivative 2 (\x. sqrt (f x)) x =
	(&2 * nth_derivative 2 f x * f x - derivative f x pow 2) / (&4 * sqrt (f x pow 3))`
[
   (BETA_TAC THEN (move ["f_pos"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_sqrt", [diff2_sqrt]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_sqrt", [second_derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_sqrt", [derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_sub", [real_sub]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_RDISTRIB", [REAL_SUB_RDISTRIB]))(thm_tac (new_rewrite [] [])))));
   ((THENL_LAST) ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a = c /\ b = d ==> a - b = c - d`))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) ((arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`sqrt (f x pow 3) = sqrt (f x) * f x`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_POW_2", [SQRT_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (repeat_tactic 1 9 (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. (&2 * a * b) * inv (&4) * c * d = (inv (&2) * c) * a * (b * d)`)))(thm_tac (new_rewrite [] []))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_NZ", [REAL_LT_IMP_NZ]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_acs *)
let second_derivative_compose_acs = Sections.section_proof []
`abs (f x) < &1 ==>
	nth_derivative 2 (\x. acs (f x)) x =
	-- ((nth_derivative 2 f x * (&1 - f x * f x) + f x * derivative f x pow 2) / 
	sqrt ((&1 - f x * f x) pow 3))`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_acs", [diff2_acs]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_acs", [second_derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_acs", [derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_ADD", [REAL_NEG_ADD]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_EQ_NEG2", [REAL_EQ_NEG2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ADD_RDISTRIB", [REAL_ADD_RDISTRIB]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))));
   ((THENL_LAST) ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a = c /\ b = d ==> a + b = c + d`))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) ((arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - f x * f x`))) (term_tac (set_tac "y")));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 <= y /\ &0 < y /\ ~(y = &0)`))) (term_tac (have_gen_tac [](move ["y_ineq"]))));
   ((((use_arg_then2 ("y_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. &1 - a * a = (&1 - a) * (&1 + a)`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_MUL", [REAL_LE_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`sqrt (y pow 3) = sqrt y * y`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_POW_2", [SQRT_POW_2]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. (a * b) * c * d = c * a * (b * d)`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_asn *)
let second_derivative_compose_asn = Sections.section_proof []
`abs (f x) < &1 ==>
	nth_derivative 2 (\x. asn (f x)) x =
	((nth_derivative 2 f x * (&1 - f x * f x) + f x * derivative f x pow 2) / 
	sqrt ((&1 - f x * f x) pow 3))`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_asn", [diff2_asn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_asn", [second_derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_asn", [derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ADD_RDISTRIB", [REAL_ADD_RDISTRIB]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))));
   ((THENL_LAST) ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a = c /\ b = d ==> a + b = c + d`))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) ((arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - f x * f x`))) (term_tac (set_tac "y")));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 <= y /\ &0 < y /\ ~(y = &0)`))) (term_tac (have_gen_tac [](move ["y_ineq"]))));
   ((((use_arg_then2 ("y_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. &1 - a * a = (&1 - a) * (&1 + a)`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_MUL", [REAL_LE_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`sqrt (y pow 3) = sqrt y * y`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_POW_2", [SQRT_POW_2]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. (a * b) * c * d = c * a * (b * d)`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_matan *)
let second_derivative_compose_matan = Sections.section_proof []
`-- &1 < f x ==>
	nth_derivative 2 (\x. matan (f x)) x =
	nth_derivative 2 f x * dmatan (f x) + derivative f x pow 2 * ddmatan (f x)`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_matan", [diff2_matan]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_matan", [second_derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_matan", [derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma diff2_compose_abs_pos *)
let diff2_compose_abs_pos = Sections.section_proof []
`&0 < f x ==> nth_diff_strong 2 (\x. abs (f x)) x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_abs_pos", [diff2_abs_pos]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_abs_neg *)
let diff2_compose_abs_neg = Sections.section_proof []
`f x < &0 ==> nth_diff_strong 2 (\x. abs (f x)) x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_abs_neg", [diff2_abs_neg]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_pow *)
let diff2_compose_pow = Sections.section_proof ["n"]
`nth_diff_strong 2 (\x. f x pow n) x`
[
   ((fun arg_tac -> arg_tac (Arg_term (`\x. x pow n`))) (term_tac (set_tac "g")));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`(\x. f x pow n) = (\x. g (f x))`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) ((((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("diff2_pow_x", [diff2_pow_x]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_atn *)
let diff2_compose_atn = Sections.section_proof []
`nth_diff_strong 2 (\x. atn (f x)) x`
[
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_atn", [diff2_atn]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_cos *)
let diff2_compose_cos = Sections.section_proof []
`nth_diff_strong 2 (\x. cos (f x)) x`
[
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_cos", [diff2_cos]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_sin *)
let diff2_compose_sin = Sections.section_proof []
`nth_diff_strong 2 (\x. sin (f x)) x`
[
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_sin", [diff2_sin]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_exp *)
let diff2_compose_exp = Sections.section_proof []
`nth_diff_strong 2 (\x. exp (f x)) x`
[
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_exp", [diff2_exp]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_log *)
let diff2_compose_log = Sections.section_proof []
`&0 < f x ==> nth_diff_strong 2 (\x. log (f x)) x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_log", [diff2_log]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_inv *)
let diff2_compose_inv = Sections.section_proof []
`~(f x = &0) ==> nth_diff_strong 2 (\x. inv (f x)) x`
[
   ((BETA_TAC THEN (move ["fn0"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_inv", [diff2_inv]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_sqrt *)
let diff2_compose_sqrt = Sections.section_proof []
`&0 < f x ==> nth_diff_strong 2 (\x. sqrt (f x)) x`
[
   ((BETA_TAC THEN (move ["f_pos"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_sqrt", [diff2_sqrt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_acs *)
let diff2_compose_acs = Sections.section_proof []
`abs (f x) < &1 ==> nth_diff_strong 2 (\x. acs (f x)) x`
[
   ((BETA_TAC THEN (move ["f_abs"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_acs", [diff2_acs]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_asn *)
let diff2_compose_asn = Sections.section_proof []
`abs (f x) < &1 ==> nth_diff_strong 2 (\x. asn (f x)) x`
[
   ((BETA_TAC THEN (move ["f_abs"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_asn", [diff2_asn]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_matan *)
let diff2_compose_matan = Sections.section_proof []
`-- &1 < f x ==> nth_diff_strong 2 (\x. matan (f x)) x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_matan", [diff2_matan]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section SecondDerivativeCompose *)
let REAL_CONTINUOUS_OPEN_PREIMAGE = Sections.finalize_theorem REAL_CONTINUOUS_OPEN_PREIMAGE;;
let second_derivative_compose = Sections.finalize_theorem second_derivative_compose;;
let diff2_compose = Sections.finalize_theorem diff2_compose;;
let continuous_not0_exists_open = Sections.finalize_theorem continuous_not0_exists_open;;
let continuous_gt_exists_open = Sections.finalize_theorem continuous_gt_exists_open;;
let continuous_lt_exists_open = Sections.finalize_theorem continuous_lt_exists_open;;
let second_derivative_compose_abs_pos = Sections.finalize_theorem second_derivative_compose_abs_pos;;
let second_derivative_compose_abs_neg = Sections.finalize_theorem second_derivative_compose_abs_neg;;
let second_derivative_compose_pow = Sections.finalize_theorem second_derivative_compose_pow;;
let second_derivative_compose_pow2 = Sections.finalize_theorem second_derivative_compose_pow2;;
let second_derivative_compose_pow3 = Sections.finalize_theorem second_derivative_compose_pow3;;
let second_derivative_compose_atn = Sections.finalize_theorem second_derivative_compose_atn;;
let second_derivative_compose_cos = Sections.finalize_theorem second_derivative_compose_cos;;
let second_derivative_compose_sin = Sections.finalize_theorem second_derivative_compose_sin;;
let second_derivative_compose_exp = Sections.finalize_theorem second_derivative_compose_exp;;
let second_derivative_compose_log = Sections.finalize_theorem second_derivative_compose_log;;
let second_derivative_compose_inv = Sections.finalize_theorem second_derivative_compose_inv;;
let second_derivative_compose_sqrt = Sections.finalize_theorem second_derivative_compose_sqrt;;
let second_derivative_compose_acs = Sections.finalize_theorem second_derivative_compose_acs;;
let second_derivative_compose_asn = Sections.finalize_theorem second_derivative_compose_asn;;
let second_derivative_compose_matan = Sections.finalize_theorem second_derivative_compose_matan;;
let diff2_compose_abs_pos = Sections.finalize_theorem diff2_compose_abs_pos;;
let diff2_compose_abs_neg = Sections.finalize_theorem diff2_compose_abs_neg;;
let diff2_compose_pow = Sections.finalize_theorem diff2_compose_pow;;
let diff2_compose_atn = Sections.finalize_theorem diff2_compose_atn;;
let diff2_compose_cos = Sections.finalize_theorem diff2_compose_cos;;
let diff2_compose_sin = Sections.finalize_theorem diff2_compose_sin;;
let diff2_compose_exp = Sections.finalize_theorem diff2_compose_exp;;
let diff2_compose_log = Sections.finalize_theorem diff2_compose_log;;
let diff2_compose_inv = Sections.finalize_theorem diff2_compose_inv;;
let diff2_compose_sqrt = Sections.finalize_theorem diff2_compose_sqrt;;
let diff2_compose_acs = Sections.finalize_theorem diff2_compose_acs;;
let diff2_compose_asn = Sections.finalize_theorem diff2_compose_asn;;
let diff2_compose_matan = Sections.finalize_theorem diff2_compose_matan;;
Sections.end_section "SecondDerivativeCompose";;

(* Lemma second_derivative_mul *)
let second_derivative_mul = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 f x ==>
  nth_diff_strong 2 g x ==>
  nth_derivative 2 (\x. f x * g x) x =
  f x * nth_derivative 2 g x + &2 * derivative f x * derivative g x + nth_derivative 2 f x * g x`
[
   ((BETA_TAC THEN (move ["df0"]) THEN (move ["dg0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f /\ nth_diff_strong_int 2 int g`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (case THEN ((move ["df"]) THEN (move ["dg"]))))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((split_tac) THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_mul", [nth_derivative_mul])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("TWO", [TWO]))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `!n. 0 <= SUC n`)))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("subnn", [subnn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subn0", [subn0]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 - 1 = 1`)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("binom", [binom]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("BINOM_1", [BINOM_1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("BINOM_REFL", [BINOM_REFL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ADD_ASSOC", [REAL_ADD_ASSOC]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_div *)
let second_derivative_div = Sections.section_proof ["f";"g";"x"]
`~(g x = &0) ==>
	nth_diff_strong 2 f x ==>
	nth_diff_strong 2 g x ==>
	nth_derivative 2 (\x. f x / g x) x = 
	((nth_derivative 2 f x * g x - f x * nth_derivative 2 g x) * g x -
	&2 * derivative g x * (derivative f x * g x - f x * derivative g x)) / (g x pow 3)`
[
   (BETA_TAC THEN (move ["gn0"]) THEN (move ["diff_f"]) THEN (move ["diff_g"]));
   (((fun arg_tac -> arg_tac (Arg_term (`derivative g x`))) (term_tac (set_tac "dg"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`derivative f x`))) (term_tac (set_tac "df"))));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative 2 g x`))) (term_tac (set_tac "ddg"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`nth_derivative 2 f x`))) (term_tac (set_tac "ddf"))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("second_derivative_mul", [second_derivative_mul]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("second_derivative_compose_inv", [second_derivative_compose_inv]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_compose_inv", [diff2_compose_inv]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((use_arg_then2 ("derivative_compose_inv", [derivative_compose_inv]))(thm_tac (new_rewrite [] []))));
   ((((use_arg_then2 ("diff_g", [])) (disch_tac [])) THEN (clear_assumption "diff_g") THEN BETA_TAC) THEN ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (done_tac));
   ((((use_arg_then2 ("ddf_def", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ddg_def", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df_def", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dg_def", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))));
   ((fun arg_tac -> arg_tac (Arg_term (`_1 + _2`))) (term_tac (set_tac "lhs")));
   (((fun arg_tac -> arg_tac (Arg_theorem (REAL_RING `!f g x. ((ddf * g x - f x * ddg) * g x - &2 * dg * (df * g x - f x * dg)) * 
						inv (g x pow 3) =
			f x * (&2 * dg pow 2 - ddg * g x) * inv (g x pow 3) +
			&2 * df * --(g x * inv (g x pow 3)) * dg +
			ddf * (g x * g x * inv (g x pow 3))`)))(thm_tac (new_rewrite [] []))));
   ((fun arg_tac -> arg_tac (Arg_term (`g x * inv (g x pow 3) = inv (g x pow 2)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`g x * inv (g x pow 2) = inv (g x)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("TWO", [TWO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((fun arg_tac -> (use_arg_then2 ("REAL_POW_2", [REAL_POW_2])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`g x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("lhs_def", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_div *)
let diff2_div = Sections.section_proof ["f";"g";"x"]
`~(g x = &0) ==> nth_diff_strong 2 f x ==> nth_diff_strong 2 g x ==>
	nth_diff_strong 2 (\x. f x / g x) x`
[
   ((BETA_TAC THEN (move ["gn0"]) THEN (move ["df0"]) THEN (move ["dg0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f /\ nth_diff_strong_int 2 int g`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (case THEN ((move ["df"]) THEN (move ["dg"]))))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((split_tac) THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_diff_mul", [nth_diff_mul])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`\x. inv (g x)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   ((((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN ((split_tac) THEN ((TRY done_tac)) THEN (move ["y"])));
   (((((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("diff2_compose_inv", [diff2_compose_inv]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma second_derivative_scale *)
let second_derivative_scale = Sections.section_proof ["f";"c";"x"]
`nth_diff_strong 2 f x ==>
	nth_derivative 2 (\x. c * f x) x = c * nth_derivative 2 f x`
[
   ((BETA_TAC THEN (move ["df0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (move ["df"]))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((BETA_TAC THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_scale", [nth_derivative_scale])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("c", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_add *)
let second_derivative_add = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 f x ==>
	nth_diff_strong 2 g x ==>
	nth_derivative 2 (\x. f x + g x) x = nth_derivative 2 f x + nth_derivative 2 g x`
[
   ((BETA_TAC THEN (move ["df0"]) THEN (move ["dg0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f /\ nth_diff_strong_int 2 int g`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (case THEN ((move ["df"]) THEN (move ["dg"]))))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((split_tac) THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_add", [nth_derivative_add])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sub *)
let second_derivative_sub = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 f x ==>
	nth_diff_strong 2 g x ==>
	nth_derivative 2 (\x. f x - g x) x = nth_derivative 2 f x - nth_derivative 2 g x`
[
   ((BETA_TAC THEN (move ["df0"]) THEN (move ["dg0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f /\ nth_diff_strong_int 2 int g`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (case THEN ((move ["df"]) THEN (move ["dg"]))))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((split_tac) THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_sub", [nth_derivative_sub])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_bounds *)
let second_derivative_compose_bounds = Sections.section_proof ["f";"g";"int";"g_bounds";"dd_bounds"]
`nth_diff_strong_int 2 int g ==>
	bounded_on_int g int g_bounds ==>
	nth_diff_strong_int 2 g_bounds f ==>
	bounded_on_int (\x. nth_derivative 2 f (g x) * derivative g x pow 2 + 
			derivative f (g x) * nth_derivative 2 g x) int dd_bounds ==>
	has_bounded_second_derivative (\x. f (g x)) int dd_bounds`
[
   ((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac));
   ((BETA_TAC THEN (move ["dg"]) THEN (move ["g_bounded"]) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("g_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("g_bounded", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_abs_pos_bounds *)
let second_derivative_abs_pos_bounds = Sections.section_proof ["dd_bounds"]
`interval_pos int ==>
	bounded_on_int (\x. &0) int dd_bounds ==>
	has_bounded_second_derivative abs int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_pos"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_abs_pos", [diff2_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("second_derivative_abs_pos", [second_derivative_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("bounded", [bounded])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
];;

(* Lemma second_derivative_abs_neg_bounds *)
let second_derivative_abs_neg_bounds = Sections.section_proof ["dd_bounds"]
`interval_neg int ==>
	bounded_on_int (\x. &0) int dd_bounds ==>
	has_bounded_second_derivative abs int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_neg"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_abs_neg", [diff2_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_neg", [interval_arith_neg])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("second_derivative_abs_neg", [second_derivative_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_neg", [interval_arith_neg])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("bounded", [bounded])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
];;

(* Lemma second_derivative_compose_abs_pos_bounds *)
let second_derivative_compose_abs_pos_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_pos f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x) int dd_bounds ==>
	has_bounded_second_derivative (\x. abs (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_int"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> &0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_abs_pos", [diff2_compose_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_abs_pos", [second_derivative_compose_abs_pos]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_abs_neg_bounds *)
let second_derivative_compose_abs_neg_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_neg f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. --nth_derivative 2 f x) int dd_bounds ==>
	has_bounded_second_derivative (\x. abs (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_int"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> f x < &0`))) (term_tac (have_gen_tac [](move ["f_ineq"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_neg", [interval_arith_neg])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_abs_neg", [diff2_compose_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_ineq", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_abs_neg", [second_derivative_compose_abs_neg]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_ineq", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_pow_bounds *)
let second_derivative_pow_bounds = Sections.section_proof ["n";"dd_bounds"]
`bounded_on_int (\x. &(n * (n - 1)) * x pow (n - 2)) int dd_bounds ==>
	has_bounded_second_derivative (\x. x pow n) int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_pow_x", [second_derivative_pow_x]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_pow_x", [diff2_pow_x]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_pow_bounds *)
let second_derivative_compose_pow_bounds = Sections.section_proof ["n";"f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. &n * (nth_derivative 2 f x * f x pow (n - 1) +
			&(n - 1) * f x pow (n - 2) * derivative f x pow 2)) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x pow n) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_pow", [diff2_compose_pow]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_pow", [second_derivative_compose_pow]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_pow2_bounds *)
let second_derivative_pow2_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int (\x. &2) int dd_bounds ==>
	has_bounded_second_derivative (\x. x pow 2) int dd_bounds`
[
   ((BETA_TAC THEN (move ["bounded"])) THEN ((((use_arg_then2 ("second_derivative_pow_bounds", [second_derivative_pow_bounds]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("subnn", [subnn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_pow", [real_pow]))(thm_tac (new_rewrite [] []))))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 * (2 - 1) = 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_pow2_bounds *)
let second_derivative_compose_pow2_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. &2 * (nth_derivative 2 f x * f x +
				derivative f x pow 2)) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x pow 2) int dd_bounds`
[
   ((BETA_TAC THEN (move ["df"]) THEN (move ["bounded"])) THEN ((((use_arg_then2 ("second_derivative_compose_pow_bounds", [second_derivative_compose_pow_bounds]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 - 1 = 1`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subnn", [subnn]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_pow3_bounds *)
let second_derivative_pow3_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int (\x. &6 * x) int dd_bounds ==>
	has_bounded_second_derivative (\x. x pow 3) int dd_bounds`
[
   ((BETA_TAC THEN (move ["bounded"])) THEN ((((use_arg_then2 ("second_derivative_pow_bounds", [second_derivative_pow_bounds]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   (((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 * (3 - 1) = 6 /\ 3 - 2 = 1`)))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_pow3_bounds *)
let second_derivative_compose_pow3_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. &3 * (nth_derivative 2 f x * f x pow 2 +
				&2 * f x * derivative f x pow 2)) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x pow 3) int dd_bounds`
[
   ((BETA_TAC THEN (move ["df"]) THEN (move ["bounded"])) THEN ((((use_arg_then2 ("second_derivative_compose_pow_bounds", [second_derivative_compose_pow_bounds]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   (((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 - 1 = 2 /\ 3 - 2 = 1`)))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_atn_bounds *)
let second_derivative_atn_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int (\x. (-- &2 * x) * inv(&1 + x pow 2) pow 2) int dd_bounds ==>
	has_bounded_second_derivative atn int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_atn", [second_derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_atn", [diff2_atn]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_atn_bounds *)
let second_derivative_compose_atn_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. (nth_derivative 2 f x * (&1 + f x * f x) - &2 * f x * derivative f x pow 2) /
			(&1 + f x * f x) pow 2) int dd_bounds ==>
	has_bounded_second_derivative (\x. atn (f x)) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_atn", [diff2_compose_atn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_atn", [second_derivative_compose_atn]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_cos_bounds *)
let second_derivative_cos_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int (\x. -- cos x) int dd_bounds ==>
	has_bounded_second_derivative cos int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("second_derivative_cos", [second_derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_cos", [diff2_cos]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_cos_bounds *)
let second_derivative_compose_cos_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. --(nth_derivative 2 f x * sin (f x) 
		+ cos (f x) * derivative f x pow 2)) int dd_bounds ==>
	has_bounded_second_derivative (\x. cos (f x)) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_cos", [diff2_compose_cos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_cos", [second_derivative_compose_cos]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sin_bounds *)
let second_derivative_sin_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int (\x. -- sin x) int dd_bounds ==>
	has_bounded_second_derivative sin int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("second_derivative_sin", [second_derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_sin", [diff2_sin]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_sin_bounds *)
let second_derivative_compose_sin_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x * cos (f x) 
		- sin (f x) * derivative f x pow 2) int dd_bounds ==>
	has_bounded_second_derivative (\x. sin (f x)) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_sin", [diff2_compose_sin]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_sin", [second_derivative_compose_sin]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_exp_bounds *)
let second_derivative_exp_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int exp int dd_bounds ==>
	has_bounded_second_derivative exp int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("second_derivative_exp", [second_derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_exp", [diff2_exp]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_exp_bounds *)
let second_derivative_compose_exp_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x * exp (f x) 
		+ exp (f x) * derivative f x pow 2) int dd_bounds ==>
	has_bounded_second_derivative (\x. exp (f x)) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_exp", [diff2_compose_exp]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_exp", [second_derivative_compose_exp]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_log_bounds *)
let second_derivative_log_bounds = Sections.section_proof ["dd_bounds"]
`interval_pos int ==>
	bounded_on_int (\x. --inv (x pow 2)) int dd_bounds ==>
	has_bounded_second_derivative log int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_pos"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_log", [diff2_log]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_log", [second_derivative_log]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_log_bounds *)
let second_derivative_compose_log_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_pos f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x / f x - (derivative f x / f x) pow 2)
			int dd_bounds ==>
	has_bounded_second_derivative (\x. log (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_int"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> &0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_log", [diff2_compose_log]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_log", [second_derivative_compose_log]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_inv_bounds *)
let second_derivative_inv_bounds = Sections.section_proof ["dd_bounds"]
`interval_not_zero int ==>
	bounded_on_int (\x. &2 * inv (x pow 3)) int dd_bounds ==>
	has_bounded_second_derivative inv int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int0"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_inv", [diff2_inv]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_inv", [second_derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_inv_bounds *)
let second_derivative_compose_inv_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_not_zero f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. (&2 * derivative f x pow 2 - nth_derivative 2 f x * f x) / f x pow 3) 
			int dd_bounds ==>
	has_bounded_second_derivative (\x. inv (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f0"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> ~(f x = &0)`))) (term_tac (have_gen_tac [](move ["fn0"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_inv", [diff2_compose_inv]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("fn0", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_inv", [second_derivative_compose_inv]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("fn0", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sqrt_bounds *)
let second_derivative_sqrt_bounds = Sections.section_proof ["dd_bounds"]
`interval_pos int ==>
	bounded_on_int (\x. --inv (&4 * sqrt (x pow 3))) int dd_bounds ==>
	has_bounded_second_derivative sqrt int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_pos"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_sqrt", [diff2_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_sqrt", [second_derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_sqrt_bounds *)
let second_derivative_compose_sqrt_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_pos f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. (&2 * nth_derivative 2 f x * f x - derivative f x pow 2) /
			(&4 * sqrt (f x pow 3))) 
			int dd_bounds ==>
	has_bounded_second_derivative (\x. sqrt (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_int"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> &0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_sqrt", [diff2_compose_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_sqrt", [second_derivative_compose_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_acs_bounds *)
let second_derivative_acs_bounds = Sections.section_proof ["dd_bounds"]
`iabs int < &1 ==>
	bounded_on_int (\x. --(x / sqrt ((&1 - x * x) pow 3))) int dd_bounds ==>
	has_bounded_second_derivative acs int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_abs"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_acs", [diff2_acs]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_acs", [second_derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_acs_bounds *)
let second_derivative_compose_acs_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> iabs f_bounds < &1 ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. --((nth_derivative 2 f x * (&1 - f x * f x) + f x * derivative f x pow 2) /
				sqrt ((&1 - f x * f x) pow 3))) int dd_bounds ==>
	has_bounded_second_derivative (\x. acs (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_abs"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> abs (f x) < &1`))) (term_tac (have_gen_tac [](move ["fabs"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_acs", [diff2_compose_acs]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("fabs", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_acs", [second_derivative_compose_acs]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("fabs", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_asn_bounds *)
let second_derivative_asn_bounds = Sections.section_proof ["dd_bounds"]
`iabs int < &1 ==>
	bounded_on_int (\x. x / sqrt ((&1 - x * x) pow 3)) int dd_bounds ==>
	has_bounded_second_derivative asn int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_abs"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_asn", [diff2_asn]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_asn", [second_derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_asn_bounds *)
let second_derivative_compose_asn_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> iabs f_bounds < &1 ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. (nth_derivative 2 f x * (&1 - f x * f x) + f x * derivative f x pow 2) /
				sqrt ((&1 - f x * f x) pow 3)) int dd_bounds ==>
	has_bounded_second_derivative (\x. asn (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_abs"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> abs (f x) < &1`))) (term_tac (have_gen_tac [](move ["fabs"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_asn", [diff2_compose_asn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("fabs", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_asn", [second_derivative_compose_asn]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("fabs", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma interval_arith_gt *)
let interval_arith_gt = Sections.section_proof ["x";"int";"f"]
`interval_arith x int /\ interval_gt f int ==> f < x`
[
   (((((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_gt", [interval_gt]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_matan_bounds *)
let second_derivative_matan_bounds = Sections.section_proof ["dd_bounds"]
`interval_gt (-- &1) int ==>
	bounded_on_int ddmatan int dd_bounds ==>
	has_bounded_second_derivative matan int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_gt"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_matan", [diff2_matan]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_gt", [interval_arith_gt])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_matan", [second_derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_gt", [interval_arith_gt])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_matan_bounds *)
let second_derivative_compose_matan_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_gt (-- &1) f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x * dmatan (f x) + derivative f x pow 2 * ddmatan (f x))
			int dd_bounds ==>
	has_bounded_second_derivative (\x. matan (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_int"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> -- &1 < f x`))) (term_tac (have_gen_tac [](move ["f_ineq"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_gt", [interval_arith_gt])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_matan", [diff2_compose_matan]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_ineq", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_matan", [second_derivative_compose_matan]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_ineq", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_scale_bounds *)
let second_derivative_scale_bounds = Sections.section_proof ["c";"f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. c * nth_derivative 2 f x) int dd_bounds ==>
	has_bounded_second_derivative (\x. c * f x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (move ["df"]) THEN (move ["b"]));
   (((((use_arg_then2 ("nth_diff_scale", [nth_diff_scale]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("second_derivative_scale", [second_derivative_scale]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (exact_tac) THEN (done_tac));
];;

(* Lemma second_derivative_add_bounds *)
let second_derivative_add_bounds = Sections.section_proof ["f";"g";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	nth_diff_strong_int 2 int g ==>
	bounded_on_int (\x. nth_derivative 2 f x + nth_derivative 2 g x) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x + g x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["b"]));
   (((((use_arg_then2 ("nth_diff_add", [nth_diff_add]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("second_derivative_add", [second_derivative_add]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sub_bounds *)
let second_derivative_sub_bounds = Sections.section_proof ["f";"g";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	nth_diff_strong_int 2 int g ==>
	bounded_on_int (\x. nth_derivative 2 f x - nth_derivative 2 g x) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x - g x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["b"]));
   (((((use_arg_then2 ("nth_diff_sub", [nth_diff_sub]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("second_derivative_sub", [second_derivative_sub]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_mul_bounds *)
let second_derivative_mul_bounds = Sections.section_proof ["f";"g";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	nth_diff_strong_int 2 int g ==>
	bounded_on_int (\x. f x * nth_derivative 2 g x + &2 * derivative f x * derivative g x +
			nth_derivative 2 f x * g x) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x * g x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["b"]));
   (((((use_arg_then2 ("nth_diff_mul", [nth_diff_mul]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("second_derivative_mul", [second_derivative_mul]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_div_bounds *)
let second_derivative_div_bounds = Sections.section_proof ["f";"g";"g_bounds";"dd_bounds"]
`bounded_on_int g int g_bounds ==> interval_not_zero g_bounds ==>
	nth_diff_strong_int 2 int f ==>
	nth_diff_strong_int 2 int g ==>
	bounded_on_int (\x. ((nth_derivative 2 f x * g x - f x * nth_derivative 2 g x) * g x -
	  &2 * derivative g x * (derivative f x * g x - f x * derivative g x)) / g x pow 3) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x / g x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))))) THEN (move ["bg"]) THEN (move ["gn0"]) THEN (simp_tac) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["b"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> ~(g x = &0)`))) (term_tac (have_gen_tac [](move ["g0"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN (((use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (disch_tac [])) THEN (clear_assumption "interval_arith_not_zero") THEN (DISCH_THEN apply_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`g_bounds`))) (term_tac exists_tac)) THEN (((use_arg_then2 ("bg", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((THENL_FIRST) ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])) (((((use_arg_then2 ("diff2_div", [diff2_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("g0", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))))) THEN (done_tac)));
   (((((use_arg_then2 ("second_derivative_div", [second_derivative_div]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("g0", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section SecondDerivativeBound *)
let nth_diff_strong2_eq_alt = Sections.finalize_theorem nth_diff_strong2_eq_alt;;
let nth_diff_strong2_eq = Sections.finalize_theorem nth_diff_strong2_eq;;
let lin_approx_compose = Sections.finalize_theorem lin_approx_compose;;
let second_derivative_abs_pos = Sections.finalize_theorem second_derivative_abs_pos;;
let second_derivative_abs_neg = Sections.finalize_theorem second_derivative_abs_neg;;
let diff2_abs_pos = Sections.finalize_theorem diff2_abs_pos;;
let diff2_abs_neg = Sections.finalize_theorem diff2_abs_neg;;
let pow_x_has_real_derivative = Sections.finalize_theorem pow_x_has_real_derivative;;
let second_derivative_pow_x = Sections.finalize_theorem second_derivative_pow_x;;
let diff2_pow_x = Sections.finalize_theorem diff2_pow_x;;
let second_derivative_pow2_x = Sections.finalize_theorem second_derivative_pow2_x;;
let second_derivative_pow3_x = Sections.finalize_theorem second_derivative_pow3_x;;
let second_derivative_atn_eq = Sections.finalize_theorem second_derivative_atn_eq;;
let second_derivative_atn = Sections.finalize_theorem second_derivative_atn;;
let diff2_atn = Sections.finalize_theorem diff2_atn;;
let second_derivative_cos = Sections.finalize_theorem second_derivative_cos;;
let diff2_cos = Sections.finalize_theorem diff2_cos;;
let second_derivative_sin = Sections.finalize_theorem second_derivative_sin;;
let diff2_sin = Sections.finalize_theorem diff2_sin;;
let second_derivative_exp = Sections.finalize_theorem second_derivative_exp;;
let diff2_exp = Sections.finalize_theorem diff2_exp;;
let second_derivative_log = Sections.finalize_theorem second_derivative_log;;
let diff2_log = Sections.finalize_theorem diff2_log;;
let second_derivative_inv = Sections.finalize_theorem second_derivative_inv;;
let diff2_inv = Sections.finalize_theorem diff2_inv;;
let SQRT_POW = Sections.finalize_theorem SQRT_POW;;
let second_derivative_sqrt = Sections.finalize_theorem second_derivative_sqrt;;
let diff2_sqrt = Sections.finalize_theorem diff2_sqrt;;
let real_powS = Sections.finalize_theorem real_powS;;
let second_derivative_acs = Sections.finalize_theorem second_derivative_acs;;
let diff2_acs = Sections.finalize_theorem diff2_acs;;
let second_derivative_asn = Sections.finalize_theorem second_derivative_asn;;
let diff2_asn = Sections.finalize_theorem diff2_asn;;
let second_derivative_matan = Sections.finalize_theorem second_derivative_matan;;
let diff2_matan = Sections.finalize_theorem diff2_matan;;
let REAL_CONTINUOUS_OPEN_PREIMAGE = Sections.finalize_theorem REAL_CONTINUOUS_OPEN_PREIMAGE;;
let second_derivative_compose = Sections.finalize_theorem second_derivative_compose;;
let diff2_compose = Sections.finalize_theorem diff2_compose;;
let continuous_not0_exists_open = Sections.finalize_theorem continuous_not0_exists_open;;
let continuous_gt_exists_open = Sections.finalize_theorem continuous_gt_exists_open;;
let continuous_lt_exists_open = Sections.finalize_theorem continuous_lt_exists_open;;
let second_derivative_compose_abs_pos = Sections.finalize_theorem second_derivative_compose_abs_pos;;
let second_derivative_compose_abs_neg = Sections.finalize_theorem second_derivative_compose_abs_neg;;
let second_derivative_compose_pow = Sections.finalize_theorem second_derivative_compose_pow;;
let second_derivative_compose_pow2 = Sections.finalize_theorem second_derivative_compose_pow2;;
let second_derivative_compose_pow3 = Sections.finalize_theorem second_derivative_compose_pow3;;
let second_derivative_compose_atn = Sections.finalize_theorem second_derivative_compose_atn;;
let second_derivative_compose_cos = Sections.finalize_theorem second_derivative_compose_cos;;
let second_derivative_compose_sin = Sections.finalize_theorem second_derivative_compose_sin;;
let second_derivative_compose_exp = Sections.finalize_theorem second_derivative_compose_exp;;
let second_derivative_compose_log = Sections.finalize_theorem second_derivative_compose_log;;
let second_derivative_compose_inv = Sections.finalize_theorem second_derivative_compose_inv;;
let second_derivative_compose_sqrt = Sections.finalize_theorem second_derivative_compose_sqrt;;
let second_derivative_compose_acs = Sections.finalize_theorem second_derivative_compose_acs;;
let second_derivative_compose_asn = Sections.finalize_theorem second_derivative_compose_asn;;
let second_derivative_compose_matan = Sections.finalize_theorem second_derivative_compose_matan;;
let diff2_compose_abs_pos = Sections.finalize_theorem diff2_compose_abs_pos;;
let diff2_compose_abs_neg = Sections.finalize_theorem diff2_compose_abs_neg;;
let diff2_compose_pow = Sections.finalize_theorem diff2_compose_pow;;
let diff2_compose_atn = Sections.finalize_theorem diff2_compose_atn;;
let diff2_compose_cos = Sections.finalize_theorem diff2_compose_cos;;
let diff2_compose_sin = Sections.finalize_theorem diff2_compose_sin;;
let diff2_compose_exp = Sections.finalize_theorem diff2_compose_exp;;
let diff2_compose_log = Sections.finalize_theorem diff2_compose_log;;
let diff2_compose_inv = Sections.finalize_theorem diff2_compose_inv;;
let diff2_compose_sqrt = Sections.finalize_theorem diff2_compose_sqrt;;
let diff2_compose_acs = Sections.finalize_theorem diff2_compose_acs;;
let diff2_compose_asn = Sections.finalize_theorem diff2_compose_asn;;
let diff2_compose_matan = Sections.finalize_theorem diff2_compose_matan;;
let second_derivative_mul = Sections.finalize_theorem second_derivative_mul;;
let second_derivative_div = Sections.finalize_theorem second_derivative_div;;
let diff2_div = Sections.finalize_theorem diff2_div;;
let second_derivative_scale = Sections.finalize_theorem second_derivative_scale;;
let second_derivative_add = Sections.finalize_theorem second_derivative_add;;
let second_derivative_sub = Sections.finalize_theorem second_derivative_sub;;
let second_derivative_compose_bounds = Sections.finalize_theorem second_derivative_compose_bounds;;
let second_derivative_abs_pos_bounds = Sections.finalize_theorem second_derivative_abs_pos_bounds;;
let second_derivative_abs_neg_bounds = Sections.finalize_theorem second_derivative_abs_neg_bounds;;
let second_derivative_compose_abs_pos_bounds = Sections.finalize_theorem second_derivative_compose_abs_pos_bounds;;
let second_derivative_compose_abs_neg_bounds = Sections.finalize_theorem second_derivative_compose_abs_neg_bounds;;
let second_derivative_pow_bounds = Sections.finalize_theorem second_derivative_pow_bounds;;
let second_derivative_compose_pow_bounds = Sections.finalize_theorem second_derivative_compose_pow_bounds;;
let second_derivative_pow2_bounds = Sections.finalize_theorem second_derivative_pow2_bounds;;
let second_derivative_compose_pow2_bounds = Sections.finalize_theorem second_derivative_compose_pow2_bounds;;
let second_derivative_pow3_bounds = Sections.finalize_theorem second_derivative_pow3_bounds;;
let second_derivative_compose_pow3_bounds = Sections.finalize_theorem second_derivative_compose_pow3_bounds;;
let second_derivative_atn_bounds = Sections.finalize_theorem second_derivative_atn_bounds;;
let second_derivative_compose_atn_bounds = Sections.finalize_theorem second_derivative_compose_atn_bounds;;
let second_derivative_cos_bounds = Sections.finalize_theorem second_derivative_cos_bounds;;
let second_derivative_compose_cos_bounds = Sections.finalize_theorem second_derivative_compose_cos_bounds;;
let second_derivative_sin_bounds = Sections.finalize_theorem second_derivative_sin_bounds;;
let second_derivative_compose_sin_bounds = Sections.finalize_theorem second_derivative_compose_sin_bounds;;
let second_derivative_exp_bounds = Sections.finalize_theorem second_derivative_exp_bounds;;
let second_derivative_compose_exp_bounds = Sections.finalize_theorem second_derivative_compose_exp_bounds;;
let second_derivative_log_bounds = Sections.finalize_theorem second_derivative_log_bounds;;
let second_derivative_compose_log_bounds = Sections.finalize_theorem second_derivative_compose_log_bounds;;
let second_derivative_inv_bounds = Sections.finalize_theorem second_derivative_inv_bounds;;
let second_derivative_compose_inv_bounds = Sections.finalize_theorem second_derivative_compose_inv_bounds;;
let second_derivative_sqrt_bounds = Sections.finalize_theorem second_derivative_sqrt_bounds;;
let second_derivative_compose_sqrt_bounds = Sections.finalize_theorem second_derivative_compose_sqrt_bounds;;
let second_derivative_acs_bounds = Sections.finalize_theorem second_derivative_acs_bounds;;
let second_derivative_compose_acs_bounds = Sections.finalize_theorem second_derivative_compose_acs_bounds;;
let second_derivative_asn_bounds = Sections.finalize_theorem second_derivative_asn_bounds;;
let second_derivative_compose_asn_bounds = Sections.finalize_theorem second_derivative_compose_asn_bounds;;
let interval_arith_gt = Sections.finalize_theorem interval_arith_gt;;
let second_derivative_matan_bounds = Sections.finalize_theorem second_derivative_matan_bounds;;
let second_derivative_compose_matan_bounds = Sections.finalize_theorem second_derivative_compose_matan_bounds;;
let second_derivative_scale_bounds = Sections.finalize_theorem second_derivative_scale_bounds;;
let second_derivative_add_bounds = Sections.finalize_theorem second_derivative_add_bounds;;
let second_derivative_sub_bounds = Sections.finalize_theorem second_derivative_sub_bounds;;
let second_derivative_mul_bounds = Sections.finalize_theorem second_derivative_mul_bounds;;
let second_derivative_div_bounds = Sections.finalize_theorem second_derivative_div_bounds;;
Sections.end_section "SecondDerivativeBound";;

(* Section TaylorArith *)
Sections.begin_section "TaylorArith";;
let cell_domain = new_definition `cell_domain x y z w <=> 
	x <= y /\ y <= z /\ y - x <= w /\ z - y <= w`;;

(* Lemma taylor_x *)
let taylor_x = Sections.section_proof ["x";"y";"z";"w"]
`cell_domain x y z w ==>
	taylor_interval (\x. x) x y z w (y, y) (&1, &1) (&0, &0)`
[
   ((((use_arg_then2 ("cell_domain", [cell_domain]))(thm_tac (new_rewrite [] [])))) THEN (move ["ineqs"]));
   ((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("lin_approx_x", [lin_approx_x]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (move ["_"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["q"]) THEN (simp_tac)));
   (((((use_arg_then2 ("REAL_CONTINUOUS_AT_ID", [REAL_CONTINUOUS_AT_ID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]));
   ((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i < 2 <=> i = 0 \/ i = 1`)))(thm_tac (new_rewrite [] [])))) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma taylor_const *)
let taylor_const = Sections.section_proof ["c";"x";"y";"z";"w"]
`cell_domain x y z w ==>
	taylor_interval (\x. c) x y z w (c, c) (&0, &0) (&0, &0)`
[
   ((((use_arg_then2 ("cell_domain", [cell_domain]))(thm_tac (new_rewrite [] [])))) THEN (move ["ineqs"]));
   ((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("lin_approx_const", [lin_approx_const]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (move ["_"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["q"]) THEN (simp_tac)));
   (((((use_arg_then2 ("REAL_CONTINUOUS_CONST", [REAL_CONTINUOUS_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]));
   ((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i < 2 <=> i = 0 \/ i = 1`)))(thm_tac (new_rewrite [] [])))) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real->real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))); Sections.add_section_var (mk_var ("y", (`:real`))); Sections.add_section_var (mk_var ("z", (`:real`))); Sections.add_section_var (mk_var ("w", (`:real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("df_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("dd_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("f_lo", (`:real`))); Sections.add_section_var (mk_var ("f_hi", (`:real`))); Sections.add_section_var (mk_var ("df_lo", (`:real`))); Sections.add_section_var (mk_var ("df_hi", (`:real`))));;

(* Lemma taylor_f_bounds *)
let taylor_f_bounds = Sections.section_proof ["df";"dd";"lo";"hi";"t"]
`taylor_interval f x y z w (f_lo, f_hi) df_bounds dd_bounds ==>
	iabs df_bounds = df ==>
	iabs dd_bounds = dd ==>
	w * (df + w * dd * inv(&2)) <= t ==>
	f_hi + t <= hi ==> lo <= f_lo - t ==>
	bounded_on_int f (x, z) (lo, hi)`
[
   (BETA_TAC THEN (move ["taylor_f"]) THEN (move ["iabs_df"]) THEN (move ["iabs_dd"]) THEN (move ["t_ineq"]) THEN (move ["hi_ineq"]) THEN (move ["lo_ineq"]));
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))))) THEN (move ["p"]) THEN (move ["ineq"]));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("taylor_upper_bound", [taylor_upper_bound])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("EQ_SYM", [EQ_SYM])) (fun fst_arg -> (use_arg_then2 ("iabs_dd", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("taylor_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("taylor_lower_bound", [taylor_lower_bound])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("EQ_SYM", [EQ_SYM])) (fun fst_arg -> (use_arg_then2 ("iabs_dd", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("taylor_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   (((simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("iabs_df", []))(thm_tac (new_rewrite [] []))))) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)) THEN (move ["ineq1"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)) THEN (move ["ineq2"]));
   ((((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN ((use_arg_then2 ("hi_ineq", [])) (disch_tac [])) THEN (clear_assumption "hi_ineq") THEN ((use_arg_then2 ("lo_ineq", [])) (disch_tac [])) THEN (clear_assumption "lo_ineq") THEN ((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("ineq1", [])) (disch_tac [])) THEN (clear_assumption "ineq1") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma taylor_df_bounds *)
let taylor_df_bounds = Sections.section_proof ["dd";"lo";"hi"]
`taylor_interval f x y z w f_bounds (df_lo, df_hi) dd_bounds ==>
	iabs dd_bounds = dd ==>
	df_hi + w * dd <= hi ==>
	lo <= df_lo - w * dd ==>
	bounded_on_int (derivative f) (x, z) (lo, hi)`
[
   (BETA_TAC THEN (move ["taylor_f"]) THEN (move ["iabs_dd"]) THEN (move ["hi_ineq"]) THEN (move ["lo_ineq"]));
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))))) THEN (move ["p"]) THEN (move ["ineq"]));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("taylor_derivative_lower_bound", [taylor_derivative_lower_bound])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("EQ_SYM", [EQ_SYM])) (fun fst_arg -> (use_arg_then2 ("iabs_dd", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("taylor_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("taylor_derivative_upper_bound", [taylor_derivative_upper_bound])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("EQ_SYM", [EQ_SYM])) (fun fst_arg -> (use_arg_then2 ("iabs_dd", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("taylor_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   ((((use_arg_then2 ("hi_ineq", [])) (disch_tac [])) THEN (clear_assumption "hi_ineq") THEN ((use_arg_then2 ("lo_ineq", [])) (disch_tac [])) THEN (clear_assumption "lo_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma bounded_on_int_compose *)
let bounded_on_int_compose = Sections.section_proof ["g";"int";"g_bounds"]
`bounded_on_int g int g_bounds ==>
	bounded_on_int f g_bounds f_bounds ==>
	bounded_on_int (\x. f (g x)) int f_bounds`
[
   ((repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (move ["g_bounded"]) THEN (move ["f_bounded"]) THEN (move ["x"]) THEN (move ["ineq"]) THEN (simp_tac));
   (((((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("g_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma bounded_on_int_imp_interval_arith *)
let bounded_on_int_imp_interval_arith = Sections.section_proof ["int"]
`bounded_on_int f int f_bounds ==>
	interval_arith y int ==> interval_arith (f y) f_bounds`
[
   ((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (move ["bounded_f"]) THEN (move ["int_y"]));
   ((((use_arg_then2 ("bounded_f", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma taylor_interval_narrow *)
let taylor_interval_narrow = Sections.section_proof ["x0";"z0";"w0"]
`taylor_interval f x y z w f_bounds df_bounds dd_bounds ==>
	cell_domain x0 y z0 w0 ==>
	x <= x0 ==> z0 <= z ==>
	taylor_interval f x0 y z0 w0 f_bounds df_bounds dd_bounds`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("cell_domain", [cell_domain]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ((case THEN ((move ["ineq"]) THEN (move ["lin"]))) THEN (move ["dd"]))) THEN (move ["c"]) THEN (move ["i1"]) THEN (move ["i2"]));
   ((THENL_FIRST) (((((use_arg_then2 ("lin", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))) THEN (split_tac)) ((((use_arg_then2 ("i2", [])) (disch_tac [])) THEN (clear_assumption "i2") THEN ((use_arg_then2 ("i1", [])) (disch_tac [])) THEN (clear_assumption "i1") THEN ((use_arg_then2 ("c", [])) (disch_tac [])) THEN (clear_assumption "c") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("dd", [])) (disch_tac [])) THEN (clear_assumption "dd") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (move ["df"])));
   ((split_tac) THEN (move ["p"]) THEN (move ["int_p"]));
   ((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("i2", [])) (disch_tac [])) THEN (clear_assumption "i2") THEN ((use_arg_then2 ("i1", [])) (disch_tac [])) THEN (clear_assumption "i1") THEN ((use_arg_then2 ("int_p", [])) (disch_tac [])) THEN (clear_assumption "int_p") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL interval_arith)))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("i2", [])) (disch_tac [])) THEN (clear_assumption "i2") THEN ((use_arg_then2 ("i1", [])) (disch_tac [])) THEN (clear_assumption "i1") THEN ((use_arg_then2 ("int_p", [])) (disch_tac [])) THEN (clear_assumption "int_p") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL interval_arith)))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section TaylorArith *)
let taylor_x = Sections.finalize_theorem taylor_x;;
let taylor_const = Sections.finalize_theorem taylor_const;;
let taylor_f_bounds = Sections.finalize_theorem taylor_f_bounds;;
let taylor_df_bounds = Sections.finalize_theorem taylor_df_bounds;;
let bounded_on_int_compose = Sections.finalize_theorem bounded_on_int_compose;;
let bounded_on_int_imp_interval_arith = Sections.finalize_theorem bounded_on_int_imp_interval_arith;;
let taylor_interval_narrow = Sections.finalize_theorem taylor_interval_narrow;;
Sections.end_section "TaylorArith";;

(* Close the module *)
end;;
